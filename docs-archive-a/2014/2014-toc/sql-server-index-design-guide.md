---
title: SQL Server インデックス デザイン ガイド | Microsoft Docs
ms.custom: ''
ms.date: 06/14/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: ''
ms.topic: conceptual
ms.assetid: b856ee9a-49e7-4fab-a88d-48a633fce269
author: rothja
ms.author: jroth
ms.openlocfilehash: 1f5ad72413fe71004fb1c5f125969b984db815d3
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/04/2020
ms.locfileid: "87632208"
---
# <a name="sql-server-index-design-guide"></a><span data-ttu-id="45d3b-102">SQL Server インデックス デザイン ガイド</span><span class="sxs-lookup"><span data-stu-id="45d3b-102">SQL Server Index Design Guide</span></span>

  <span data-ttu-id="45d3b-103">不完全なデザインのインデックスやインデックスの不備は、データベース アプリケーションのボトルネックの主な原因となります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-103">Poorly designed indexes and a lack of indexes are primary sources of database application bottlenecks.</span></span> <span data-ttu-id="45d3b-104">効率的なインデックスのデザインは、データベースとアプリケーションの高パフォーマンスを実現するための最優先事項です。</span><span class="sxs-lookup"><span data-stu-id="45d3b-104">Designing efficient indexes is paramount to achieving good database and application performance.</span></span> <span data-ttu-id="45d3b-105">この SQL Server インデックス デザイン ガイドには、効果的なインデックスをデザインしてアプリケーションのニーズを満たすために役立つ情報および推奨事項が含まれています。</span><span class="sxs-lookup"><span data-stu-id="45d3b-105">This SQL Server index design guide contains information and best practices to help you design effective indexes to meet the needs of your application.</span></span>  
  
<span data-ttu-id="45d3b-106">**に適用さ**れます。特に指定が [!INCLUDE[ssVersion2005](../includes/ssversion2005-md.md)] [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)] ない限り、を使用します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-106">**Applies to**: [!INCLUDE[ssVersion2005](../includes/ssversion2005-md.md)] through [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)] unless noted otherwise.</span></span>  
  
 <span data-ttu-id="45d3b-107">このガイドでは、 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]で使用できるインデックスの種類に関して一般的な知識があることを前提としています。</span><span class="sxs-lookup"><span data-stu-id="45d3b-107">This guide assumes the reader has a general understanding of the index types available in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="45d3b-108">インデックスの種類に関する全般的な説明については、「 [インデックス](../relational-databases/indexes/indexes.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="45d3b-108">For a general description of index types, see [Index Types](../relational-databases/indexes/indexes.md).</span></span>  
  
##  <a name="in-this-guide"></a><a name="Top"></a><span data-ttu-id="45d3b-109">このガイドの手順</span><span class="sxs-lookup"><span data-stu-id="45d3b-109">In This Guide</span></span>  

 [<span data-ttu-id="45d3b-110">インデックスのデザインの基礎</span><span class="sxs-lookup"><span data-stu-id="45d3b-110">Index Design Basics</span></span>](#Basics)  
  
 [<span data-ttu-id="45d3b-111">インデックスのデザインに関する一般的なガイドライン</span><span class="sxs-lookup"><span data-stu-id="45d3b-111">General Index Design Guidelines</span></span>](#General_Design)  
  
 [<span data-ttu-id="45d3b-112">クラスター化インデックスのデザインガイドライン</span><span class="sxs-lookup"><span data-stu-id="45d3b-112">Clustered Index Design Guidelines</span></span>](#Clustered)  
  
 [<span data-ttu-id="45d3b-113">非クラスター化インデックスのデザインガイドライン</span><span class="sxs-lookup"><span data-stu-id="45d3b-113">Nonclustered Index Design Guidelines</span></span>](#Nonclustered)  
  
 [<span data-ttu-id="45d3b-114">一意インデックスのデザインガイドライン</span><span class="sxs-lookup"><span data-stu-id="45d3b-114">Unique Index Design Guidelines</span></span>](#Unique)  
  
 [<span data-ttu-id="45d3b-115">フィルター選択されたインデックスのデザインガイドライン</span><span class="sxs-lookup"><span data-stu-id="45d3b-115">Filtered Index Design Guidelines</span></span>](#Filtered)  
  
 [<span data-ttu-id="45d3b-116">その他の参考資料</span><span class="sxs-lookup"><span data-stu-id="45d3b-116">Additional Reading</span></span>](#Additional_Reading)  
  
##  <a name="index-design-basics"></a><a name="Basics"></a> <span data-ttu-id="45d3b-117">インデックスのデザインの基礎</span><span class="sxs-lookup"><span data-stu-id="45d3b-117">Index Design Basics</span></span>  

 <span data-ttu-id="45d3b-118">インデックスとは、テーブルまたはビューに関連付けられたディスク上の構造で、テーブルやビューからの行の取得を高速化します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-118">An index is an on-disk structure associated with a table or view that speeds retrieval of rows from the table or view.</span></span> <span data-ttu-id="45d3b-119">インデックスには、テーブル内またはビュー内の 1 つ以上の列から構築されたキーが含まれています。</span><span class="sxs-lookup"><span data-stu-id="45d3b-119">An index contains keys built from one or more columns in the table or view.</span></span> <span data-ttu-id="45d3b-120">これらのキーは 1 つの構造 (B-Tree) 内に格納されます。SQL Server はこの構造を使用して、キー値に関連した 1 つ以上の行を効率よく迅速に検出できます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-120">These keys are stored in a structure (B-tree) that enables SQL Server to find the row or rows associated with the key values quickly and efficiently.</span></span>  
  
 <span data-ttu-id="45d3b-121">データベースとワークロードに適したインデックスの選択は、クエリの速度と更新コストのバランスを取る必要がある複雑な作業です。</span><span class="sxs-lookup"><span data-stu-id="45d3b-121">The selection of the right indexes for a database and its workload is a complex balancing act between query speed and update cost.</span></span> <span data-ttu-id="45d3b-122">インデックス キー内の列数が少ないインデックスを使用すると、ディスク領域とメンテナンスのオーバーヘッドが少なくて済みます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-122">Narrow indexes, or indexes with few columns in the index key, require less disk space and maintenance overhead.</span></span> <span data-ttu-id="45d3b-123">これに対して、列数の多いインデックスを使用すると、より多くのクエリに対応できます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-123">Wide indexes, on the other hand, cover more queries.</span></span> <span data-ttu-id="45d3b-124">効率の高いインデックスを決定するには、さまざまなデザインをテストする必要があります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-124">You may have to experiment with several different designs before finding the most efficient index.</span></span> <span data-ttu-id="45d3b-125">インデックスは、データベース スキーマやアプリケーションのデザインに影響を与えずに追加、変更、および削除できます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-125">Indexes can be added, modified, and dropped without affecting the database schema or application design.</span></span> <span data-ttu-id="45d3b-126">さまざまなデザインのインデックスを積極的にテストするようにしてください。</span><span class="sxs-lookup"><span data-stu-id="45d3b-126">Therefore, you should not hesitate to experiment with different indexes.</span></span>  
  
 <span data-ttu-id="45d3b-127">[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] のクエリ オプティマイザーでは、多くの場合、最も効率的なインデックスが選択されます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-127">The query optimizer in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] reliably chooses the most effective index in the vast majority of cases.</span></span> <span data-ttu-id="45d3b-128">インデックスのデザインの全体的な考え方としては、クエリ オプティマイザーでインデックスを選択するための選択肢として、さまざまなデザインのインデックスを用意し、オプティマイザーに決定を任せる必要があります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-128">Your overall index design strategy should provide a variety of indexes for the query optimizer to choose from and trust it to make the right decision.</span></span> <span data-ttu-id="45d3b-129">このようにすると、分析時間を短縮でき、さまざまな状況でパフォーマンスを向上できます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-129">This reduces analysis time and produces good performance over a variety of situations.</span></span> <span data-ttu-id="45d3b-130">クエリ オプティマイザーで特定のクエリに使用されるインデックスを確認するには、 [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)]で、 **[クエリ]** メニューの **[実際の実行プランを含める]** を選択します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-130">To see which indexes the query optimizer uses for a specific query, in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)], on the **Query** menu, select **Include Actual Execution Plan**.</span></span>  
  
 <span data-ttu-id="45d3b-131">インデックスを使用しても、常にパフォーマンスが向上するわけではありません。また、パフォーマンスが優れていても、常にインデックスが効率的に使用されているわけでもありません。</span><span class="sxs-lookup"><span data-stu-id="45d3b-131">Do not always equate index usage with good performance, and good performance with efficient index use.</span></span> <span data-ttu-id="45d3b-132">インデックスを使用すれば常にパフォーマンスが向上するならば、クエリ オプティマイザーのジョブは単純です。</span><span class="sxs-lookup"><span data-stu-id="45d3b-132">If using an index always helped produce the best performance, the job of the query optimizer would be simple.</span></span> <span data-ttu-id="45d3b-133">しかし実際には、不適切なインデックスを選択すると、最適なパフォーマンスを実現することはできません。</span><span class="sxs-lookup"><span data-stu-id="45d3b-133">In reality, an incorrect index choice can cause less than optimal performance.</span></span> <span data-ttu-id="45d3b-134">したがって、クエリ オプティマイザーでは、パフォーマンスの向上につながる場合にのみインデックスまたはインデックスの組み合わせが選択され、パフォーマンスの低下につながる場合、インデックス付き検索は実行されません。</span><span class="sxs-lookup"><span data-stu-id="45d3b-134">Therefore, the task of the query optimizer is to select an index, or combination of indexes, only when it will improve performance, and to avoid indexed retrieval when it will hinder performance.</span></span>  
  
### <a name="index-design-tasks"></a><span data-ttu-id="45d3b-135">インデックスのデザインの作業</span><span class="sxs-lookup"><span data-stu-id="45d3b-135">Index Design Tasks</span></span>  

 <span data-ttu-id="45d3b-136">インデックスをデザインするには、次の作業を行うことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="45d3b-136">The follow tasks make up our recommended strategy for designing indexes:</span></span>  
  
1.  <span data-ttu-id="45d3b-137">データベース自体の特性を理解します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-137">Understand the characteristics of the database itself.</span></span> <span data-ttu-id="45d3b-138">たとえば、データが頻繁に変更されるオンライン トランザクション処理 (OLTP) データベースであるか、主に読み取り専用データが格納されており非常に大きなデータ セットの高速処理を要する意思決定支援システム (DSS) データベースまたはデータ ウェアハウジング (OLAP) データベースであるかを理解する必要があります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-138">For example, is it an online transaction processing (OLTP) database with frequent data modifications, or a Decision Support System (DSS) or data warehousing (OLAP) database that contains primarily read-only data and must process very large data sets quickly.</span></span> <span data-ttu-id="45d3b-139">[!INCLUDE[ssSQL11](../includes/sssql11-md.md)]で、 *xVelocity メモリ最適化列ストア* インデックスは、一般的なデータ ウェアハウスのデータ セットに特に適しています。</span><span class="sxs-lookup"><span data-stu-id="45d3b-139">In [!INCLUDE[ssSQL11](../includes/sssql11-md.md)], *xVelocity memory optimized columnstore* index is especially appropriate for typical data warehousing data sets.</span></span> <span data-ttu-id="45d3b-140">列ストア インデックスによって、フィルター処理クエリ、集計クエリ、グループ化クエリ、スター結合クエリなどの一般的なデータ ウェアハウス クエリのパフォーマンスを向上することで、ユーザーが快適にデータ ウェアハウスを利用できるようになります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-140">Columnstore indexes can transform the data warehousing experience for users by enabling faster performance for common data warehousing queries such as filtering, aggregating, grouping, and star-join queries.</span></span> <span data-ttu-id="45d3b-141">詳細については、「[列ストアインデックスの説明](../relational-databases/indexes/columnstore-indexes-described.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="45d3b-141">For more information, see [Columnstore Indexes Described](../relational-databases/indexes/columnstore-indexes-described.md).</span></span>  
  
2.  <span data-ttu-id="45d3b-142">最もよく使用されるクエリの特性を理解します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-142">Understand the characteristics of the most frequently used queries.</span></span> <span data-ttu-id="45d3b-143">たとえば、よく使用されるクエリの中に、複数のテーブルを結合するクエリがあることを把握していると、使用する最適なインデックスの種類を決定するときに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-143">For example, knowing that a frequently used query joins two or more tables will help you determine the best type of indexes to use.</span></span>  
  
3.  <span data-ttu-id="45d3b-144">クエリで使用される列の特性を理解します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-144">Understand the characteristics of the columns used in the queries.</span></span> <span data-ttu-id="45d3b-145">たとえば、整数データ型を格納する列で、一意の列または NULL 値を許容しない列であれば、インデックスに適しています。</span><span class="sxs-lookup"><span data-stu-id="45d3b-145">For example, an index is ideal for columns that have an integer data type and are also unique or nonnull columns.</span></span> <span data-ttu-id="45d3b-146">適切に定義されたデータのサブセットが含まれている列に対し、 [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] 以上のバージョンでは、フィルター選択されたインデックスを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-146">For columns that have well-defined subsets of data, you can use a filtered index in [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] and higher versions.</span></span> <span data-ttu-id="45d3b-147">詳細については、このガイドの「 [フィルター選択されたインデックスのデザイン ガイドライン](#Filtered) 」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="45d3b-147">For more information, see [Filtered Index Design Guidelines](#Filtered) in this guide.</span></span>  
  
4.  <span data-ttu-id="45d3b-148">インデックスの作成時またはメンテナンス時のパフォーマンスを向上させるインデックス オプションを決定します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-148">Determine which index options might enhance performance when the index is created or maintained.</span></span> <span data-ttu-id="45d3b-149">たとえば、既存の大きなテーブルにクラスター化インデックスを作成する際には ONLINE インデックス オプションが有益です。</span><span class="sxs-lookup"><span data-stu-id="45d3b-149">For example, creating a clustered index on an existing large table would benefit from the ONLINE index option.</span></span> <span data-ttu-id="45d3b-150">ONLINE オプションを使用すると、インデックスの作成中または再構築中に、基になるデータで同時処理を続行できます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-150">The ONLINE option allows for concurrent activity on the underlying data to continue while the index is being created or rebuilt.</span></span> <span data-ttu-id="45d3b-151">詳細については、「 [インデックス オプションの設定](../relational-databases/indexes/set-index-options.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="45d3b-151">For more information, see [Set Index Options](../relational-databases/indexes/set-index-options.md).</span></span>  
  
5.  <span data-ttu-id="45d3b-152">インデックスの最適な格納場所を決定します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-152">Determine the optimal storage location for the index.</span></span> <span data-ttu-id="45d3b-153">非クラスター化インデックスは、基になるテーブルと同じファイル グループまたは別のファイル グループに格納できます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-153">A nonclustered index can be stored in the same filegroup as the underlying table, or on a different filegroup.</span></span> <span data-ttu-id="45d3b-154">インデックスの格納場所により、ディスク I/O のパフォーマンスが向上し、その結果クエリのパフォーマンスを向上させることができます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-154">The storage location of indexes can improve query performance by increasing disk I/O performance.</span></span> <span data-ttu-id="45d3b-155">たとえば、非クラスター化インデックスを、テーブル ファイル グループとは別のディスク上にあるファイル グループに格納すると、複数のディスクを同時に読み取ることができるため、パフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-155">For example, storing a nonclustered index on a filegroup that is on a different disk than the table filegroup can improve performance because multiple disks can be read at the same time.</span></span>  
  
     <span data-ttu-id="45d3b-156">また、クラスター化インデックスと非クラスター化インデックスでは、複数のファイル グループにまたがってパーティション構成を使用できます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-156">Alternatively, clustered and nonclustered indexes can use a partition scheme across multiple filegroups.</span></span> <span data-ttu-id="45d3b-157">大きなテーブルやインデックスをパーティション分割すると、コレクション全体の整合性を維持しながら、データのサブセットに対するアクセスや管理を迅速かつ効率的に行うことができるので、大きなテーブルやインデックスを管理しやすくなります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-157">Partitioning makes large tables or indexes more manageable by letting you access or manage subsets of data quickly and efficiently, while maintaining the integrity of the overall collection.</span></span> <span data-ttu-id="45d3b-158">詳細については、「 [Partitioned Tables and Indexes](../relational-databases/partitions/partitioned-tables-and-indexes.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="45d3b-158">For more information, see [Partitioned Tables and Indexes](../relational-databases/partitions/partitioned-tables-and-indexes.md).</span></span> <span data-ttu-id="45d3b-159">パーティション分割を検討するときは、インデックスを固定するかどうかを決定します。つまり、基本的にテーブルと同じ方法でパーティション分割するか、または別の方法でパーティション分割するかを決定するということです。</span><span class="sxs-lookup"><span data-stu-id="45d3b-159">When you consider partitioning, determine whether the index should be aligned, that is, partitioned in essentially the same manner as the table, or partitioned independently.</span></span>  
  
##  <a name="general-index-design-guidelines"></a><a name="General_Design"></a> <span data-ttu-id="45d3b-160">インデックスのデザインの全般的なガイドライン</span><span class="sxs-lookup"><span data-stu-id="45d3b-160">General Index Design Guidelines</span></span>  

 <span data-ttu-id="45d3b-161">経験豊富なデータベース管理者であれば適切なインデックス セットをデザインできますが、それほど複雑でないデータベースとワークロードであっても、この作業はきわめて複雑で、時間がかかり、間違いを犯しやすいものです。</span><span class="sxs-lookup"><span data-stu-id="45d3b-161">Experienced database administrators can design a good set of indexes, but this task is very complex, time-consuming, and error-prone even for moderately complex databases and workloads.</span></span> <span data-ttu-id="45d3b-162">使用するデータベース、クエリ、データ列の特性を理解することが、最適なインデックスをデザインする際に役に立ちます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-162">Understanding the characteristics of your database, queries, and data columns can help you design optimal indexes.</span></span>  
  
### <a name="database-considerations"></a><span data-ttu-id="45d3b-163">データベースに関する注意点</span><span class="sxs-lookup"><span data-stu-id="45d3b-163">Database Considerations</span></span>  

 <span data-ttu-id="45d3b-164">インデックスをデザインするときは、次のデータベースのガイドラインを考慮してください。</span><span class="sxs-lookup"><span data-stu-id="45d3b-164">When you design an index, consider the following database guidelines:</span></span>  
  
-   <span data-ttu-id="45d3b-165">1 つのテーブルに多数のインデックスがあると、テーブル内でのデータ変更に応じてインデックスをすべて調整する必要があるので、INSERT、UPDATE、DELETE、および MERGE の各ステートメントのパフォーマンスに影響します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-165">Large numbers of indexes on a table affect the performance of INSERT, UPDATE, DELETE, and MERGE statements because all indexes must be adjusted appropriately as data in the table changes.</span></span> <span data-ttu-id="45d3b-166">たとえば、列が複数のインデックスで使用されており、この列のデータを変更する UPDATE ステートメントを実行する場合は、その列が含まれている各インデックスも、基になるベース テーブル (ヒープまたはクラスター化インデックス) と同様に更新する必要があります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-166">For example, if a column is used in several indexes and you execute an UPDATE statement that modifies that column's data, each index that contains that column must be updated as well as the column in the underlying base table (heap or clustered index).</span></span>  
  
    -   <span data-ttu-id="45d3b-167">頻繁に更新するテーブルにはインデックスをデザインしすぎないようにし、インデックスの幅を狭く、つまり列数を可能な限り少なくします。</span><span class="sxs-lookup"><span data-stu-id="45d3b-167">Avoid over-indexing heavily updated tables and keep indexes narrow, that is, with as few columns as possible.</span></span>  
  
    -   <span data-ttu-id="45d3b-168">更新の必要が少なく、容量の大きいテーブルの場合、クエリのパフォーマンスを向上させるにはインデックスを多数使用します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-168">Use many indexes to improve query performance on tables with low update requirements, but large volumes of data.</span></span> <span data-ttu-id="45d3b-169">SELECT ステートメントなど、データを変更しないクエリの場合は、多数のインデックスを使用することで、クエリ オプティマイザーが最速のアクセス方法を決定する際に選択できるインデックスが多くなるため、クエリのパフォーマンスを向上できる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-169">Large numbers of indexes can help the performance of queries that do not modify data, such as SELECT statements, because the query optimizer has more indexes to choose from to determine the fastest access method.</span></span>  
  
-   <span data-ttu-id="45d3b-170">小さなテーブルではインデックスを作成しない方がよい場合もあります。これは、クエリ オプティマイザーが単純なテーブル スキャンを実行するよりデータのインデックスを検索する方に時間がかかることがあるためです。</span><span class="sxs-lookup"><span data-stu-id="45d3b-170">Indexing small tables may not be optimal because it can take the query optimizer longer to traverse the index searching for data than to perform a simple table scan.</span></span> <span data-ttu-id="45d3b-171">そのため、小さなテーブルのインデックスがまったく使用されない可能性があっても、テーブルのデータの変更に合わせてメンテナンスする必要があります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-171">Therefore, indexes on small tables might never be used, but must still be maintained as data in the table changes.</span></span>  
  
-   <span data-ttu-id="45d3b-172">ビューが集計、テーブル結合、または集計と結合の組み合わせを使用している場合、ビューにインデックスを設定すると、パフォーマンスが大幅に向上します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-172">Indexes on views can provide significant performance gains when the view contains aggregations, table joins, or a combination of aggregations and joins.</span></span> <span data-ttu-id="45d3b-173">クエリで明示的に参照しなくても、クエリ オプティマイザーはそのビューを使用します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-173">The view does not have to be explicitly referenced in the query for the query optimizer to use it.</span></span>  
  
-   <span data-ttu-id="45d3b-174">データベース エンジン チューニング アドバイザーを使用してデータベースを分析し、推奨インデックスを作成します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-174">Use the Database Engine Tuning Advisor to analyze your database and make index recommendations.</span></span> <span data-ttu-id="45d3b-175">詳細については、「 [Database Engine Tuning Advisor](../relational-databases/performance/database-engine-tuning-advisor.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="45d3b-175">For more information, see [Database Engine Tuning Advisor](../relational-databases/performance/database-engine-tuning-advisor.md).</span></span>  
  
### <a name="query-considerations"></a><span data-ttu-id="45d3b-176">クエリに関する注意点</span><span class="sxs-lookup"><span data-stu-id="45d3b-176">Query Considerations</span></span>  

 <span data-ttu-id="45d3b-177">インデックスをデザインするときは、次のクエリのガイドラインを考慮してください。</span><span class="sxs-lookup"><span data-stu-id="45d3b-177">When you design an index, consider the following query guidelines:</span></span>  
  
-   <span data-ttu-id="45d3b-178">クエリの述語や結合条件で頻繁に使用される列に対して非クラスター化インデックスを作成します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-178">Create nonclustered indexes on the columns that are frequently used in predicates and join conditions in queries.</span></span> <span data-ttu-id="45d3b-179">ただし、不要な列を追加しないようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-179">However, you should avoid adding unnecessary columns.</span></span> <span data-ttu-id="45d3b-180">インデックス列を追加しすぎると、必要なディスク領域が増え、インデックスのメンテナンスのパフォーマンスも低下する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-180">Adding too many index columns can adversely affect disk space and index maintenance performance.</span></span>  
  
-   <span data-ttu-id="45d3b-181">クエリの対象にインデックスを含めると、クエリのパフォーマンスを向上できます。これは、クエリの要件を満たすために必要なデータがすべて、インデックス自体に保持されているためです。</span><span class="sxs-lookup"><span data-stu-id="45d3b-181">Covering indexes can improve query performance because all the data needed to meet the requirements of the query exists within the index itself.</span></span> <span data-ttu-id="45d3b-182">つまり、要求されたデータの取得に必要なのはインデックス ページだけで、テーブルやクラスター化インデックスのデータ ページは必要ありません。このため、全体的にディスク I/O を削減できます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-182">That is, only the index pages, and not the data pages of the table or clustered index, are required to retrieve the requested data; therefore, reducing overall disk I/O.</span></span> <span data-ttu-id="45d3b-183">たとえば、テーブルの列 **a** と **b** に対するクエリは、このテーブルに列 **a**、 **b**、 **c** に基づく複合インデックスが作成されていれば、インデックスのみから指定したデータを取得できます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-183">For example, a query of columns **a** and **b** on a table that has a composite index created on columns **a**, **b**, and **c** can retrieve the specified data from the index alone.</span></span>  
  
-   <span data-ttu-id="45d3b-184">複数のクエリを使用して同じ行を更新するよりも、1 つのステートメントでできるだけ多くの行を挿入または変更するクエリを作成します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-184">Write queries that insert or modify as many rows as possible in a single statement, instead of using multiple queries to update the same rows.</span></span> <span data-ttu-id="45d3b-185">ステートメントを 1 つだけ使用することで、インデックスのメンテナンスを最適化できます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-185">By using only one statement, optimized index maintenance could be exploited.</span></span>  
  
-   <span data-ttu-id="45d3b-186">クエリの種類とクエリ内での列の使用方法を評価します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-186">Evaluate the query type and how columns are used in the query.</span></span> <span data-ttu-id="45d3b-187">たとえば、完全一致検索クエリで使用される列は、非クラスター化インデックスまたはクラスター化インデックスにする適切な候補になります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-187">For example, a column used in an exact-match query type would be a good candidate for a nonclustered or clustered index.</span></span>  
  
### <a name="column-considerations"></a><span data-ttu-id="45d3b-188">列に関する注意点</span><span class="sxs-lookup"><span data-stu-id="45d3b-188">Column Considerations</span></span>  

 <span data-ttu-id="45d3b-189">インデックスをデザインするときは、次の列のガイドラインを考慮してください。</span><span class="sxs-lookup"><span data-stu-id="45d3b-189">When you design an index consider the following column guidelines:</span></span>  
  
-   <span data-ttu-id="45d3b-190">クラスター化インデックスのインデックス キー長は長くならないようにします。</span><span class="sxs-lookup"><span data-stu-id="45d3b-190">Keep the length of the index key short for clustered indexes.</span></span> <span data-ttu-id="45d3b-191">また、クラスター化インデックスは一意列や非 NULL 列に作成すると効率的です。</span><span class="sxs-lookup"><span data-stu-id="45d3b-191">Additionally, clustered indexes benefit from being created on unique or nonnull columns.</span></span>  
  
-   <span data-ttu-id="45d3b-192">`ntext`、`text`、`image`, `varchar(max)`、`nvarchar(max)`、および `varbinary(max)` データ型の列をインデックス キー列に指定することはできません。</span><span class="sxs-lookup"><span data-stu-id="45d3b-192">Columns that are of the `ntext`, `text`, `image`, `varchar(max)`, `nvarchar(max)`, and `varbinary(max)` data types cannot be specified as index key columns.</span></span> <span data-ttu-id="45d3b-193">ただし、`varchar(max)`、`nvarchar(max)`、`varbinary(max)`、および `xml` データ型は、インデックスの非キー列として非クラスター化インデックスに含めることができます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-193">However, `varchar(max)`, `nvarchar(max)`, `varbinary(max)`, and `xml` data types can participate in a nonclustered index as nonkey index columns.</span></span> <span data-ttu-id="45d3b-194">詳細については、このガイドの ['付加列インデックス'](#Included_Columns)に関するセクションを参照してください。</span><span class="sxs-lookup"><span data-stu-id="45d3b-194">For more information, see the section ['Index with Included Columns](#Included_Columns)' in this guide.</span></span>  
  
-   <span data-ttu-id="45d3b-195">`xml` データ型は、XML インデックスでのみキー列にできます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-195">An `xml` data type can only be a key column only in an XML index.</span></span> <span data-ttu-id="45d3b-196">詳細については、「[XML インデックス &#40;SQL Server&#41;](../relational-databases/xml/xml-indexes-sql-server.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="45d3b-196">For more information, see [XML Indexes &#40;SQL Server&#41;](../relational-databases/xml/xml-indexes-sql-server.md).</span></span> <span data-ttu-id="45d3b-197">SQL Server 2012 SP1 では、選択的 XML インデックスと呼ばれる新しい種類の XML インデックスが導入されています。</span><span class="sxs-lookup"><span data-stu-id="45d3b-197">SQL Server 2012 SP1 introduces a new type of XML index known as a Selective XML Index.</span></span> <span data-ttu-id="45d3b-198">この新しいインデックスを使用すると、SQL Server に XML 形式で格納されたデータに対するクエリのパフォーマンスが向上するため、XML データの大量のワークロードに対するインデックスの設定がはるかに高速になります。また、インデックス自体のストレージ コストを削減できるため、スケーラビリティも向上します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-198">This new index can improve querying performance over data stored as XML in SQL Server, allow for much faster indexing of large XML data workloads, and improve scalability by reducing storage costs of the index itself.</span></span> <span data-ttu-id="45d3b-199">詳細については、「[選択的 XML インデックス &#40;SXI&#41;](../relational-databases/xml/selective-xml-indexes-sxi.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="45d3b-199">For more information, see [Selective XML Indexes &#40;SXI&#41;](../relational-databases/xml/selective-xml-indexes-sxi.md).</span></span>  
  
-   <span data-ttu-id="45d3b-200">列の一意性を調べます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-200">Examine column uniqueness.</span></span> <span data-ttu-id="45d3b-201">同じ列の組み合わせに対して一意でないインデックスを作成するよりも一意インデックスを作成する方が、クエリ オプティマイザーに追加情報が提供され、インデックスの利用価値が高まります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-201">A unique index instead of a nonunique index on the same combination of columns provides additional information for the query optimizer that makes the index more useful.</span></span> <span data-ttu-id="45d3b-202">詳細については、このガイドの「 [一意インデックスのデザイン ガイドライン](#Unique) 」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="45d3b-202">For more information, see [Unique Index Design Guidelines](#Unique) in this guide.</span></span>  
  
-   <span data-ttu-id="45d3b-203">列内のデータの分布を調べます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-203">Examine data distribution in the column.</span></span> <span data-ttu-id="45d3b-204">インデックスを設定した列にほとんど一意の値がない場合や、このような列を結合する場合、クエリに時間がかかることがよくあります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-204">Frequently, a long-running query is caused by indexing a column with few unique values, or by performing a join on such a column.</span></span> <span data-ttu-id="45d3b-205">これは、データとクエリにかかわる根本的な問題で、通常はこのような状況を特定しなければ解決できません。</span><span class="sxs-lookup"><span data-stu-id="45d3b-205">This is a fundamental problem with the data and query, and generally cannot be resolved without identifying this situation.</span></span> <span data-ttu-id="45d3b-206">たとえば、姓がアルファベット順に並んだ電話帳では、対象地域のすべての人が Smith や Jones という姓である場合、特定の人を探すときに役に立ちません。</span><span class="sxs-lookup"><span data-stu-id="45d3b-206">For example, a physical telephone directory sorted alphabetically on last name will not expedite locating a person if all people in the city are named Smith or Jones.</span></span> <span data-ttu-id="45d3b-207">データ分布の詳細については、「 [統計](../relational-databases/statistics/statistics.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="45d3b-207">For more information about data distribution, see [Statistics](../relational-databases/statistics/statistics.md).</span></span>  
  
-   <span data-ttu-id="45d3b-208">スパース列、ほとんどが NULL 値の列、さまざまなカテゴリの値を含む列、および異なる範囲の値を含む列のようなサブセットが明確に定義されている列では、フィルター選択されたインデックスの使用を検討してください。</span><span class="sxs-lookup"><span data-stu-id="45d3b-208">Consider using filtered indexes on columns that have well-defined subsets, for example sparse columns, columns with mostly NULL values, columns with categories of values, and columns with distinct ranges of values.</span></span> <span data-ttu-id="45d3b-209">フィルター選択されたインデックスを適切に設計すると、クエリのパフォーマンスが向上し、インデックスのメンテナンス コストとストレージ コストを削減できます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-209">A well-designed filtered index can improve query performance, reduce index maintenance costs, and reduce storage costs.</span></span>  
  
-   <span data-ttu-id="45d3b-210">インデックスに複数の列が含まれる場合は、列の順序を考慮します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-210">Consider the order of the columns if the index will contain multiple columns.</span></span> <span data-ttu-id="45d3b-211">等しい (=)、より大きい (>)、より小さい (<)、BETWEEN などの検索条件の WHERE 句で使用されるか、結合に含まれる列は、先頭に配置します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-211">The column that is used in the WHERE clause in an equal to (=), greater than (>), less than (<), or BETWEEN search condition, or participates in a join, should be placed first.</span></span> <span data-ttu-id="45d3b-212">その他の列は、差異の程度、つまり最も差異の大きいものから最も差異の小さいものの順に配置します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-212">Additional columns should be ordered based on their level of distinctness, that is, from the most distinct to the least distinct.</span></span>  
  
     <span data-ttu-id="45d3b-213">たとえば、インデックスが `LastName`, `FirstName` として定義されている場合、このインデックスは、検索条件が `WHERE LastName = 'Smith'` または `WHERE LastName = Smith AND FirstName LIKE 'J%'`である場合に効果があります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-213">For example, if the index is defined as `LastName`, `FirstName` the index will be useful when the search criterion is `WHERE LastName = 'Smith'` or `WHERE LastName = Smith AND FirstName LIKE 'J%'`.</span></span> <span data-ttu-id="45d3b-214">ただし、クエリ オプティマイザーでは、 `FirstName (WHERE FirstName = 'Jane')`のみで検索するクエリには、このインデックスが使用されません。</span><span class="sxs-lookup"><span data-stu-id="45d3b-214">However, the query optimizer would not use the index for a query that searched only on `FirstName (WHERE FirstName = 'Jane')`.</span></span>  
  
-   <span data-ttu-id="45d3b-215">計算列のインデックス設定を検討します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-215">Consider indexing computed columns.</span></span> <span data-ttu-id="45d3b-216">詳細については、「 [計算列のインデックス](../relational-databases/indexes/indexes-on-computed-columns.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="45d3b-216">For more information, see [Indexes on Computed Columns](../relational-databases/indexes/indexes-on-computed-columns.md).</span></span>  
  
### <a name="index-characteristics"></a><span data-ttu-id="45d3b-217">インデックスの特性</span><span class="sxs-lookup"><span data-stu-id="45d3b-217">Index Characteristics</span></span>  

 <span data-ttu-id="45d3b-218">クエリにインデックスを設定することが適切であると判断した場合は、状況に応じて最適な種類のインデックスを選択します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-218">After you have determined that an index is appropriate for a query, you can select the type of index that best fits your situation.</span></span> <span data-ttu-id="45d3b-219">インデックスの特性は、次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="45d3b-219">Index characteristics include the following:</span></span>  
  
-   <span data-ttu-id="45d3b-220">クラスター化と非クラスター化</span><span class="sxs-lookup"><span data-stu-id="45d3b-220">Clustered versus nonclustered</span></span>  
  
-   <span data-ttu-id="45d3b-221">一意と非一意</span><span class="sxs-lookup"><span data-stu-id="45d3b-221">Unique versus nonunique</span></span>  
  
-   <span data-ttu-id="45d3b-222">単一列と複数列</span><span class="sxs-lookup"><span data-stu-id="45d3b-222">Single column versus multicolumn</span></span>  
  
-   <span data-ttu-id="45d3b-223">昇順と降順 (インデックス内の列の並び)</span><span class="sxs-lookup"><span data-stu-id="45d3b-223">Ascending or descending order on the columns in the index</span></span>  
  
-   <span data-ttu-id="45d3b-224">テーブル全体の非クラスター化インデックスとフィルター選択された非クラスター化インデックス</span><span class="sxs-lookup"><span data-stu-id="45d3b-224">Full-table versus filtered for nonclustered indexes</span></span>  
  
 <span data-ttu-id="45d3b-225">インデックスを最初に保存したときの特性をカスタマイズし、FILLFACTOR などのオプションを設定してパフォーマンスやメンテナンスを最適化できます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-225">You can also customize the initial storage characteristics of the index to optimize its performance or maintenance by setting an option such as FILLFACTOR.</span></span> <span data-ttu-id="45d3b-226">また、パフォーマンスを最適化するために、ファイル グループやパーティション構成を使用してインデックスの保存場所を決定することもできます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-226">Also, you can determine the index storage location by using filegroups or partition schemes to optimize performance.</span></span>  
  
###  <a name="index-placement-on-filegroups-or-partitions-schemes"></a><a name="Index_placement"></a> <span data-ttu-id="45d3b-227">ファイル グループまたはパーティション構成に対するインデックス配置</span><span class="sxs-lookup"><span data-stu-id="45d3b-227">Index Placement on Filegroups or Partitions Schemes</span></span>  

 <span data-ttu-id="45d3b-228">インデックスの設計について考えるときは、データベースに関連付けられたファイル グループ上にインデックスを配置することを検討する必要があります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-228">As you develop your index design strategy, you should consider the placement of the indexes on the filegroups associated with the database.</span></span> <span data-ttu-id="45d3b-229">ファイル グループまたはパーティション構成を慎重に選択することで、クエリのパフォーマンスを向上できる場合があります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-229">Careful selection of the filegroup or partition scheme can improve query performance.</span></span>  
  
 <span data-ttu-id="45d3b-230">既定では、インデックスが作成されるベース テーブルと同じファイル グループにインデックスも格納されます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-230">By default, indexes are stored in the same filegroup as the base table on which the index is created.</span></span> <span data-ttu-id="45d3b-231">パーティション分割されていないクラスター化インデックスおよびベース テーブルは、常に同じファイル グループに存在します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-231">A nonpartitioned clustered index and the base table always reside in the same filegroup.</span></span> <span data-ttu-id="45d3b-232">しかし、次の操作を実行できます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-232">However, you can do the following:</span></span>  
  
-   <span data-ttu-id="45d3b-233">ベース テーブルまたはクラスター化インデックスのファイル グループ以外のファイル グループに、非クラスター化インデックスを作成する。</span><span class="sxs-lookup"><span data-stu-id="45d3b-233">Create nonclustered indexes on a filegroup other than the filegroup of the base table or clustered index.</span></span>  
  
-   <span data-ttu-id="45d3b-234">複数のファイル グループにまたがるクラスター化インデックスおよび非クラスター化インデックスをパーティション分割する。</span><span class="sxs-lookup"><span data-stu-id="45d3b-234">Partition clustered and nonclustered indexes to span multiple filegroups.</span></span>  
  
-   <span data-ttu-id="45d3b-235">あるファイル グループから別のファイル グループにテーブルを移動する。この操作を行うには、クラスター化インデックスを削除して DROP INDEX ステートメントの MOVE TO 句に新しいファイル グループまたはパーティション構成を指定するか、DROP_EXISTING 句を指定した CREATE INDEX ステートメントを使用します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-235">Move a table from one filegroup to another by dropping the clustered index and specifying a new filegroup or partition scheme in the MOVE TO clause of the DROP INDEX statement or by using the CREATE INDEX statement with the DROP_EXISTING clause.</span></span>  
  
 <span data-ttu-id="45d3b-236">異なるファイル グループに非クラスター化インデックスを作成した場合、そのファイル グループが独自のコントローラーを持つ異なる物理ドライブを使用していると、パフォーマンスの向上を実現できます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-236">By creating the nonclustered index on a different filegroup, you can achieve performance gains if the filegroups are using different physical drives with their own controllers.</span></span> <span data-ttu-id="45d3b-237">データおよびインデックス情報は、複数のディスク ヘッドにより並列で読み込めるようになります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-237">Data and index information can then be read in parallel by the multiple disk heads.</span></span> <span data-ttu-id="45d3b-238">たとえば、ファイル グループ `Table_A` の `f1` とファイル グループ `Index_A` の `f2` が同じクエリで使用される場合、両ファイル グループが競合することなく完全に使用されるため、パフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-238">For example, if `Table_A` on filegroup `f1` and `Index_A` on filegroup `f2` are both being used by the same query, performance gains can be achieved because both filegroups are being fully used without contention.</span></span> <span data-ttu-id="45d3b-239">ただし、クエリによって `Table_A` がスキャンされる場合でも、 `Index_A` が参照されていないと、ファイル グループ `f1` のみが使用されます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-239">However, if `Table_A` is scanned by the query but `Index_A` is not referenced, only filegroup `f1` is used.</span></span> <span data-ttu-id="45d3b-240">この場合、パフォーマンスは向上しません。</span><span class="sxs-lookup"><span data-stu-id="45d3b-240">This creates no performance gain.</span></span>  
  
 <span data-ttu-id="45d3b-241">アクセスの種類や実行のタイミングは事前には予測できないため、テーブルとインデックスをすべてのファイル グループにわたって分散しておくことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="45d3b-241">Because you cannot predict what type of access will occur and when it will occur, it could be a better decision to spread your tables and indexes across all filegroups.</span></span> <span data-ttu-id="45d3b-242">すべてのデータとインデックスが、すべてのディスクにわたって均等に分散されていれば、どのような方法でデータへのアクセスが行われても、確実にすべてのディスクがアクセスされます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-242">This would guarantee that all disks are being accessed because all data and indexes are spread evenly across all disks, regardless of which way the data is accessed.</span></span> <span data-ttu-id="45d3b-243">この方法は、システム管理者にとっても簡単な方法になります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-243">This is also a simpler approach for system administrators.</span></span>  
  
#### <a name="partitions-across-multiple-filegroups"></a><span data-ttu-id="45d3b-244">複数のファイル グループでのパーティション分割</span><span class="sxs-lookup"><span data-stu-id="45d3b-244">Partitions Across Multiple Filegroups</span></span>  

 <span data-ttu-id="45d3b-245">複数のファイル グループにわたるクラスター化インデックスおよび非クラスター化インデックスをパーティション分割することもできます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-245">You can also consider partitioning clustered and nonclustered indexes across multiple filegroups.</span></span> <span data-ttu-id="45d3b-246">パーティション インデックスは、パーティション関数に基づいて、行方向または行ごとにパーティション分割されます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-246">Partitioned indexes are partitioned horizontally, or by row, based on a partition function.</span></span> <span data-ttu-id="45d3b-247">パーティション関数では、パーティション分割列と呼ばれる特定の列の値に基づいて、一連のパーティションに各行をどのようにマップするのかを定義します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-247">The partition function defines how each row is mapped to a set of partitions based on the values of certain columns, called partitioning columns.</span></span> <span data-ttu-id="45d3b-248">パーティション構成では、一連のファイル グループにパーティションをマップするように指定します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-248">A partition scheme specifies the mapping of the partitions to a set of filegroups.</span></span>  
  
 <span data-ttu-id="45d3b-249">インデックスをパーティション分割すると、次のような利点があります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-249">Partitioning an index can provide the following benefits:</span></span>  
  
-   <span data-ttu-id="45d3b-250">大きなインデックスがより管理しやすくなるスケーラブルなシステムを提供できる。</span><span class="sxs-lookup"><span data-stu-id="45d3b-250">Provide scalable systems that make large indexes more manageable.</span></span> <span data-ttu-id="45d3b-251">たとえば OLTP システムで、大きなインデックスを扱うパーティション対応のアプリケーションを実装できます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-251">OLTP systems, for example, can implement partition-aware applications that deal with large indexes.</span></span>  
  
-   <span data-ttu-id="45d3b-252">クエリをより高速かつ効率的に実行できる。</span><span class="sxs-lookup"><span data-stu-id="45d3b-252">Make queries run faster and more efficiently.</span></span> <span data-ttu-id="45d3b-253">クエリからインデックスのいくつかのパーティションへアクセスしたときに、クエリ オプティマイザーでは個別のパーティションを同時に処理し、クエリによる影響を受けないパーティションを除外できます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-253">When queries access several partitions of an index, the query optimizer can process individual partitions at the same time and exclude partitions that are not affected by the query.</span></span>  
  
 <span data-ttu-id="45d3b-254">詳細については、「 [Partitioned Tables and Indexes](../relational-databases/partitions/partitioned-tables-and-indexes.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="45d3b-254">For more information, see [Partitioned Tables and Indexes](../relational-databases/partitions/partitioned-tables-and-indexes.md).</span></span>  
  
###  <a name="index-sort-order-design-guidelines"></a><a name="Sort_Order"></a> <span data-ttu-id="45d3b-255">インデックス並べ替え順のデザイン ガイドライン</span><span class="sxs-lookup"><span data-stu-id="45d3b-255">Index Sort Order Design Guidelines</span></span>  

 <span data-ttu-id="45d3b-256">インデックスを定義する場合、インデックス キー列のデータを昇順と降順のどちらで格納する必要があるかを考慮する必要があります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-256">When defining indexes, you should consider whether the data for the index key column should be stored in ascending or descending order.</span></span> <span data-ttu-id="45d3b-257">昇順は既定の並べ替え順で、以前のバージョンの [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]との互換性が維持されます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-257">Ascending is the default and maintains compatibility with earlier versions of [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="45d3b-258">CREATE INDEX、CREATE TABLE、および ALTER TABLE の各ステートメントの構文では、インデックスと制約の個別の列にキーワード ASC (昇順) と DESC (降順) を使用できます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-258">The syntax of the CREATE INDEX, CREATE TABLE, and ALTER TABLE statements supports the keywords ASC (ascending) and DESC (descending) on individual columns in indexes and constraints.</span></span>  
  
 <span data-ttu-id="45d3b-259">インデックスにキー値が格納される順序を指定することは、テーブルを参照しているクエリに ORDER BY 句があり、そのインデックスの 1 つ以上のキー列が ORDER BY 句によって異なる方向に指定されている場合に役立ちます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-259">Specifying the order in which key values are stored in an index is useful when queries referencing the table have ORDER BY clauses that specify different directions for the key column or columns in that index.</span></span> <span data-ttu-id="45d3b-260">このような場合、インデックスにより、クエリ プランで SORT 操作を実行する必要がなくなるので、クエリをより効率的に実行できるようになります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-260">In these cases, the index can remove the need for a SORT operator in the query plan; therefore, this makes the query more efficient.</span></span> <span data-ttu-id="45d3b-261">たとえば、 [!INCLUDE[ssSampleDBCoFull](../includes/sssampledbcofull-md.md)] の購買部のバイヤーが、業者から購入する製品の品質を評価する必要がある場合について考えてみます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-261">For example, the buyers in the [!INCLUDE[ssSampleDBCoFull](../includes/sssampledbcofull-md.md)] purchasing department have to evaluate the quality of products they purchase from vendors.</span></span> <span data-ttu-id="45d3b-262">バイヤーにとって最も関心があるのは、これらの業者から配送された製品の中から、返品率の高い製品を見つけ出すことです。</span><span class="sxs-lookup"><span data-stu-id="45d3b-262">The buyers are most interested in finding products sent by these vendors with a high rejection rate.</span></span> <span data-ttu-id="45d3b-263">次のクエリに示すように、この基準を満たすデータを取得するには、 `RejectedQty` テーブルの `Purchasing.PurchaseOrderDetail` 列を降順 (大から小) に並べ替え、 `ProductID` 列を昇順 (小から大) に並べ替える必要があります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-263">As shown in the following query, retrieving the data to meet this criteria requires the `RejectedQty` column in the `Purchasing.PurchaseOrderDetail` table to be sorted in descending order (large to small) and the `ProductID` column to be sorted in ascending order (small to large).</span></span>  
  
```sql
SELECT RejectedQty, ((RejectedQty/OrderQty)*100) AS RejectionRate,  
    ProductID, DueDate  
FROM Purchasing.PurchaseOrderDetail  
ORDER BY RejectedQty DESC, ProductID ASC;  
```  
  
 <span data-ttu-id="45d3b-264">次に示すこのクエリの実行プランは、クエリ オプティマイザーにより SORT 操作が使用され、ORDER BY 句で指定された順序で結果セットが返されたことを示します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-264">The following execution plan for this query shows that the query optimizer used a SORT operator to return the result set in the order specified by the ORDER BY clause.</span></span>  
  
 <span data-ttu-id="45d3b-265">![SORT 操作が使用されることを示す実行プラン](media/indexsort1.gif "SORT 操作が使用されることを示す実行プラン")</span><span class="sxs-lookup"><span data-stu-id="45d3b-265">![Execution plan shows a SORT operator is used.](media/indexsort1.gif "Execution plan shows a SORT operator is used.")</span></span>  
  
 <span data-ttu-id="45d3b-266">作成したインデックスのキー列がクエリの ORDER BY 句で使用するキー列と一致する場合、クエリ プランの SORT 操作を削除できるので、クエリ プランがより効率的になります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-266">If an index is created with key columns that match those in the ORDER BY clause in the query, the SORT operator can be eliminated in the query plan and the query plan is more efficient.</span></span>  
  
```sql
CREATE NONCLUSTERED INDEX IX_PurchaseOrderDetail_RejectedQty  
ON Purchasing.PurchaseOrderDetail  
    (RejectedQty DESC, ProductID ASC, DueDate, OrderQty);  
```  
  
 <span data-ttu-id="45d3b-267">もう一度クエリを実行した後、次の実行プランは、SORT 操作が削除され、新しく作成された非クラスター化インデックスが使用されたことを示します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-267">After the query is executed again, the following execution plan shows that the SORT operator has been eliminated and the newly created nonclustered index is used.</span></span>  
  
 <span data-ttu-id="45d3b-268">![SORT 操作が使用されないことを示す実行プラン](media/insertsort2.gif "SORT 操作が使用されないことを示す実行プラン")</span><span class="sxs-lookup"><span data-stu-id="45d3b-268">![Execution plan shows a SORT operator is not used](media/insertsort2.gif "Execution plan shows a SORT operator is not used")</span></span>  
  
 <span data-ttu-id="45d3b-269">[!INCLUDE[ssDE](../includes/ssde-md.md)] は、どちらの方向でも同じように効率的に移動します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-269">The [!INCLUDE[ssDE](../includes/ssde-md.md)] can move equally efficiently in either direction.</span></span> <span data-ttu-id="45d3b-270">`(RejectedQty DESC, ProductID ASC)` として定義されたインデックスは、ORDER BY 句の列の並べ替え方向が逆転されたクエリで引き続き使用できます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-270">An index defined as `(RejectedQty DESC, ProductID ASC)` can still be used for a query in which the sort direction of the columns in the ORDER BY clause are reversed.</span></span> <span data-ttu-id="45d3b-271">たとえば、ORDER BY 句 `ORDER BY RejectedQty ASC, ProductID DESC` が含まれたクエリでは、このインデックスを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-271">For example, a query with the ORDER BY clause `ORDER BY RejectedQty ASC, ProductID DESC` can use the index.</span></span>  
  
 <span data-ttu-id="45d3b-272">並べ替え順は、キー列のみに指定できます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-272">Sort order can be specified only for key columns.</span></span> <span data-ttu-id="45d3b-273">[sys.index_columns](/sql/relational-databases/system-catalog-views/sys-indexes-transact-sql) カタログ ビューと INDEXKEY_PROPERTY 関数により、インデックス列が昇順と降順のどちらで格納されているかが報告されます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-273">The [sys.index_columns](/sql/relational-databases/system-catalog-views/sys-indexes-transact-sql) catalog view and the INDEXKEY_PROPERTY function report whether an index column is stored in ascending or descending order.</span></span>  
  
 <span data-ttu-id="45d3b-274">[このガイドの [](#Top) ![トップに戻る] リンクで使用される矢印アイコン](media/uparrow16x16.gif "[トップに戻る] リンクで使用される矢印アイコン")</span><span class="sxs-lookup"><span data-stu-id="45d3b-274">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
##  <a name="clustered-index-design-guidelines"></a><a name="Clustered"></a> <span data-ttu-id="45d3b-275">クラスター化インデックスのデザイン ガイドライン</span><span class="sxs-lookup"><span data-stu-id="45d3b-275">Clustered Index Design Guidelines</span></span>  

 <span data-ttu-id="45d3b-276">クラスター化インデックスは、データ行をそのキー値に基づいて並べ替え、テーブル内に格納します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-276">Clustered indexes sort and store the data rows in the table based on their key values.</span></span> <span data-ttu-id="45d3b-277">データ行自体は 1 つの順序でしか並べ替えられないため、1 つのテーブルに設定できるクラスター化インデックスは 1 つだけです。</span><span class="sxs-lookup"><span data-stu-id="45d3b-277">There can only be one clustered index per table, because the data rows themselves can only be sorted in one order.</span></span> <span data-ttu-id="45d3b-278">ほとんどの場合、各テーブルには、次の条件を満たす単一または複数の列に基づいて定義されたクラスター化インデックスを作成することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="45d3b-278">With few exceptions, every table should have a clustered index defined on the column, or columns, that offer the following:</span></span>  
  
-   <span data-ttu-id="45d3b-279">頻繁に使用されるクエリに使用可能。</span><span class="sxs-lookup"><span data-stu-id="45d3b-279">Can be used for frequently used queries.</span></span>  
  
-   <span data-ttu-id="45d3b-280">一意性が高い。</span><span class="sxs-lookup"><span data-stu-id="45d3b-280">Provide a high degree of uniqueness.</span></span>  
  
    > [!NOTE]  
    >  <span data-ttu-id="45d3b-281">PRIMARY KEY 制約を作成すると、単一または複数の列に基づく一意のインデックスが自動的に作成されます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-281">When you create a PRIMARY KEY constraint, a unique index on the column, or columns, is automatically created.</span></span> <span data-ttu-id="45d3b-282">既定では、クラスター化インデックスが作成されますが、制約を作成する際に非クラスター化インデックスを作成するように指定することもできます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-282">By default, this index is clustered; however, you can specify a nonclustered index when you create the constraint.</span></span>  
  
-   <span data-ttu-id="45d3b-283">範囲クエリで使用可能。</span><span class="sxs-lookup"><span data-stu-id="45d3b-283">Can be used in range queries.</span></span>  
  
 <span data-ttu-id="45d3b-284">UNIQUE プロパティを使用してクラスター化インデックスが作成されていない場合、は [!INCLUDE[ssDE](../includes/ssde-md.md)] 自動的に4バイトの uniquifier 列をテーブルに追加します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-284">If the clustered index is not created with the UNIQUE property, the [!INCLUDE[ssDE](../includes/ssde-md.md)] automatically adds a 4-byte uniquifier column to the table.</span></span> <span data-ttu-id="45d3b-285">必要に応じて、 [!INCLUDE[ssDE](../includes/ssde-md.md)] uniquifier 値が自動的に行に追加され、各キーが一意になります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-285">When it is required, the [!INCLUDE[ssDE](../includes/ssde-md.md)] automatically adds a uniquifier value to a row to make each key unique.</span></span> <span data-ttu-id="45d3b-286">この列とその値は、内部的に使用されるもので、ユーザーが参照したりアクセスすることはできません。</span><span class="sxs-lookup"><span data-stu-id="45d3b-286">This column and its values are used internally and cannot be seen or accessed by users.</span></span>  
  
### <a name="clustered-index-architecture"></a><span data-ttu-id="45d3b-287">クラスター化インデックスのアーキテクチャ</span><span class="sxs-lookup"><span data-stu-id="45d3b-287">Clustered Index Architecture</span></span>  

 <span data-ttu-id="45d3b-288">[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]では、インデックスは B ツリーとして構成されます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-288">In [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)], indexes are organized as B-trees.</span></span> <span data-ttu-id="45d3b-289">インデックス B ツリー内の各ページをインデックス ノードと呼びます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-289">Each page in an index B-tree is called an index node.</span></span> <span data-ttu-id="45d3b-290">B ツリーの最上位ノードはルート ノードといいます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-290">The top node of the B-tree is called the root node.</span></span> <span data-ttu-id="45d3b-291">インデックス内の最下位ノードをリーフ ノードと呼びます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-291">The bottom nodes in the index are called the leaf nodes.</span></span> <span data-ttu-id="45d3b-292">ルート ノードとリーフ ノードの間にあるインデックス レベルは、総称して中間レベルといいます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-292">Any index levels between the root and the leaf nodes are collectively known as intermediate levels.</span></span> <span data-ttu-id="45d3b-293">クラスター化インデックスでは、リーフ ノードに基になるテーブルのデータ ページが含まれています。</span><span class="sxs-lookup"><span data-stu-id="45d3b-293">In a clustered index, the leaf nodes contain the data pages of the underlying table.</span></span> <span data-ttu-id="45d3b-294">ルート ノードと中間レベル ノードには、インデックス行を保持するインデックス ページが含まれています。</span><span class="sxs-lookup"><span data-stu-id="45d3b-294">The root and intermediate level nodes contain index pages holding index rows.</span></span> <span data-ttu-id="45d3b-295">各インデックス行には、キー値と、B ツリー内の中間レベル ページかインデックスのリーフ レベルのデータ行のいずれかへのポインターが含まれています。</span><span class="sxs-lookup"><span data-stu-id="45d3b-295">Each index row contains a key value and a pointer to either an intermediate level page in the B-tree, or a data row in the leaf level of the index.</span></span> <span data-ttu-id="45d3b-296">インデックスの各レベルのページは、二重にリンクされた一覧でリンクされています。</span><span class="sxs-lookup"><span data-stu-id="45d3b-296">The pages in each level of the index are linked in a doubly-linked list.</span></span>  
  
 <span data-ttu-id="45d3b-297">クラスター化インデックスの場合、 [sys.partitions](/sql/relational-databases/system-catalog-views/sys-partitions-transact-sql)にはインデックスで使用されるパーティションごとに 1 つの行が含まれます。この場合、 **index_id** は 1 と等しくなります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-297">Clustered indexes have one row in [sys.partitions](/sql/relational-databases/system-catalog-views/sys-partitions-transact-sql), with **index_id** = 1 for each partition used by the index.</span></span> <span data-ttu-id="45d3b-298">既定では、クラスター化インデックスのパーティションは 1 つです。</span><span class="sxs-lookup"><span data-stu-id="45d3b-298">By default, a clustered index has a single partition.</span></span> <span data-ttu-id="45d3b-299">クラスター化インデックスにパーティションが複数ある場合、各パーティションは、そのパーティションのデータを保持する B ツリー構造になります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-299">When a clustered index has multiple partitions, each partition has a B-tree structure that contains the data for that specific partition.</span></span> <span data-ttu-id="45d3b-300">たとえば、クラスター化インデックスに 4 つのパーティションがある場合、4 つの B ツリーを持つ構造になります。この場合、パーティションごとに 1 つの B ツリーがあります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-300">For example, if a clustered index has four partitions, there are four B-tree structures; one in each partition.</span></span>  
  
 <span data-ttu-id="45d3b-301">クラスター化インデックスのデータ型によっては、各クラスター化インデックスの構造に 1 つ以上のアロケーション ユニットが含まれ、そこに特定のパーティションのデータが格納され、管理されます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-301">Depending on the data types in the clustered index, each clustered index structure will have one or more allocation units in which to store and manage the data for a specific partition.</span></span> <span data-ttu-id="45d3b-302">各クラスター化インデックスには、パーティションごとに、少なくとも 1 つの IN_ROW_DATA アロケーション ユニットがあります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-302">At a minimum, each clustered index will have one IN_ROW_DATA allocation unit per partition.</span></span> <span data-ttu-id="45d3b-303">また、クラスター化インデックスにラージ オブジェクト (LOB) 列が含まれている場合は、パーティションごとに 1 つの LOB_DATA アロケーション ユニットもあります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-303">The clustered index will also have one LOB_DATA allocation unit per partition if it contains large object (LOB) columns.</span></span> <span data-ttu-id="45d3b-304">さらに、行サイズの上限である 8,060 バイトを超える可変長列が含まれている場合は、パーティションごとに 1 つの ROW_OVERFLOW_DATA アロケーション ユニットがあります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-304">It will also have one ROW_OVERFLOW_DATA allocation unit per partition if it contains variable length columns that exceed the 8,060 byte row size limit.</span></span>  
  
 <span data-ttu-id="45d3b-305">データ チェーン内のページとページ内の行は、クラスター化インデックス キーの値に基づいて並べ替えられます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-305">The pages in the data chain and the rows in them are ordered on the value of the clustered index key.</span></span> <span data-ttu-id="45d3b-306">挿入はすべて、挿入される行のキー値が、順序付けられた既存の行の並びの中に正しく収まる位置で行われます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-306">All inserts are made at the point where the key value in the inserted row fits in the ordering sequence among existing rows.</span></span>  
  
 <span data-ttu-id="45d3b-307">次の図は、1 つのパーティション内のクラスター化インデックスの構造を示します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-307">This illustration shows the structure of a clustered index in a single partition.</span></span>  
  
 <span data-ttu-id="45d3b-308">![クラスター化インデックスのレベル](media/bokind2.gif "クラスター化インデックスのレベル")</span><span class="sxs-lookup"><span data-stu-id="45d3b-308">![Levels of a clustered index](media/bokind2.gif "Levels of a clustered index")</span></span>  
  
### <a name="query-considerations"></a><span data-ttu-id="45d3b-309">クエリに関する注意点</span><span class="sxs-lookup"><span data-stu-id="45d3b-309">Query Considerations</span></span>  

 <span data-ttu-id="45d3b-310">クラスター化インデックスを作成する前に、データがどのようにアクセスされるかを理解しておいてください。</span><span class="sxs-lookup"><span data-stu-id="45d3b-310">Before you create clustered indexes, understand how your data will be accessed.</span></span> <span data-ttu-id="45d3b-311">次の処理を行うクエリには、クラスター化インデックスを使用することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="45d3b-311">Consider using a clustered index for queries that do the following:</span></span>  
  
-   <span data-ttu-id="45d3b-312">BETWEEN、>、>=、<、<= などの演算子を使用して、ある範囲の値を返す。</span><span class="sxs-lookup"><span data-stu-id="45d3b-312">Return a range of values by using operators such as BETWEEN, >, >=, <, and <=.</span></span>  
  
     <span data-ttu-id="45d3b-313">クラスター化インデックスを使用して最初の値を持つ行が検索されると、後続のインデックス値がある行は物理的に必ず隣接しています。</span><span class="sxs-lookup"><span data-stu-id="45d3b-313">After the row with the first value is found by using the clustered index, rows with subsequent indexed values are guaranteed to be physically adjacent.</span></span> <span data-ttu-id="45d3b-314">たとえば、クエリである範囲内の販売注文番号を持つ行を取得する場合、 `SalesOrderNumber` 列のクラスター化インデックスを使用すると、最初の販売注文番号を含む行をすばやく検索して、最後の販売注文番号に達するまでテーブル内の後続の行をすべて取得できます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-314">For example, if a query retrieves records between a range of sales order numbers, a clustered index on the column `SalesOrderNumber` can quickly locate the row that contains the starting sales order number, and then retrieve all successive rows in the table until the last sales order number is reached.</span></span>  
  
-   <span data-ttu-id="45d3b-315">大きな結果セットを返す。</span><span class="sxs-lookup"><span data-stu-id="45d3b-315">Return large result sets.</span></span>  
  
-   <span data-ttu-id="45d3b-316">JOIN 句を使用する。通常、これらは外部キー列になります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-316">Use JOIN clauses; typically these are foreign key columns.</span></span>  
  
-   <span data-ttu-id="45d3b-317">ORDER BY 句または GROUP BY 句を使用する。</span><span class="sxs-lookup"><span data-stu-id="45d3b-317">Use ORDER BY, or GROUP BY clauses.</span></span>  
  
     <span data-ttu-id="45d3b-318">ORDER BY 句または GROUP BY 句の中で指定された列にインデックスが設定されている場合、行が既に並べ替えられているので、 [!INCLUDE[ssDE](../includes/ssde-md.md)] によるデータの並べ替えが必要ないことがあります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-318">An index on the columns specified in the ORDER BY or GROUP BY clause may remove the need for the [!INCLUDE[ssDE](../includes/ssde-md.md)] to sort the data, because the rows are already sorted.</span></span> <span data-ttu-id="45d3b-319">このような場合は、クエリ パフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-319">This improves query performance.</span></span>  
  
### <a name="column-considerations"></a><span data-ttu-id="45d3b-320">列に関する注意点</span><span class="sxs-lookup"><span data-stu-id="45d3b-320">Column Considerations</span></span>  

 <span data-ttu-id="45d3b-321">通常は、クラスター化インデックス キーの定義に使用する列はできるだけ少なくする必要があります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-321">Generally, you should define the clustered index key with as few columns as possible.</span></span> <span data-ttu-id="45d3b-322">次の 1 つ以上の条件を満たす列を使用するようにしてください。</span><span class="sxs-lookup"><span data-stu-id="45d3b-322">Consider columns that have one or more of the following attributes:</span></span>  
  
-   <span data-ttu-id="45d3b-323">一意な値または多数の異なる値を含む。</span><span class="sxs-lookup"><span data-stu-id="45d3b-323">Are unique or contain many distinct values</span></span>  
  
     <span data-ttu-id="45d3b-324">たとえば、従業員 ID は、従業員を一意に識別します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-324">For example, an employee ID uniquely identifies employees.</span></span> <span data-ttu-id="45d3b-325">`EmployeeID` 列にクラスター化インデックスまたは PRIMARY KEY 制約を設定すると、従業員 ID 番号に基づいて従業員情報を検索するクエリのパフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-325">A clustered index or PRIMARY KEY constraint on the `EmployeeID` column would improve the performance of queries that search for employee information based on the employee ID number.</span></span> <span data-ttu-id="45d3b-326">また、 `LastName`列、 `FirstName`列、 `MiddleName` 列を基にクラスター化インデックスを作成することもできます。従業員レコードは、これらの列でグループ化されたりクエリが実行されることが多く、これらの列を組み合わせると高い多様性が生まれます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-326">Alternatively, a clustered index could be created on `LastName`, `FirstName`, `MiddleName` because employee records are frequently grouped and queried in this way, and the combination of these columns would still provide a high degree of difference.</span></span>  
  
-   <span data-ttu-id="45d3b-327">順次アクセスされる。</span><span class="sxs-lookup"><span data-stu-id="45d3b-327">Are accessed sequentially</span></span>  
  
     <span data-ttu-id="45d3b-328">たとえば、製品 ID は、 `Production.Product` データベースの [!INCLUDE[ssSampleDBobject](../includes/sssampledbobject-md.md)] テーブルにある製品を一意に識別します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-328">For example, a product ID uniquely identifies products in the `Production.Product` table in the [!INCLUDE[ssSampleDBobject](../includes/sssampledbobject-md.md)] database.</span></span> <span data-ttu-id="45d3b-329">`WHERE ProductID BETWEEN 980 and 999`など、順次検索が指定されているクエリでは、 `ProductID`列に基づくクラスター化インデックスによりパフォーマンスが向上する場合があります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-329">Queries in which a sequential search is specified, such as `WHERE ProductID BETWEEN 980 and 999`, would benefit from a clustered index on `ProductID`.</span></span> <span data-ttu-id="45d3b-330">これは、行がこのキー列を基に並べ替えて格納されている場合があるためです。</span><span class="sxs-lookup"><span data-stu-id="45d3b-330">This is because the rows would be stored in sorted order on that key column.</span></span>  
  
-   <span data-ttu-id="45d3b-331">ID として定義されている。</span><span class="sxs-lookup"><span data-stu-id="45d3b-331">Defined as IDENTITY.</span></span>  
  
-   <span data-ttu-id="45d3b-332">テーブルから取得したデータの並べ替えに頻繁に使用される。</span><span class="sxs-lookup"><span data-stu-id="45d3b-332">Used frequently to sort the data retrieved from a table.</span></span>  
  
     <span data-ttu-id="45d3b-333">このような列を基にテーブルをクラスター化する (つまり、物理的に並べ替える) と、この列に対してクエリを実行するたびに並べ替えにかかるコストを節約できるため便利です。</span><span class="sxs-lookup"><span data-stu-id="45d3b-333">It can be a good idea to cluster, that is physically sort, the table on that column to save the cost of a sort operation every time the column is queried.</span></span>  
  
 <span data-ttu-id="45d3b-334">次のような場合は、クラスター化インデックスの使用は適していません。</span><span class="sxs-lookup"><span data-stu-id="45d3b-334">Clustered indexes are not a good choice for the following attributes:</span></span>  
  
-   <span data-ttu-id="45d3b-335">頻繁に変更される列</span><span class="sxs-lookup"><span data-stu-id="45d3b-335">Columns that undergo frequent changes</span></span>  
  
     <span data-ttu-id="45d3b-336">これにより、は [!INCLUDE[ssDE](../includes/ssde-md.md)] 行のデータ値を物理的な順序で保持する必要があるため、行全体が移動します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-336">This causes the whole row to move, because the [!INCLUDE[ssDE](../includes/ssde-md.md)] must keep the data values of a row in physical order.</span></span> <span data-ttu-id="45d3b-337">データが頻繁に変更される大規模トランザクション処理システムでは、特にこの点に留意してください。</span><span class="sxs-lookup"><span data-stu-id="45d3b-337">This is an important consideration in high-volume transaction processing systems in which data is typically volatile.</span></span>  
  
-   <span data-ttu-id="45d3b-338">広範なキー</span><span class="sxs-lookup"><span data-stu-id="45d3b-338">Wide keys</span></span>  
  
     <span data-ttu-id="45d3b-339">広範なキーは、複数の列または複数のサイズの大きな列を組み合わせたものです。</span><span class="sxs-lookup"><span data-stu-id="45d3b-339">Wide keys are a composite of several columns or several large-size columns.</span></span> <span data-ttu-id="45d3b-340">クラスター化インデックスのキー値は、すべての非クラスター化インデックスにより、参照キーとして使用されます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-340">The key values from the clustered index are used by all nonclustered indexes as lookup keys.</span></span> <span data-ttu-id="45d3b-341">非クラスター化インデックスのエントリには、クラスター化キー以外に、非クラスター化インデックスのキー列も格納されるため、同じテーブルに非クラスター化インデックスが定義されている場合は、サイズがかなり大きくなります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-341">Any nonclustered indexes defined on the same table will be significantly larger because the nonclustered index entries contain the clustering key and also the key columns defined for that nonclustered index.</span></span>  
  
 <span data-ttu-id="45d3b-342">[このガイドの [](#Top) ![トップに戻る] リンクで使用される矢印アイコン](media/uparrow16x16.gif "[トップに戻る] リンクで使用される矢印アイコン")</span><span class="sxs-lookup"><span data-stu-id="45d3b-342">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
##  <a name="nonclustered-index-design-guidelines"></a><a name="Nonclustered"></a> <span data-ttu-id="45d3b-343">非クラスター化インデックスのデザイン ガイドライン</span><span class="sxs-lookup"><span data-stu-id="45d3b-343">Nonclustered Index Design Guidelines</span></span>  

 <span data-ttu-id="45d3b-344">非クラスター化インデックスには、インデックス キー値、およびテーブル データの格納場所を指す行ロケーターが含まれています。</span><span class="sxs-lookup"><span data-stu-id="45d3b-344">A nonclustered index contains the index key values and row locators that point to the storage location of the table data.</span></span> <span data-ttu-id="45d3b-345">1 つのテーブルまたはインデックス付きビューに複数の非クラスター化インデックスを作成できます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-345">You can create multiple nonclustered indexes on a table or indexed view.</span></span> <span data-ttu-id="45d3b-346">一般に、非クラスター化インデックスは、頻繁に使用するクエリで、クラスター化インデックスで対応されないクエリのパフォーマンスを向上するようにデザインします。</span><span class="sxs-lookup"><span data-stu-id="45d3b-346">Generally, nonclustered indexes should be designed to improve the performance of frequently used queries that are not covered by the clustered index.</span></span>  
  
 <span data-ttu-id="45d3b-347">クエリ オプティマイザーでデータ値を検索するときは、本の索引を使用する場合と同じように、非クラスター化インデックスを検索してテーブル内でのデータ値の位置を探し、その位置から直接データを取得します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-347">Similar to the way you use an index in a book, the query optimizer searches for a data value by searching the nonclustered index to find the location of the data value in the table and then retrieves the data directly from that location.</span></span> <span data-ttu-id="45d3b-348">非クラスター化インデックスには、クエリの検索対象であるデータ値のテーブル内での位置を正確に記述するエントリが格納されているので、完全一致比較クエリの場合は非クラスター化インデックスが最適です。</span><span class="sxs-lookup"><span data-stu-id="45d3b-348">This makes nonclustered indexes the optimal choice for exact match queries because the index contains entries describing the exact location in the table of the data values being searched for in the queries.</span></span> <span data-ttu-id="45d3b-349">たとえば、 `HumanResources. Employee` テーブルに対してクエリを実行し、ある 1 人の上司に直属するすべての従業員を取得する場合、クエリ オプティマイザーは `IX_Employee_ManagerID`をキー列として、非クラスター化インデックス `ManagerID` を使用することができます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-349">For example, to query the `HumanResources. Employee` table for all employees that report to a specific manager, the query optimizer might use the nonclustered index `IX_Employee_ManagerID`; this has `ManagerID` as its key column.</span></span> <span data-ttu-id="45d3b-350">クエリ オプティマイザーはこのインデックスの中から、指定された `ManagerID`と一致するすべてのエントリを迅速に検索できます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-350">The query optimizer can quickly find all entries in the index that match the specified `ManagerID`.</span></span> <span data-ttu-id="45d3b-351">インデックスの各エントリのポインターは、テーブル (またはクラスター化インデックス) の、対応するデータが見つかる正確なページおよび行を指しています。</span><span class="sxs-lookup"><span data-stu-id="45d3b-351">Each index entry points to the exact page and row in the table, or clustered index, in which the corresponding data can be found.</span></span> <span data-ttu-id="45d3b-352">クエリ オプティマイザーは、インデックスの中からすべてのエントリを検出した後、正確なページおよび行に直接移動してデータを取得できます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-352">After the query optimizer finds all entries in the index, it can go directly to the exact page and row to retrieve the data.</span></span>  
  
### <a name="nonclustered-index-architecture"></a><span data-ttu-id="45d3b-353">非クラスター化インデックスのアーキテクチャ</span><span class="sxs-lookup"><span data-stu-id="45d3b-353">Nonclustered Index Architecture</span></span>  

 <span data-ttu-id="45d3b-354">非クラスター化インデックスもクラスター化インデックスと同じ B ツリー構造ですが、次に示す大きな相違点があります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-354">Nonclustered indexes have the same B-tree structure as clustered indexes, except for the following significant differences:</span></span>  
  
-   <span data-ttu-id="45d3b-355">基になるテーブルのデータ行は、非クラスター化キーに基づいた順序で並べ替えられたり格納されたりしません。</span><span class="sxs-lookup"><span data-stu-id="45d3b-355">The data rows of the underlying table are not sorted and stored in order based on their nonclustered keys.</span></span>  
  
-   <span data-ttu-id="45d3b-356">非クラスター化インデックスのリーフ層は、データ ページではなくインデックス ページで構成されます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-356">The leaf layer of a nonclustered index is made up of index pages instead of data pages.</span></span>  
  
 <span data-ttu-id="45d3b-357">非クラスター化インデックス行内の行ロケーターは、次に示すような、行を指すポインターまたは行のクラスター化インデックス キーのいずれかです。</span><span class="sxs-lookup"><span data-stu-id="45d3b-357">The row locators in nonclustered index rows are either a pointer to a row or are a clustered index key for a row, as described in the following:</span></span>  
  
-   <span data-ttu-id="45d3b-358">テーブルがヒープで、クラスター化インデックスが設定されていない場合、行ロケーターはその行へのポインターです。</span><span class="sxs-lookup"><span data-stu-id="45d3b-358">If the table is a heap, which means it does not have a clustered index, the row locator is a pointer to the row.</span></span> <span data-ttu-id="45d3b-359">このポインターは、ファイル識別子 (ID)、ページ番号、およびそのページ上での行の番号で構成されます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-359">The pointer is built from the file identifier (ID), page number, and number of the row on the page.</span></span> <span data-ttu-id="45d3b-360">ポインター全体は、RID (行 ID) と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-360">The whole pointer is known as a Row ID (RID).</span></span>  
  
-   <span data-ttu-id="45d3b-361">テーブルにクラスター化インデックスがある場合、またはインデックスがインデックス付きビューにある場合は、行ロケーターが行のクラスター化インデックス キーになります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-361">If the table has a clustered index, or the index is on an indexed view, the row locator is the clustered index key for the row.</span></span>  
  
 <span data-ttu-id="45d3b-362">非クラスター化インデックスの場合、[sys.partitions](/sql/relational-databases/system-catalog-views/sys-partitions-transact-sql) にはインデックスで使用されるパーティションごとに 1 つの行が含まれます。この場合、**index_id** は 1 より大きくなります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-362">Nonclustered indexes have one row in [sys.partitions](/sql/relational-databases/system-catalog-views/sys-partitions-transact-sql) with **index_id** >1 for each partition used by the index.</span></span> <span data-ttu-id="45d3b-363">既定では、非クラスター化インデックスのパーティションは 1 つです。</span><span class="sxs-lookup"><span data-stu-id="45d3b-363">By default, a nonclustered index has a single partition.</span></span> <span data-ttu-id="45d3b-364">非クラスター化インデックスにパーティションが複数ある場合、各パーティションは、その特定のパーティションに対してインデックス行を保持する B ツリー構造になります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-364">When a nonclustered index has multiple partitions, each partition has a B-tree structure that contains the index rows for that specific partition.</span></span> <span data-ttu-id="45d3b-365">たとえば、非クラスター化インデックスに 4 つのパーティションがある場合、4 つの B ツリーを持つ構造になります。この場合、パーティションごとに 1 つの B ツリーがあります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-365">For example, if a nonclustered index has four partitions, there are four B-tree structures, with one in each partition.</span></span>  
  
 <span data-ttu-id="45d3b-366">非クラスター化インデックスのデータ型によっては、各非クラスター化インデックスの構造に 1 つ以上のアロケーション ユニットが含まれ、そこに特定のパーティションのデータが格納され、管理されます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-366">Depending on the data types in the nonclustered index, each nonclustered index structure will have one or more allocation units in which to store and manage the data for a specific partition.</span></span> <span data-ttu-id="45d3b-367">各非クラスター化インデックスには、インデックス B ツリーのページが格納されているパーティションごとに、少なくとも 1 つの IN_ROW_DATA アロケーション ユニットがあります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-367">At a minimum, each nonclustered index will have one IN_ROW_DATA allocation unit per partition that stores the index B-tree pages.</span></span> <span data-ttu-id="45d3b-368">また、非クラスター化インデックスにラージ オブジェクト (LOB) 列が含まれている場合は、パーティションごとに 1 つの LOB_DATA アロケーション ユニットもあります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-368">The nonclustered index will also have one LOB_DATA allocation unit per partition if it contains large object (LOB) columns .</span></span> <span data-ttu-id="45d3b-369">さらに、行サイズの上限である 8,060 バイトを超える可変長列が含まれている場合は、パーティションごとに 1 つの ROW_OVERFLOW_DATA があります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-369">Additionally, it will have one ROW_OVERFLOW_DATA allocation unit per partition if it contains variable length columns that exceed the 8,060 byte row size limit.</span></span>  
  
 <span data-ttu-id="45d3b-370">次の図に、1 つのパーティション内の非クラスター化インデックスの構造を示します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-370">The following illustration shows the structure of a nonclustered index in a single partition.</span></span>  
  
 <span data-ttu-id="45d3b-371">![非クラスター化インデックスのレベル](media/bokind1.gif "非クラスター化インデックスのレベル")</span><span class="sxs-lookup"><span data-stu-id="45d3b-371">![Levels of a nonclustered index](media/bokind1.gif "Levels of a nonclustered index")</span></span>  
  
### <a name="database-considerations"></a><span data-ttu-id="45d3b-372">データベースに関する注意点</span><span class="sxs-lookup"><span data-stu-id="45d3b-372">Database Considerations</span></span>  

 <span data-ttu-id="45d3b-373">非クラスター化インデックスをデザインするときは、データベースの特性を考慮してください。</span><span class="sxs-lookup"><span data-stu-id="45d3b-373">Consider the characteristics of the database when designing nonclustered indexes.</span></span>  
  
-   <span data-ttu-id="45d3b-374">更新の必要が少なく、容量の大きいデータベースまたはテーブルの場合、クエリのパフォーマンスを向上させるには非クラスター化インデックスを多数作成するのが適しています。</span><span class="sxs-lookup"><span data-stu-id="45d3b-374">Databases or tables with low update requirements, but large volumes of data can benefit from many nonclustered indexes to improve query performance.</span></span> <span data-ttu-id="45d3b-375">テーブル全体の非クラスター化インデックスと比較してクエリのパフォーマンスが向上し、インデックスのストレージ コストとインデックスのメンテナンス コストが削減されるように、適切に定義されたデータのサブセットに対してフィルター選択されたインデックスを作成することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="45d3b-375">Consider creating filtered indexes for well-defined subsets of data to improve query performance, reduce index storage costs, and reduce index maintenance costs compared with full-table nonclustered indexes.</span></span>  
  
     <span data-ttu-id="45d3b-376">読み取り専用データが中心の意思決定支援システム アプリケーションおよびデータベースは、非クラスター化インデックスを多数作成するのが適しています。</span><span class="sxs-lookup"><span data-stu-id="45d3b-376">Decision Support System applications and databases that contain primarily read-only data can benefit from many nonclustered indexes.</span></span> <span data-ttu-id="45d3b-377">非クラスター化インデックスを多数作成すると、クエリ オプティマイザーにより最速のアクセス手段が判断される際の選択肢になるインデックスが多く、データベースの更新頻度が低いのでインデックスのメンテナンスによってパフォーマンスが低下することはありません。</span><span class="sxs-lookup"><span data-stu-id="45d3b-377">The query optimizer has more indexes to choose from to determine the fastest access method, and the low update characteristics of the database mean index maintenance will not impede performance.</span></span>  
  
-   <span data-ttu-id="45d3b-378">テーブルの更新頻度が高いオンライン トランザクション処理アプリケーションおよびデータベースに、インデックスを過度に作成することはお勧めしません。</span><span class="sxs-lookup"><span data-stu-id="45d3b-378">Online Transaction Processing applications and databases that contain heavily updated tables should avoid over-indexing.</span></span> <span data-ttu-id="45d3b-379">また、インデックスの列数はできる限り抑えてください。</span><span class="sxs-lookup"><span data-stu-id="45d3b-379">Additionally, indexes should be narrow, that is, with as few columns as possible.</span></span>  
  
     <span data-ttu-id="45d3b-380">1 つのテーブルに多数のインデックスがあると、テーブル内のデータが変更された場合にインデックスをすべて調整する必要があるので、INSERT、UPDATE、DELETE、および MERGE の各ステートメントのパフォーマンスに影響します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-380">Large numbers of indexes on a table affect the performance of INSERT, UPDATE, DELETE, and MERGE  statements because all indexes must be adjusted appropriately as data in the table changes.</span></span>  
  
### <a name="query-considerations"></a><span data-ttu-id="45d3b-381">クエリに関する注意点</span><span class="sxs-lookup"><span data-stu-id="45d3b-381">Query Considerations</span></span>  

 <span data-ttu-id="45d3b-382">非クラスター化インデックスを作成する前に、データがどのようにアクセスされるかを理解しておいてください。</span><span class="sxs-lookup"><span data-stu-id="45d3b-382">Before you create nonclustered indexes, you should understand how your data will be accessed.</span></span> <span data-ttu-id="45d3b-383">次に示す特徴があるクエリには非クラスター化インデックスを使用することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="45d3b-383">Consider using a nonclustered index for queries that have the following attributes:</span></span>  
  
-   <span data-ttu-id="45d3b-384">JOIN 句または GROUP BY 句を使用している。</span><span class="sxs-lookup"><span data-stu-id="45d3b-384">Use JOIN or GROUP BY clauses.</span></span>  
  
     <span data-ttu-id="45d3b-385">結合操作やグループ化操作に使用する列の非クラスター化インデックスを複数作成し、外部キー列にクラスター化インデックスを作成してください。</span><span class="sxs-lookup"><span data-stu-id="45d3b-385">Create multiple nonclustered indexes on columns involved in join and grouping operations, and a clustered index on any foreign key columns.</span></span>  
  
-   <span data-ttu-id="45d3b-386">大きな結果セットを返さないクエリ。</span><span class="sxs-lookup"><span data-stu-id="45d3b-386">Queries that do not return large result sets.</span></span>  
  
     <span data-ttu-id="45d3b-387">大きなテーブルから適切に定義された行のサブセットを返すクエリに対応するために、フィルター選択されたインデックスを作成してください。</span><span class="sxs-lookup"><span data-stu-id="45d3b-387">Create filtered indexes to cover queries that return a well-defined subset of rows from a large table.</span></span>  
  
-   <span data-ttu-id="45d3b-388">完全一致を返すクエリの検索条件 (WHERE 句など) に頻繁に使用される列を含んでいる。</span><span class="sxs-lookup"><span data-stu-id="45d3b-388">Contain columns frequently involved in search conditions of a query, such as WHERE clause, that return exact matches.</span></span>  
  
### <a name="column-considerations"></a><span data-ttu-id="45d3b-389">列に関する注意点</span><span class="sxs-lookup"><span data-stu-id="45d3b-389">Column Considerations</span></span>  

 <span data-ttu-id="45d3b-390">次に示す特徴に 1 つ以上該当する列を考慮してください。</span><span class="sxs-lookup"><span data-stu-id="45d3b-390">Consider columns that have one or more of these attributes:</span></span>  
  
-   <span data-ttu-id="45d3b-391">クエリを包括している。</span><span class="sxs-lookup"><span data-stu-id="45d3b-391">Cover the query.</span></span>  
  
     <span data-ttu-id="45d3b-392">インデックスにクエリのすべての列が含まれていると、パフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-392">Performance gains are achieved when the index contains all columns in the query.</span></span> <span data-ttu-id="45d3b-393">クエリ オプティマイザーではインデックス内ですべての列値を参照できるので、テーブルやクラスター化インデックスのデータにアクセスすることがなく、ディスク I/O 操作が少なくてすみます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-393">The query optimizer can locate all the column values within the index; table or clustered index data is not accessed resulting in fewer disk I/O operations.</span></span> <span data-ttu-id="45d3b-394">列数の多いインデックス キーを作成する代わりに、包括する列を追加するには、付加列インデックスを使用します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-394">Use index with included columns to add covering columns instead of creating a wide index key.</span></span>  
  
     <span data-ttu-id="45d3b-395">テーブルにクラスター化インデックスがある場合、クラスター化インデックスに定義された列がテーブルの各非クラスター化インデックスの末尾に自動的に付加されます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-395">If the table has a clustered index, the column or columns defined in the clustered index are automatically appended to the end of each nonclustered index on the table.</span></span> <span data-ttu-id="45d3b-396">その結果、非クラスター化インデックスの定義にクラスター化インデックスの列を指定することなく、インデックスにはクエリで使用するすべての列が含まれることになります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-396">This can produce a covered query without specifying the clustered index columns in the definition of the nonclustered index.</span></span> <span data-ttu-id="45d3b-397">たとえば、あるテーブルの列 `C`にクラスター化インデックスがある場合、列 `B` および `A` の非クラスター化インデックスのキー値は列 `B`、 `A`、および `C`となります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-397">For example, if a table has a clustered index on column `C`, a nonclustered index on columns `B` and `A` will have as its key values columns `B`, `A`, and `C`.</span></span>  
  
-   <span data-ttu-id="45d3b-398">姓と名の組み合わせなど、多数の異なる値が格納されている (他の列にクラスター化インデックスが使用されている場合)。</span><span class="sxs-lookup"><span data-stu-id="45d3b-398">Lots of distinct values, such as a combination of last name and first name, if a clustered index is used for other columns.</span></span>  
  
     <span data-ttu-id="45d3b-399">1 と 0 のみなど異なる値が少数しかない場合、テーブル スキャンを行う方が通常は効率的なので、ほとんどのクエリではインデックスが使用されません。</span><span class="sxs-lookup"><span data-stu-id="45d3b-399">If there are very few distinct values, such as only 1 and 0, most queries will not use the index because a table scan is generally more efficient.</span></span> <span data-ttu-id="45d3b-400">このようなデータの場合は、少数の行のみに含まれる異なる値に対してフィルター選択されたインデックスを作成することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="45d3b-400">For this type of data, consider creating a filtered index on a distinct value that only occurs in a small number of rows.</span></span> <span data-ttu-id="45d3b-401">たとえば、ほとんどの値が 0 の場合は、クエリ オプティマイザーで 1 を含むデータ行に対してフィルター選択されたインデックスを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-401">For example, if most of the values are 0, the query optimizer might use a filtered index for the data rows that contain 1.</span></span>  
  
####  <a name="use-included-columns-to-extend-nonclustered-indexes"></a><a name="Included_Columns"></a> <span data-ttu-id="45d3b-402">付加列の使用による非クラスター化インデックスの拡張</span><span class="sxs-lookup"><span data-stu-id="45d3b-402">Use Included Columns to Extend Nonclustered Indexes</span></span>  

 <span data-ttu-id="45d3b-403">非クラスター化インデックスのリーフ レベルに非キー列を追加することにより、非クラスター化インデックスの機能を拡張できます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-403">You can extend the functionality of nonclustered indexes by adding nonkey columns to the leaf level of the nonclustered index.</span></span> <span data-ttu-id="45d3b-404">非キー列を含めることにより、より多くのクエリをカバーする非クラスター化インデックスを作成できます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-404">By including nonkey columns, you can create nonclustered indexes that cover more queries.</span></span> <span data-ttu-id="45d3b-405">これは、非キー列には次の利点があるためです。</span><span class="sxs-lookup"><span data-stu-id="45d3b-405">This is because the nonkey columns have the following benefits:</span></span>  
  
-   <span data-ttu-id="45d3b-406">非キー列には、インデックス キー列として許可されていないデータ型を設定できる。</span><span class="sxs-lookup"><span data-stu-id="45d3b-406">They can be data types not allowed as index key columns.</span></span>  
  
-   <span data-ttu-id="45d3b-407">インデックス キー列の数やインデックス キーのサイズを計算するときに、 [!INCLUDE[ssDE](../includes/ssde-md.md)] では非キー列が考慮されない。</span><span class="sxs-lookup"><span data-stu-id="45d3b-407">They are not considered by the [!INCLUDE[ssDE](../includes/ssde-md.md)] when calculating the number of index key columns or index key size.</span></span>  
  
 <span data-ttu-id="45d3b-408">クエリ内のすべての列が、キー列または非キー列のいずれかとしてインデックスに含まれるているとき、非キー付加列を含むインデックスにより、クエリ パフォーマンスが大幅に向上します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-408">An index with included nonkey columns can significantly improve query performance when all columns in the query are included in the index either as key or nonkey columns.</span></span> <span data-ttu-id="45d3b-409">クエリ オプティマイザーではインデックス内のすべての列値を参照できるので、テーブルやクラスター化インデックスのデータにアクセスすることがなく、ディスク I/O 操作が少なくて済むため、パフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-409">Performance gains are achieved because the query optimizer can locate all the column values within the index; table or clustered index data is not accessed resulting in fewer disk I/O operations.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="45d3b-410">クエリによって参照されるすべての列がインデックスに含まれているときは、一般的に、そのインデックスはクエリをカバーしていると呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-410">When an index contains all the columns referenced by the query it is typically referred to as covering the query.</span></span>  
  
 <span data-ttu-id="45d3b-411">キー列がインデックスのすべてのレベルに格納されている場合は、非キー列はリーフ レベルだけに格納されます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-411">While key columns are stored at all levels of the index, nonkey columns are stored only at the leaf level.</span></span>  
  
##### <a name="using-included-columns-to-avoid-size-limits"></a><span data-ttu-id="45d3b-412">サイズ制限を回避するための付加列の使用</span><span class="sxs-lookup"><span data-stu-id="45d3b-412">Using Included Columns to Avoid Size Limits</span></span>  

 <span data-ttu-id="45d3b-413">非クラスター化インデックスに非キー列を含めることで、現在のインデックス サイズの制限 (最大 16 個のキー列と最大 900 バイトのインデックス キーのサイズ) を超えないようにすることができます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-413">You can include nonkey columns in a nonclustered index to avoid exceeding the current index size limitations of a maximum of 16 key columns and a maximum index key size of 900 bytes.</span></span> <span data-ttu-id="45d3b-414">インデックス キー列の数やインデックス キーのサイズを計算するときに、 [!INCLUDE[ssDE](../includes/ssde-md.md)] では非キー列が考慮されません。</span><span class="sxs-lookup"><span data-stu-id="45d3b-414">The [!INCLUDE[ssDE](../includes/ssde-md.md)] does not consider nonkey columns when calculating the number of index key columns or index key size.</span></span>  
  
 <span data-ttu-id="45d3b-415">たとえば、 `Document` テーブルにある次の列にインデックスを設定するとします。</span><span class="sxs-lookup"><span data-stu-id="45d3b-415">For example, assume that you want to index the following columns in the `Document` table:</span></span>  
  
 `Title nvarchar(50)`  
  
 `Revision nchar(5)`  
  
 `FileName nvarchar(400)`  
  
 <span data-ttu-id="45d3b-416">`nchar` データ型および `nvarchar` データ型は各文字に 2 バイト要するため、これら 3 つの列が含まれるインデックスは 900 バイトのサイズ制限を 10 バイト超えます (455 \* 2)。</span><span class="sxs-lookup"><span data-stu-id="45d3b-416">Because the `nchar` and `nvarchar` data types require 2 bytes for each character, an index that contains these three columns would exceed the 900 byte size limitation by 10 bytes (455 \* 2).</span></span> <span data-ttu-id="45d3b-417">`INCLUDE` ステートメントの `CREATE INDEX` 句を使用することにより、インデックス キーを (`Title, Revision`) として定義し、 `FileName` を非キー列として定義できます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-417">By using the `INCLUDE` clause of the `CREATE INDEX` statement, the index key could be defined as (`Title, Revision`) and `FileName` defined as a nonkey column.</span></span> <span data-ttu-id="45d3b-418">その結果、インデックス キーのサイズが 110 バイト (55 \* 2) になりましたが、インデックスには必要な列がすべて含まれています。</span><span class="sxs-lookup"><span data-stu-id="45d3b-418">In this way, the index key size would be 110 bytes (55 \* 2), and the index would still contain all the required columns.</span></span> <span data-ttu-id="45d3b-419">このようなインデックスは、次のステートメントで作成されます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-419">The following statement creates such an index.</span></span>  
  
```sql
CREATE INDEX IX_Document_Title   
ON Production.Document (Title, Revision)   
INCLUDE (FileName);   
```  
  
##### <a name="index-with-included-columns-guidelines"></a><span data-ttu-id="45d3b-420">付加列インデックスのガイドライン</span><span class="sxs-lookup"><span data-stu-id="45d3b-420">Index with Included Columns Guidelines</span></span>  

 <span data-ttu-id="45d3b-421">付加列非クラスター化インデックスを設計するときは、次のガイドラインについて考慮してください。</span><span class="sxs-lookup"><span data-stu-id="45d3b-421">When you design nonclustered indexes with included columns consider the following guidelines:</span></span>  
  
-   <span data-ttu-id="45d3b-422">非キー列は、CREATE INDEX ステートメントの INCLUDE 句で定義されます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-422">Nonkey columns are defined in the INCLUDE clause of the CREATE INDEX statement.</span></span>  
  
-   <span data-ttu-id="45d3b-423">非キー列は、テーブルやインデックス付きビューの非クラスター化インデックスにのみ定義できます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-423">Nonkey columns can only be defined on nonclustered indexes on tables or indexed views.</span></span>  
  
-   <span data-ttu-id="45d3b-424">`text`、`ntext`、および `image` を除く、すべてのデータ型を使用できます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-424">All data types are allowed except `text`, `ntext`, and `image`.</span></span>  
  
-   <span data-ttu-id="45d3b-425">決定的な計算列、および正確または不正確な計算列を、付加列にできます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-425">Computed columns that are deterministic and either precise or imprecise can be included columns.</span></span> <span data-ttu-id="45d3b-426">詳細については、「 [計算列のインデックス](../relational-databases/indexes/indexes-on-computed-columns.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="45d3b-426">For more information, see [Indexes on Computed Columns](../relational-databases/indexes/indexes-on-computed-columns.md).</span></span>  
  
-   <span data-ttu-id="45d3b-427">キー列と同様に、計算列が `image`、`ntext`、および `text` の各データ型から派生している場合は、計算列のデータ型が非キー インデックス列として許可されている限り、非キー (付加) 列にできます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-427">As with key columns, computed columns derived from `image`, `ntext`, and `text` data types can be nonkey (included) columns as long as the computed column data type is allowed as a nonkey index column.</span></span>  
  
-   <span data-ttu-id="45d3b-428">INCLUDE リストとキー列リストの両方に、列名を指定することはできません。</span><span class="sxs-lookup"><span data-stu-id="45d3b-428">Column names cannot be specified in both the INCLUDE list and in the key column list.</span></span>  
  
-   <span data-ttu-id="45d3b-429">INCLUDE リスト内で列名を繰り返すことはできません。</span><span class="sxs-lookup"><span data-stu-id="45d3b-429">Column names cannot be repeated in the INCLUDE list.</span></span>  
  
##### <a name="column-size-guidelines"></a><span data-ttu-id="45d3b-430">列サイズのガイドライン</span><span class="sxs-lookup"><span data-stu-id="45d3b-430">Column Size Guidelines</span></span>  
  
-   <span data-ttu-id="45d3b-431">キー列は少なくとも 1 つ定義する必要があります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-431">At least one key column must be defined.</span></span> <span data-ttu-id="45d3b-432">非キー列の最大数は 1,023 列です。</span><span class="sxs-lookup"><span data-stu-id="45d3b-432">The maximum number of nonkey columns is 1023 columns.</span></span> <span data-ttu-id="45d3b-433">これは、テーブルの最大列数から 1 を引いた数です。</span><span class="sxs-lookup"><span data-stu-id="45d3b-433">This is the maximum number of table columns minus 1.</span></span>  
  
-   <span data-ttu-id="45d3b-434">非キーを除くインデックス キー列は、既存のインデックス サイズの制限 (最大 16 個のキー列、インデックス キーの合計サイズ 900 バイト) に従う必要があります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-434">Index key columns, excluding nonkeys, must follow the existing index size restrictions of 16 key columns maximum, and a total index key size of 900 bytes.</span></span>  
  
-   <span data-ttu-id="45d3b-435">すべての非キー列の合計サイズは、INCLUDE 句で指定された列のサイズによってのみ制限されます。たとえば、`varchar(max)` 列は 2 GB に制限されます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-435">The total size of all nonkey columns is limited only by the size of the columns specified in the INCLUDE clause; for example, `varchar(max)` columns are limited to 2 GB.</span></span>  
  
##### <a name="column-modification-guidelines"></a><span data-ttu-id="45d3b-436">列の変更のガイドライン</span><span class="sxs-lookup"><span data-stu-id="45d3b-436">Column Modification Guidelines</span></span>  

 <span data-ttu-id="45d3b-437">付加列として定義されたテーブル列を変更するときには、次の制限が適用されます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-437">When you modify a table column that has been defined as an included column, the following restrictions apply:</span></span>  
  
-   <span data-ttu-id="45d3b-438">インデックスを先に削除しない限り、非キー列をテーブルから削除できません。</span><span class="sxs-lookup"><span data-stu-id="45d3b-438">Nonkey columns cannot be dropped from the table unless the index is dropped first.</span></span>  
  
-   <span data-ttu-id="45d3b-439">次の操作以外に、非キー列は変更できません。</span><span class="sxs-lookup"><span data-stu-id="45d3b-439">Nonkey columns cannot be changed, except to do the following:</span></span>  
  
    -   <span data-ttu-id="45d3b-440">列の NULL 値の許容を NOT NULL から NULL に変更する。</span><span class="sxs-lookup"><span data-stu-id="45d3b-440">Change the nullability of the column from NOT NULL to NULL.</span></span>  
  
    -   <span data-ttu-id="45d3b-441">`varchar`、`nvarchar`、または `varbinary` の各列の長さを拡張する。</span><span class="sxs-lookup"><span data-stu-id="45d3b-441">Increase the length of `varchar`, `nvarchar`, or `varbinary` columns.</span></span>  
  
        > [!NOTE]  
        >  <span data-ttu-id="45d3b-442">これらの列の変更の制限は、インデックス キー列にも適用されます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-442">These column modification restrictions also apply to index key columns.</span></span>  
  
##### <a name="design-recommendations"></a><span data-ttu-id="45d3b-443">設計上の推奨事項</span><span class="sxs-lookup"><span data-stu-id="45d3b-443">Design Recommendations</span></span>  

 <span data-ttu-id="45d3b-444">検索や参照に使用される列のみがキー列になるように、大きなサイズのインデックス キーを使用して、非クラスター化インデックスを設計し直します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-444">Redesign nonclustered indexes with a large index key size so that only columns used for searching and lookups are key columns.</span></span> <span data-ttu-id="45d3b-445">クエリをカバーする他のすべての列を、非キー付加列にします。</span><span class="sxs-lookup"><span data-stu-id="45d3b-445">Make all other columns that cover the query included nonkey columns.</span></span> <span data-ttu-id="45d3b-446">その結果、クエリをカバーするために必要なすべての列を含むことができますが、インデックス キー自体は小さく、効率的です。</span><span class="sxs-lookup"><span data-stu-id="45d3b-446">In this way, you will have all columns needed to cover the query, but the index key itself is small and efficient.</span></span>  
  
 <span data-ttu-id="45d3b-447">たとえば、次のクエリをカバーするインデックスを設計するとします。</span><span class="sxs-lookup"><span data-stu-id="45d3b-447">For example, assume that you want to design an index to cover the following query.</span></span>  
  
```sql
SELECT AddressLine1, AddressLine2, City, StateProvinceID, PostalCode  
FROM Person.Address  
WHERE PostalCode BETWEEN N'98000' and N'99999';  
```  
  
 <span data-ttu-id="45d3b-448">クエリをカバーするには、インデックスに各列を定義する必要があります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-448">To cover the query, each column must be defined in the index.</span></span> <span data-ttu-id="45d3b-449">すべての列をキー列として定義でき、その場合キーのサイズは 334 バイトになります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-449">Although you could define all columns as key columns, the key size would be 334 bytes.</span></span> <span data-ttu-id="45d3b-450">実際に検索条件に使用されている唯一の列は、30 バイトの長さの `PostalCode` 列なので、より効果的な設計のインデックスにするには、キー列として `PostalCode` を定義し、他のすべての列を非キー列として含めます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-450">Because the only column actually used as search criteria is the `PostalCode` column, having a length of 30 bytes, a better index design would define `PostalCode` as the key column and include all other columns as nonkey columns.</span></span>  
  
 <span data-ttu-id="45d3b-451">次のステートメントにより、クエリをカバーする付加列インデックスが作成されます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-451">The following statement creates an index with included columns to cover the query.</span></span>  
  
```sql
CREATE INDEX IX_Address_PostalCode  
ON Person.Address (PostalCode)  
INCLUDE (AddressLine1, AddressLine2, City, StateProvinceID);  
```  
  
##### <a name="performance-considerations"></a><span data-ttu-id="45d3b-452">パフォーマンスに関する考慮事項</span><span class="sxs-lookup"><span data-stu-id="45d3b-452">Performance Considerations</span></span>  

 <span data-ttu-id="45d3b-453">不要な列は追加しないでください。</span><span class="sxs-lookup"><span data-stu-id="45d3b-453">Avoid adding unnecessary columns.</span></span> <span data-ttu-id="45d3b-454">キーまたは非キーのインデックス列を追加しすぎると、次のようなパフォーマンス上の問題が発生することがあります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-454">Adding too many index columns, key or nonkey, can have the following performance implications:</span></span>  
  
-   <span data-ttu-id="45d3b-455">1 ページに収まるインデックス行が少なくなります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-455">Fewer index rows will fit on a page.</span></span> <span data-ttu-id="45d3b-456">これにより、ディスク I/O が増加しキャッシュ効率が低下します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-456">This could create I/O increases and reduced cache efficiency.</span></span>  
  
-   <span data-ttu-id="45d3b-457">インデックスを格納するために、さらに多くのディスク領域が必要になります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-457">More disk space will be required to store the index.</span></span> <span data-ttu-id="45d3b-458">特に、`varchar(max)`、`nvarchar(max)`、`varbinary(max)`、または `xml` のデータ型を非キー インデックス列として追加すると、必要なディスク領域が大幅に増加します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-458">In particular, adding `varchar(max)`, `nvarchar(max)`, `varbinary(max)`, or `xml` data types as nonkey index columns may significantly increase disk space requirements.</span></span> <span data-ttu-id="45d3b-459">これは、列の値がインデックスのリーフ レベルにコピーされるためです。</span><span class="sxs-lookup"><span data-stu-id="45d3b-459">This is because the column values are copied into the index leaf level.</span></span> <span data-ttu-id="45d3b-460">そのため、列の値がインデックスとベース テーブルの両方に存在します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-460">Therefore, they reside in both the index and the base table.</span></span>  
  
-   <span data-ttu-id="45d3b-461">インデックスのメンテナンスによって、基になるテーブルやインデックス付きビューに対する変更、挿入、更新、削除にかかる時間が長くなる場合があります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-461">Index maintenance may increase the time that it takes to perform modifications, inserts, updates, or deletes, to the underlying table or indexed view.</span></span>  
  
 <span data-ttu-id="45d3b-462">データ変更によるパフォーマンスへの影響や追加ディスク領域の要件よりも、クエリのパフォーマンスから得られる利点の方が大きいかどうかを判断する必要があります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-462">You will have to determine whether the gains in query performance outweigh the affect to performance during data modification and in additional disk space requirements.</span></span>  
  
 <span data-ttu-id="45d3b-463">[このガイドの [](#Top) ![トップに戻る] リンクで使用される矢印アイコン](media/uparrow16x16.gif "[トップに戻る] リンクで使用される矢印アイコン")</span><span class="sxs-lookup"><span data-stu-id="45d3b-463">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
##  <a name="unique-index-design-guidelines"></a><a name="Unique"></a> <span data-ttu-id="45d3b-464">一意インデックスのデザイン ガイドライン</span><span class="sxs-lookup"><span data-stu-id="45d3b-464">Unique Index Design Guidelines</span></span>  

 <span data-ttu-id="45d3b-465">一意インデックスを使用すると、インデックス キーの値が重複することがないので、テーブルのすべての行を一意にすることができます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-465">A unique index guarantees that the index key contains no duplicate values and therefore every row in the table is in some way unique.</span></span> <span data-ttu-id="45d3b-466">一意であることがデータ自体の特性である場合にだけ、一意インデックスを指定します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-466">Specifying a unique index makes sense only when uniqueness is a characteristic of the data itself.</span></span> <span data-ttu-id="45d3b-467">たとえば、主キーが `NationalIDNumber` で、 `HumanResources.Employee` テーブルの `EmployeeID`列の値が必ず一意になるようにする場合は、 `NationalIDNumber` 列で UNIQUE 制約を作成します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-467">For example, if you want to make sure that the values in the `NationalIDNumber` column in the `HumanResources.Employee` table are unique, when the primary key is `EmployeeID`, create a UNIQUE constraint on the `NationalIDNumber` column.</span></span> <span data-ttu-id="45d3b-468">ユーザーが複数の従業員に対してその列に同じ値を入力しようとすると、エラー メッセージが表示され、重複する値は入力されません。</span><span class="sxs-lookup"><span data-stu-id="45d3b-468">If the user tries to enter the same value in that column for more than one employee, an error message is displayed and the duplicate value is not entered.</span></span>  
  
 <span data-ttu-id="45d3b-469">複数列に一意インデックスを指定すると、インデックス キーの値の組み合わせはそれぞれ一意になります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-469">With multicolumn unique indexes, the index guarantees that each combination of values in the index key is unique.</span></span> <span data-ttu-id="45d3b-470">たとえば、 `LastName`列、 `FirstName`列、および `MiddleName` 列の組み合わせに一意インデックスを作成した場合、テーブル内の 2 つの行がこれらの列に対して同じ値の組み合わせを持つことはできません。</span><span class="sxs-lookup"><span data-stu-id="45d3b-470">For example, if a unique index is created on a combination of `LastName`, `FirstName`, and `MiddleName` columns, no two rows in the table could have the same combination of values for these columns.</span></span>  
  
 <span data-ttu-id="45d3b-471">クラスター化インデックスと非クラスター化インデックスは共に一意インデックスにできます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-471">Both clustered and nonclustered indexes can be unique.</span></span> <span data-ttu-id="45d3b-472">列のデータが一意である場合、1 つのテーブルに 1 つの一意クラスター化インデックスと、複数の一意非クラスター化インデックスを作成できます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-472">Provided that the data in the column is unique, you can create both a unique clustered index and multiple unique nonclustered indexes on the same table.</span></span>  
  
 <span data-ttu-id="45d3b-473">一意インデックスの利点を次に示します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-473">The benefits of unique indexes include the following:</span></span>  
  
-   <span data-ttu-id="45d3b-474">定義された列のデータの整合性が保証されます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-474">Data integrity of the defined columns is ensured.</span></span>  
  
-   <span data-ttu-id="45d3b-475">クエリ オプティマイザーの役に立つ追加情報が提供されます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-475">Additional information helpful to the query optimizer is provided.</span></span>  
  
 <span data-ttu-id="45d3b-476">PRIMARY KEY 制約または UNIQUE 制約を作成すると、指定した列に一意インデックスが自動的に作成されます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-476">Creating a PRIMARY KEY or UNIQUE constraint automatically creates a unique index on the specified columns.</span></span> <span data-ttu-id="45d3b-477">UNIQUE 制約を作成することと、制約とは無関係の一意インデックスを作成することの間に大きな違いはありません。</span><span class="sxs-lookup"><span data-stu-id="45d3b-477">There are no significant differences between creating a UNIQUE constraint and creating a unique index independent of a constraint.</span></span> <span data-ttu-id="45d3b-478">データ検証も同じ方式で行われ、クエリ オプティマイザーでは、制約によって作成された一意インデックスと手動で作成された一意インデックスは区別されません。</span><span class="sxs-lookup"><span data-stu-id="45d3b-478">Data validation occurs in the same manner and the query optimizer does not differentiate between a unique index created by a constraint or manually created.</span></span> <span data-ttu-id="45d3b-479">ただし、データの整合性を維持することを目的とした列には、列に UNIQUE 制約または PRIMARY KEY 制約を作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-479">However, you should create a UNIQUE or PRIMARY KEY constraint on the column when data integrity is the objective.</span></span> <span data-ttu-id="45d3b-480">この作業を行うことで、インデックスの目的が明確になります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-480">By doing this the objective of the index will be clear.</span></span>  
  
### <a name="considerations"></a><span data-ttu-id="45d3b-481">考慮事項</span><span class="sxs-lookup"><span data-stu-id="45d3b-481">Considerations</span></span>  
  
-   <span data-ttu-id="45d3b-482">重複するキー値がデータに存在する場合は、一意インデックス、UNIQUE 制約、または PRIMARY KEY 制約を作成できません。</span><span class="sxs-lookup"><span data-stu-id="45d3b-482">A unique index, UNIQUE constraint, or PRIMARY KEY constraint cannot be created if duplicate key values exist in the data.</span></span>  
  
-   <span data-ttu-id="45d3b-483">データが一意のときに一意性を強制する場合は、一意インデックスを作成する方が、同じ組み合わせの列に一意でないインデックスを作成するよりも、より効率的な実行プランを作成できる追加情報がクエリ オプティマイザーに提供されます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-483">If the data is unique and you want uniqueness enforced, creating a unique index instead of a nonunique index on the same combination of columns provides additional information for the query optimizer that can produce more efficient execution plans.</span></span> <span data-ttu-id="45d3b-484">この場合、一意インデックスを作成することをお勧めします (できるだけ UNIQUE 制約を作成することをお勧めします)。</span><span class="sxs-lookup"><span data-stu-id="45d3b-484">Creating a unique index (preferably by creating a UNIQUE constraint) is recommended in this case.</span></span>  
  
-   <span data-ttu-id="45d3b-485">一意非クラスター化インデックスには、付加非キー列を含めることができます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-485">A unique nonclustered index can contain included nonkey columns.</span></span> <span data-ttu-id="45d3b-486">詳細については、 [付加列インデックス](#Included_Columns)に関する記述を参照してください。</span><span class="sxs-lookup"><span data-stu-id="45d3b-486">For more information, see [Index with Included Columns](#Included_Columns).</span></span>  
  
 <span data-ttu-id="45d3b-487">[このガイドの [](#Top) ![トップに戻る] リンクで使用される矢印アイコン](media/uparrow16x16.gif "[トップに戻る] リンクで使用される矢印アイコン")</span><span class="sxs-lookup"><span data-stu-id="45d3b-487">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
##  <a name="filtered-index-design-guidelines"></a><a name="Filtered"></a> <span data-ttu-id="45d3b-488">フィルター選択されたインデックスのデザイン ガイドライン</span><span class="sxs-lookup"><span data-stu-id="45d3b-488">Filtered Index Design Guidelines</span></span>  

 <span data-ttu-id="45d3b-489">フィルター選択されたインデックスは、最適化された非クラスター化インデックスであり、適切に定義されたデータのサブセットから選択するクエリに対応する際に特に適しています。</span><span class="sxs-lookup"><span data-stu-id="45d3b-489">A filtered index is an optimized nonclustered index, especially suited to cover queries that select from a well-defined subset of data.</span></span> <span data-ttu-id="45d3b-490">フィルター選択されたインデックスは、フィルター述語を使用して、テーブル内の一部の行にインデックスを作成します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-490">It uses a filter predicate to index a portion of rows in the table.</span></span> <span data-ttu-id="45d3b-491">フィルター選択されたインデックスを適切にデザインすると、クエリのパフォーマンスが向上し、インデックスのメンテナンス コストを削減して、テーブル全体のインデックスと比較してインデックスのストレージ コストを削減することができます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-491">A well-designed filtered index can improve query performance, reduce index maintenance costs, and reduce index storage costs compared with full-table indexes.</span></span>  
  
||  
|-|  
|<span data-ttu-id="45d3b-492">**適用対象**: [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] から [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)]</span><span class="sxs-lookup"><span data-stu-id="45d3b-492">**Applies to**: [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] through [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].</span></span>|  
  
 <span data-ttu-id="45d3b-493">フィルター選択されたインデックスは、テーブル全体のインデックスよりも次の点で優れています。</span><span class="sxs-lookup"><span data-stu-id="45d3b-493">Filtered indexes can provide the following advantages over full-table indexes:</span></span>  
  
-   <span data-ttu-id="45d3b-494">**クエリのパフォーマンスとプランの品質の向上**</span><span class="sxs-lookup"><span data-stu-id="45d3b-494">**Improved query performance and plan quality**</span></span>  
  
     <span data-ttu-id="45d3b-495">フィルター選択されたインデックスを適切にデザインすると、クエリのパフォーマンスと実行プランの品質が向上します。これは、このインデックスが、テーブル全体の非クラスター化インデックスよりも小さく、フィルター選択された統計情報を含むためです。</span><span class="sxs-lookup"><span data-stu-id="45d3b-495">A well-designed filtered index improves query performance and execution plan quality because it is smaller than a full-table nonclustered index and has filtered statistics.</span></span> <span data-ttu-id="45d3b-496">フィルター選択された統計情報は、フィルター選択されたインデックスの行のみを対象としているため、テーブル全体の統計情報よりも正確です。</span><span class="sxs-lookup"><span data-stu-id="45d3b-496">The filtered statistics are more accurate than full-table statistics because they cover only the rows in the filtered index.</span></span>  
  
-   <span data-ttu-id="45d3b-497">**インデックスのメンテナンス コストの削減**</span><span class="sxs-lookup"><span data-stu-id="45d3b-497">**Reduced index maintenance costs**</span></span>  
  
     <span data-ttu-id="45d3b-498">インデックスのメンテナンスが行われるのは、データ操作言語 (DML) ステートメントがインデックス内のデータに影響を与える場合のみです。</span><span class="sxs-lookup"><span data-stu-id="45d3b-498">An index is maintained only when data manipulation language (DML) statements affect the data in the index.</span></span> <span data-ttu-id="45d3b-499">フィルター選択されたインデックスにより、インデックスのメンテナンス コストは、テーブル全体の非クラスター化インデックスと比較して削減されます。これは、フィルター選択されたインデックスは小さく、インデックス内のデータが影響を受けた場合にのみメンテナンスされるためです。</span><span class="sxs-lookup"><span data-stu-id="45d3b-499">A filtered index reduces index maintenance costs compared with a full-table nonclustered index because it is smaller and is only maintained when the data in the index is affected.</span></span> <span data-ttu-id="45d3b-500">特に、含まれるデータにほとんど影響がない場合は、多数のフィルター選択されたインデックスを作成できます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-500">It is possible to have a large number of filtered indexes, especially when they contain data that is affected infrequently.</span></span> <span data-ttu-id="45d3b-501">同様に、フィルター選択されたインデックスに頻繁に影響を受けるデータのみが含まれている場合は、インデックスのサイズを小さくすると、統計情報の更新コストが削減されます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-501">Similarly, if a filtered index contains only the frequently affected data, the smaller size of the index reduces the cost of updating the statistics.</span></span>  
  
-   <span data-ttu-id="45d3b-502">**インデックスのストレージ コストの削減**</span><span class="sxs-lookup"><span data-stu-id="45d3b-502">**Reduced index storage costs**</span></span>  
  
     <span data-ttu-id="45d3b-503">テーブル全体のインデックスが不要な場合は、フィルター選択されたインデックスを作成すると、非クラスター化インデックスのディスク ストレージを削減できます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-503">Creating a filtered index can reduce disk storage for nonclustered indexes when a full-table index is not necessary.</span></span> <span data-ttu-id="45d3b-504">ストレージ要件をあまり増やすことなく、テーブル全体の非クラスター化インデックスを複数のフィルター選択されたインデックスに置き換えることができます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-504">You can replace a full-table nonclustered index with multiple filtered indexes without significantly increasing the storage requirements.</span></span>  
  
 <span data-ttu-id="45d3b-505">フィルター選択されたインデックスは、クエリが SELECT ステートメントで参照する、適切に定義されたデータのサブセットが列に含まれている場合に役立ちます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-505">Filtered indexes are useful when columns contain well-defined subsets of data that queries reference in SELECT statements.</span></span> <span data-ttu-id="45d3b-506">次に例をいくつか示します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-506">Examples are:</span></span>  
  
-   <span data-ttu-id="45d3b-507">NULL 以外の値を少数しか含まないスパース列。</span><span class="sxs-lookup"><span data-stu-id="45d3b-507">Sparse columns that contain only a few non-NULL values.</span></span>  
  
-   <span data-ttu-id="45d3b-508">複数のカテゴリのデータを含む異種列。</span><span class="sxs-lookup"><span data-stu-id="45d3b-508">Heterogeneous columns that contain categories of data.</span></span>  
  
-   <span data-ttu-id="45d3b-509">金額、時間、日付など、値の範囲を含む列。</span><span class="sxs-lookup"><span data-stu-id="45d3b-509">Columns that contain ranges of values such as dollar amounts, time, and dates.</span></span>  
  
-   <span data-ttu-id="45d3b-510">列の値の単純な比較ロジックで定義されるテーブル パーティション。</span><span class="sxs-lookup"><span data-stu-id="45d3b-510">Table partitions that are defined by simple comparison logic for column values.</span></span>  
  
 <span data-ttu-id="45d3b-511">フィルター選択されたインデックスのメンテナンス コストの削減は、そのインデックスに含まれる行数がテーブル全体のインデックスと比較して少ない場合に、最も明確になります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-511">Reduced maintenance costs for filtered indexes are most noticeable when the number of rows in the index is small compared with a full-table index.</span></span> <span data-ttu-id="45d3b-512">フィルター選択されたインデックスにテーブル内のほとんどの行が含まれる場合は、テーブル全体のインデックスよりもメンテナンス コストがかかることがあります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-512">If the filtered index includes most of the rows in the table, it could cost more to maintain than a full-table index.</span></span> <span data-ttu-id="45d3b-513">この場合は、フィルター選択されたインデックスではなく、テーブル全体のインデックスを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-513">In this case, you should use a full-table index instead of a filtered index.</span></span>  
  
 <span data-ttu-id="45d3b-514">フィルター選択されたインデックスは 1 つのテーブルで定義され、単純な比較演算子のみをサポートします。</span><span class="sxs-lookup"><span data-stu-id="45d3b-514">Filtered indexes are defined on one table and only support simple comparison operators.</span></span> <span data-ttu-id="45d3b-515">複数のテーブルを参照するフィルター式や複雑なロジックを含むフィルター式が必要な場合は、ビューを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-515">If you need a filter expression that references multiple tables or has complex logic, you should create a view.</span></span>  
  
### <a name="design-considerations"></a><span data-ttu-id="45d3b-516">デザインに関する考慮事項</span><span class="sxs-lookup"><span data-stu-id="45d3b-516">Design Considerations</span></span>  

 <span data-ttu-id="45d3b-517">フィルター選択されたインデックスを効果的にデザインするには、アプリケーションで使用されるクエリを把握し、そのクエリがデータのサブセットとどのように関連するかを理解することが重要です。</span><span class="sxs-lookup"><span data-stu-id="45d3b-517">In order to design effective filtered indexes, it is important to understand what queries your application uses and how they relate to subsets of your data.</span></span> <span data-ttu-id="45d3b-518">適切に定義されたサブセットを持つデータの例として、ほとんどが NULL 値の列、異種カテゴリの値を含む列、および異なる範囲の値を含む列が挙げられます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-518">Some examples of data that have well-defined subsets are columns with mostly NULL values, columns with heterogeneous categories of values and columns with distinct ranges of values.</span></span> <span data-ttu-id="45d3b-519">次のデザインに関する考慮事項では、フィルター選択されたインデックスがテーブル全体のインデックスよりも優れている場合のさまざまなシナリオを示します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-519">The following design considerations give a variety of scenarios for when a filtered index can provide advantages over full-table indexes.</span></span>  
  
#### <a name="filtered-indexes-for-subsets-of-data"></a><span data-ttu-id="45d3b-520">データのサブセットのフィルター選択されたインデックス</span><span class="sxs-lookup"><span data-stu-id="45d3b-520">Filtered Indexes for Subsets of Data</span></span>  

 <span data-ttu-id="45d3b-521">クエリに関連する少数の値だけが列に含まれている場合、値のサブセットにフィルター選択されたインデックスを作成できます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-521">When a column only has a small number of relevant values for queries, you can create a filtered index on the subset of values.</span></span> <span data-ttu-id="45d3b-522">たとえば、列の値がほとんど NULL の場合に、クエリで常に NULL 以外の値を選択するときは、NULL 以外のデータ行にフィルター選択されたインデックスを作成できます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-522">For example, when the values in a column are mostly NULL and the query selects only from the non-NULL values, you can create a filtered index for the non-NULL data rows.</span></span> <span data-ttu-id="45d3b-523">作成したインデックスは、同じキー列に定義されているテーブル全体の非クラスター化インデックスよりも小さく、メンテナンス コストが少なくなります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-523">The resulting index will be smaller and cost less to maintain than a full-table nonclustered index defined on the same key columns.</span></span>  
  
 <span data-ttu-id="45d3b-524">たとえば、 `AdventureWorks2012` データベースには、 `Production.BillOfMaterials` という 2,679 行のテーブルがあります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-524">For example, the `AdventureWorks2012` database has a `Production.BillOfMaterials` table with 2679 rows.</span></span> <span data-ttu-id="45d3b-525">`EndDate` 列では、NULL 以外の値を含む行は 199 行だけで、他の 2,480 行には NULL が含まれています。</span><span class="sxs-lookup"><span data-stu-id="45d3b-525">The `EndDate` column has only 199 rows that contain a non-NULL value and the other 2480 rows contain NULL.</span></span> <span data-ttu-id="45d3b-526">次のフィルター選択されたインデックスは、インデックスで定義された列を返し、 `EndDate`で NULL 以外の値を含む行のみを選択するクエリに対応します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-526">The following filtered index would cover queries that return the columns defined in the index and that select only rows with a non-NULL value for `EndDate`.</span></span>  
  
```sql
CREATE NONCLUSTERED INDEX FIBillOfMaterialsWithEndDate  
    ON Production.BillOfMaterials (ComponentID, StartDate)  
    WHERE EndDate IS NOT NULL ;  
GO  
```  
  
 <span data-ttu-id="45d3b-527">フィルター選択されたインデックス `FIBillOfMaterialsWithEndDate` は、次のクエリに対して有効です。</span><span class="sxs-lookup"><span data-stu-id="45d3b-527">The filtered index `FIBillOfMaterialsWithEndDate` is valid for the following query.</span></span> <span data-ttu-id="45d3b-528">クエリ実行プランを表示して、クエリ オプティマイザーでフィルター選択されたインデックスが使用されたかどうかを確認できます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-528">You can display the query execution plan to determine if the query optimizer used the filtered index.</span></span>  
  
```sql
SELECT ProductAssemblyID, ComponentID, StartDate   
FROM Production.BillOfMaterials  
WHERE EndDate IS NOT NULL   
    AND ComponentID = 5   
    AND StartDate > '20080101' ;  
```  
  
 <span data-ttu-id="45d3b-529">フィルター選択されたインデックスの作成方法およびフィルター選択されたインデックスの述語式の定義方法の詳細については、「 [フィルター選択されたインデックスの作成](../relational-databases/indexes/create-filtered-indexes.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="45d3b-529">For more information about how to create filtered indexes and how to define the filtered index predicate expression, see [Create Filtered Indexes](../relational-databases/indexes/create-filtered-indexes.md).</span></span>  
  
#### <a name="filtered-indexes-for-heterogeneous-data"></a><span data-ttu-id="45d3b-530">異種データのフィルター選択されたインデックス</span><span class="sxs-lookup"><span data-stu-id="45d3b-530">Filtered Indexes for Heterogeneous Data</span></span>  

 <span data-ttu-id="45d3b-531">テーブルに異種データの行が含まれている場合、1 つ以上のカテゴリのデータに対してフィルター選択されたインデックスを作成できます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-531">When a table has heterogeneous data rows, you can create a filtered index for one or more categories of data.</span></span>  
  
 <span data-ttu-id="45d3b-532">たとえば、 `Production.Product` テーブルに示される製品がそれぞれ `ProductSubcategoryID`に割り当てられ、Bikes、Components、Clothing、Accessories の製品カテゴリに関連付けられています。</span><span class="sxs-lookup"><span data-stu-id="45d3b-532">For example, the products listed in the `Production.Product` table are each assigned to a `ProductSubcategoryID`, which are in turn associated with the product categories Bikes, Components, Clothing, or Accessories.</span></span> <span data-ttu-id="45d3b-533">`Production.Product` テーブル内にあるこうしたカテゴリの列の値はあまり密接に関連していないので、異種カテゴリとなります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-533">These categories are heterogeneous because their column values in the `Production.Product` table are not closely correlated.</span></span> <span data-ttu-id="45d3b-534">たとえば、 `Color`、 `ReorderPoint`、 `ListPrice`、 `Weight`、 `Class`、および `Style` の各列には、各製品カテゴリで固有の特性があります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-534">For example, the columns `Color`, `ReorderPoint`, `ListPrice`, `Weight`, `Class`, and `Style` have unique characteristics for each product category.</span></span> <span data-ttu-id="45d3b-535">サブカテゴリ 27 ～ 36 を含む付属品に対して頻繁に使用されるクエリがあるとします。</span><span class="sxs-lookup"><span data-stu-id="45d3b-535">Suppose that there are frequent queries for accessories which have subcategories between 27 and 36 inclusive.</span></span> <span data-ttu-id="45d3b-536">次の例に示すように、付属品のサブカテゴリにフィルター選択されたインデックスを作成することで、付属品に対するクエリのパフォーマンスを向上させることができます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-536">You can improve the performance of queries for accessories by creating a filtered index on the accessories subcategories as shown in the following example.</span></span>  
  
```sql
CREATE NONCLUSTERED INDEX FIProductAccessories  
    ON Production.Product (ProductSubcategoryID, ListPrice)   
        Include (Name)  
WHERE ProductSubcategoryID >= 27 AND ProductSubcategoryID <= 36;
```  
  
 <span data-ttu-id="45d3b-537">フィルター選択されたインデックス `FIProductAccessories` は次のクエリに対応します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-537">The filtered index `FIProductAccessories` covers the following query because the query</span></span>  
  
 <span data-ttu-id="45d3b-538">これは、クエリ結果がインデックスに含まれ、クエリ プランにベース テーブルの参照が含まれないためです。</span><span class="sxs-lookup"><span data-stu-id="45d3b-538">results are contained in the index and the query plan does not include a base table lookup.</span></span> <span data-ttu-id="45d3b-539">たとえば、クエリ述語式 `ProductSubcategoryID = 33` はフィルター選択されたインデックスの述語 `ProductSubcategoryID >= 27` および `ProductSubcategoryID <= 36`のサブセットで、クエリ述語の `ProductSubcategoryID` 列と `ListPrice` 列はどちらもインデックスのキー列であり、名前は付加列としてインデックスのリーフ レベルに格納されます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-539">For example, the query predicate expression `ProductSubcategoryID = 33` is a subset of the filtered index predicate `ProductSubcategoryID >= 27` and `ProductSubcategoryID <= 36`, the `ProductSubcategoryID` and `ListPrice` columns in the query predicate are both key columns in the index, and name is stored in the leaf level of the index as an included column.</span></span>  
  
```sql
SELECT Name, ProductSubcategoryID, ListPrice  
FROM Production.Product  
WHERE ProductSubcategoryID = 33 AND ListPrice > 25.00 ;  
```  
  
#### <a name="key-columns"></a><span data-ttu-id="45d3b-540">[キー列]</span><span class="sxs-lookup"><span data-stu-id="45d3b-540">Key Columns</span></span>  

 <span data-ttu-id="45d3b-541">フィルター選択されたインデックスの定義に少数のキーまたは付加列を含めること、およびフィルター選択されたインデックスをクエリ オプティマイザーによってクエリ実行プランで選択するために必要な列だけを組み込むことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="45d3b-541">It is a best practice to include a small number of key or included columns in a filtered index definition, and to incorporate only the columns that are necessary for the query optimizer to choose the filtered index for the query execution plan.</span></span> <span data-ttu-id="45d3b-542">クエリ オプティマイザーでは、フィルター選択されたインデックスがクエリに対応するかどうかに関係なく、フィルター選択されたインデックスがクエリに対して選択されます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-542">The query optimizer can choose a filtered index for the query regardless of whether it does or does not cover the query.</span></span> <span data-ttu-id="45d3b-543">ただし、フィルター選択されたインデックスがクエリに対応する場合は、そのインデックスが選択される可能性は高くなります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-543">However, the query optimizer is more likely to choose a filtered index if it covers the query.</span></span>  
  
 <span data-ttu-id="45d3b-544">場合によっては、フィルター選択されたインデックスは、その式の列をキー列または付加列としてフィルター選択されたインデックスの定義に含めなくても、クエリに対応します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-544">In some cases, a filtered index covers the query without including the columns in the filtered index expression as key or included columns in the filtered index definition.</span></span> <span data-ttu-id="45d3b-545">次のガイドラインでは、フィルター選択されたインデックスの式の列をフィルター選択されたインデックスの定義でキー列または付加列にする必要がある場合について説明します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-545">The following guidelines explain when a column in the filtered index expression should be a key or included column in the filtered index definition.</span></span> <span data-ttu-id="45d3b-546">次の例では、以前に作成したフィルター選択されたインデックス `FIBillOfMaterialsWithEndDate` を使用します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-546">The examples refer to the filtered index, `FIBillOfMaterialsWithEndDate` that was created previously.</span></span>  
  
 <span data-ttu-id="45d3b-547">フィルター選択されたインデックスの式がクエリ述語と同じであり、フィルター選択されたインデックスの式の列がクエリ結果と共に返されない場合、その式の列を、フィルター選択されたインデックスの定義でキー列または付加列にする必要はありません。</span><span class="sxs-lookup"><span data-stu-id="45d3b-547">A column in the filtered index expression does not need to be a key or included column in the filtered index definition if the filtered index expression is equivalent to the query predicate and the query does not return the column in the filtered index expression with the query results.</span></span> <span data-ttu-id="45d3b-548">たとえば、クエリ述語がフィルター式と同じであり、 `FIBillOfMaterialsWithEndDate` がクエリ結果と共に返されないため、 `EndDate` は次のクエリに対応します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-548">For example, `FIBillOfMaterialsWithEndDate` covers the following query because the query predicate is equivalent to the filter expression, and `EndDate` is not returned with the query results.</span></span> <span data-ttu-id="45d3b-549">`FIBillOfMaterialsWithEndDate` は、フィルター選択されたインデックスの定義のキー列または付加列として `EndDate` を必要としません。</span><span class="sxs-lookup"><span data-stu-id="45d3b-549">`FIBillOfMaterialsWithEndDate` does not need `EndDate` as a key or included column in the filtered index definition.</span></span>  
  
```sql
SELECT ComponentID, StartDate FROM Production.BillOfMaterials  
WHERE EndDate IS NOT NULL;   
```  
  
 <span data-ttu-id="45d3b-550">フィルター選択されたインデックスの式と異なるクエリ述語で比較に列が使用される場合は、フィルター選択されたインデックスの式の列を、フィルター選択されたインデックスの定義でキー列または付加列にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-550">A column in the filtered index expression should be a key or included column in the filtered index definition if the query predicate uses the column in a comparison that is not equivalent to the filtered index expression.</span></span> <span data-ttu-id="45d3b-551">たとえば、 `FIBillOfMaterialsWithEndDate` は、フィルター選択されたインデックスから行のサブセットを選択するので、次のクエリに対して有効です。</span><span class="sxs-lookup"><span data-stu-id="45d3b-551">For example, `FIBillOfMaterialsWithEndDate` is valid for the following query because it selects a subset of rows from the filtered index.</span></span> <span data-ttu-id="45d3b-552">ただし、 `EndDate` が比較 `EndDate > '20040101'`で使用されるため、次のクエリには対応していません。この比較は、フィルター選択されたインデックスの式と異なります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-552">However, it does not cover the following query because `EndDate` is used in the comparison `EndDate > '20040101'`, which is not equivalent to the filtered index expression.</span></span> <span data-ttu-id="45d3b-553">クエリ プロセッサでは、 `EndDate`の値を参照せずにこのクエリを実行することはできません。</span><span class="sxs-lookup"><span data-stu-id="45d3b-553">The query processor cannot execute this query without looking up the values of `EndDate`.</span></span> <span data-ttu-id="45d3b-554">したがって、 `EndDate` をフィルター選択されたインデックスの定義でキー列または付加列にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-554">Therefore, `EndDate` should be a key or included column in the filtered index definition.</span></span>  
  
```sql
SELECT ComponentID, StartDate FROM Production.BillOfMaterials  
WHERE EndDate > '20040101';   
```  
  
 <span data-ttu-id="45d3b-555">フィルター選択されたインデックスの式の列がクエリ結果セットに含まれる場合、その列をフィルター選択されたインデックスの定義でキー列または付加列にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-555">A column in the filtered index expression should be a key or included column in the filtered index definition if the column is in the query result set.</span></span> <span data-ttu-id="45d3b-556">たとえば、 `FIBillOfMaterialsWithEndDate` はクエリ結果に含まれる `EndDate` 列を返すので、次のクエリに対応しません。</span><span class="sxs-lookup"><span data-stu-id="45d3b-556">For example, `FIBillOfMaterialsWithEndDate` does not cover the following query because it returns the `EndDate` column in the query results.</span></span> <span data-ttu-id="45d3b-557">したがって、 `EndDate` をフィルター選択されたインデックスの定義でキー列または付加列にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-557">Therefore, `EndDate` should be a key or included column in the filtered index definition.</span></span>  
  
```sql
SELECT ComponentID, StartDate, EndDate FROM Production.BillOfMaterials  
WHERE EndDate IS NOT NULL;  
```  
  
 <span data-ttu-id="45d3b-558">テーブルのクラスター化インデックス キーは、フィルター選択されたインデックスの定義でキー列または付加列にする必要はありません。</span><span class="sxs-lookup"><span data-stu-id="45d3b-558">The clustered index key of the table does not need to be a key or included column in the filtered index definition.</span></span> <span data-ttu-id="45d3b-559">クラスター化インデックス キーは、フィルター選択されたインデックスなど、すべての非クラスター化インデックスに自動的に含まれます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-559">The clustered index key is automatically included in all nonclustered indexes, including filtered indexes.</span></span>  
  
#### <a name="data-conversion-operators-in-the-filter-predicate"></a><span data-ttu-id="45d3b-560">フィルター述語のデータ変換演算子</span><span class="sxs-lookup"><span data-stu-id="45d3b-560">Data Conversion Operators in the Filter Predicate</span></span>  

 <span data-ttu-id="45d3b-561">フィルター選択されたインデックスでは、その式に指定された比較演算子によって暗黙的または明示的なデータ変換が行われる場合、変換が比較演算子の左辺で行われると、エラーが発生します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-561">If the comparison operator specified in the filtered index expression of the filtered index results in an implicit or explicit data conversion, an error will occur if the conversion occurs on the left side of a comparison operator.</span></span> <span data-ttu-id="45d3b-562">解決方法としては、比較演算子の右辺にデータ変換演算子 (CAST または CONVERT) を含む、フィルター選択されたインデックスの式を記述します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-562">A solution is to write the filtered index expression with the data conversion operator (CAST or CONVERT) on the right side of the comparison operator.</span></span>  
  
 <span data-ttu-id="45d3b-563">次の例では、さまざまなデータ型が含まれるテーブルを作成します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-563">The following example creates a table with a variety of data types.</span></span>  
  
```sql
USE AdventureWorks2012;  
GO  
CREATE TABLE dbo.TestTable (a int, b varbinary(4));  
```  
  
 <span data-ttu-id="45d3b-564">次のフィルター選択されたインデックスの定義では、列 `b` は、定数 1 と比較するために、整数データ型に暗黙的に変換されます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-564">In the following filtered index definition, column `b` is implicitly converted to an integer data type for the purpose of comparing it to the constant 1.</span></span> <span data-ttu-id="45d3b-565">これにより、フィルター選択された述語の演算子の左辺で変換が行われるため、エラー メッセージ 10611 が生成されます。</span><span class="sxs-lookup"><span data-stu-id="45d3b-565">This generates error message 10611 because the conversion occurs on the left hand side of the operator in the filtered predicate.</span></span>  
  
```sql
CREATE NONCLUSTERED INDEX TestTabIndex ON dbo.TestTable(a,b)  
WHERE b = 1;  
```  
  
 <span data-ttu-id="45d3b-566">解決策として、次の例に示すように、右辺の定数を、列 `b`と同じ型になるように変換します。</span><span class="sxs-lookup"><span data-stu-id="45d3b-566">The solution is to convert the constant on the right hand side to be of the same type as column `b`, as seen in the following example:</span></span>  
  
```sql
CREATE INDEX TestTabIndex ON dbo.TestTable(a,b)  
WHERE b = CONVERT(Varbinary(4), 1);  
```  
  
 <span data-ttu-id="45d3b-567">データ変換を比較演算子の左辺から右辺に移動すると、変換の意味が変わることがあります。</span><span class="sxs-lookup"><span data-stu-id="45d3b-567">Moving the data conversion from the left side to the right side of a comparison operator might change the meaning of the conversion.</span></span> <span data-ttu-id="45d3b-568">この例では、CONVERT 演算子を右辺に追加したときに、整数の比較から `varbinary` の比較に変わりました。</span><span class="sxs-lookup"><span data-stu-id="45d3b-568">In the above example, when the CONVERT operator was added to the right side, the comparison changed from an integer comparison to a `varbinary` comparison.</span></span>  
  
 <span data-ttu-id="45d3b-569">[このガイドの [](#Top) ![トップに戻る] リンクで使用される矢印アイコン](media/uparrow16x16.gif "[トップに戻る] リンクで使用される矢印アイコン")</span><span class="sxs-lookup"><span data-stu-id="45d3b-569">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
##  <a name="additional-reading"></a><a name="Additional_Reading"></a> <span data-ttu-id="45d3b-570">その他の情報</span><span class="sxs-lookup"><span data-stu-id="45d3b-570">Additional Reading</span></span>  

 <span data-ttu-id="45d3b-571">[SQL Server 2008 のインデックス付きビューによるパフォーマンスの向上](https://msdn.microsoft.com/library/dd171921(v=sql.100).aspx)</span><span class="sxs-lookup"><span data-stu-id="45d3b-571">[Improving Performance with SQL Server 2008 Indexed Views](https://msdn.microsoft.com/library/dd171921(v=sql.100).aspx)</span></span>  
  
 [<span data-ttu-id="45d3b-572">パーティション テーブルとパーティション インデックス</span><span class="sxs-lookup"><span data-stu-id="45d3b-572">Partitioned Tables and Indexes</span></span>](../relational-databases/partitions/partitioned-tables-and-indexes.md)  
  
  
