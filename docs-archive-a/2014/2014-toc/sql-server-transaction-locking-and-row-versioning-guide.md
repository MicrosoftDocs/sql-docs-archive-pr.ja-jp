---
title: SQL Server トランザクションのロックおよび行のバージョン管理ガイド | Microsoft Docs
ms.custom: ''
ms.date: 01/24/2019
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: ''
ms.topic: conceptual
ms.assetid: c7757153-9697-4f01-881c-800e254918c9
author: rothja
ms.author: jroth
ms.openlocfilehash: c79f9997249568c88409394441d28c71da453d63
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/04/2020
ms.locfileid: "87632860"
---
# <a name="sql-server-transaction-locking-and-row-versioning-guide"></a><span data-ttu-id="1f03c-102">SQL Server トランザクションのロックおよび行のバージョン管理ガイド</span><span class="sxs-lookup"><span data-stu-id="1f03c-102">SQL Server Transaction Locking and Row Versioning Guide</span></span>

  <span data-ttu-id="1f03c-103">どのようなデータベースであっても、トランザクションを正しく管理しないと、ユーザー数が多いシステムでは競合やパフォーマンスの問題を招くことがあります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-103">In any database, mismanagement of transactions often leads to contention and performance problems in systems that have many users.</span></span> <span data-ttu-id="1f03c-104">データにアクセスするユーザー数が多いほど、トランザクションが効率的に行われるアプリケーションを用意することが重要になります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-104">As the number of users that access the data increases, it becomes important to have applications that use transactions efficiently.</span></span> <span data-ttu-id="1f03c-105">このガイドでは、各トランザクションの物理的な整合性の確保を目的として [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)]で使用されるロックおよび行のバージョン管理のメカニズムと、アプリケーションで効率的にトランザクションを制御する方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-105">This guide describes the locking and row versioning mechanisms the [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] uses to ensure the physical integrity of each transaction and provides information on how applications can control transactions efficiently.</span></span>  
  
<span data-ttu-id="1f03c-106">**に適用さ**れます。特に指定が [!INCLUDE[ssVersion2005](../includes/ssversion2005-md.md)] [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)] ない限り、を使用します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-106">**Applies to**: [!INCLUDE[ssVersion2005](../includes/ssversion2005-md.md)] through [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)] unless noted otherwise.</span></span>  
  
##  <a name="in-this-guide"></a><a name="Top"></a><span data-ttu-id="1f03c-107">このガイドの手順</span><span class="sxs-lookup"><span data-stu-id="1f03c-107">In This Guide</span></span>  

 [<span data-ttu-id="1f03c-108">トランザクションの基礎</span><span class="sxs-lookup"><span data-stu-id="1f03c-108">Transaction Basics</span></span>](#Basics)  
  
 [<span data-ttu-id="1f03c-109">ロックと行のバージョン管理の基本</span><span class="sxs-lookup"><span data-stu-id="1f03c-109">Locking and Row Versioning Basics</span></span>](#Lock_Basics)  
  
 [<span data-ttu-id="1f03c-110">データベースエンジンでのロック</span><span class="sxs-lookup"><span data-stu-id="1f03c-110">Locking in the Database Engine</span></span>](#Lock_Engine)  
  
 [<span data-ttu-id="1f03c-111">データベース エンジンでの行のバージョン管理に基づく分離レベル</span><span class="sxs-lookup"><span data-stu-id="1f03c-111">Row Versioning-based Isolation Levels in the Database Engine</span></span>](#Row_versioning)  
  
 [<span data-ttu-id="1f03c-112">インデックスのロックのカスタマイズ</span><span class="sxs-lookup"><span data-stu-id="1f03c-112">Customizing Locking for an Index</span></span>](#Customize)  
  
 [<span data-ttu-id="1f03c-113">トランザクションの詳細情報</span><span class="sxs-lookup"><span data-stu-id="1f03c-113">Advanced Transaction Information</span></span>](#Advanced)  
  
##  <a name="transaction-basics"></a><a name="Basics"></a> <span data-ttu-id="1f03c-114">トランザクションの基礎</span><span class="sxs-lookup"><span data-stu-id="1f03c-114">Transaction Basics</span></span>  

 <span data-ttu-id="1f03c-115">トランザクションは、論理的な 1 つの作業単位として実行される一連の操作です。</span><span class="sxs-lookup"><span data-stu-id="1f03c-115">A transaction is a sequence of operations performed as a single logical unit of work.</span></span> <span data-ttu-id="1f03c-116">論理的な 1 つの作業単位がトランザクションとして有効であるには、ACID と呼ばれる 4 つのプロパティ (原子性、一貫性、分離性、および持続性) を備えている必要があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-116">A logical unit of work must exhibit four properties, called the atomicity, consistency, isolation, and durability (ACID) properties, to qualify as a transaction.</span></span>  
  
 <span data-ttu-id="1f03c-117">原子性</span><span class="sxs-lookup"><span data-stu-id="1f03c-117">Atomicity</span></span>  
 <span data-ttu-id="1f03c-118">トランザクションは、分離できない 1 つの作業単位であり、そのデータ変更がすべて実行されるか、まったく実行されないかのどちらかである必要があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-118">A transaction must be an atomic unit of work; either all of its data modifications are performed, or none of them are performed.</span></span>  
  
 <span data-ttu-id="1f03c-119">一貫性</span><span class="sxs-lookup"><span data-stu-id="1f03c-119">Consistency</span></span>  
 <span data-ttu-id="1f03c-120">トランザクションの完了時に、すべてのデータが一貫した状態になければなりません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-120">When completed, a transaction must leave all data in a consistent state.</span></span> <span data-ttu-id="1f03c-121">リレーショナル データベースの場合、すべてのデータの整合性を維持するため、トランザクションの変更に対してすべてのルールが適用される必要があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-121">In a relational database, all rules must be applied to the transaction's modifications to maintain all data integrity.</span></span> <span data-ttu-id="1f03c-122">B ツリー インデックスや二重リンク リストなどのすべての内部データ構造は、トランザクションの終了時に正しくなければなりません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-122">All internal data structures, such as B-tree indexes or doubly-linked lists, must be correct at the end of the transaction.</span></span>  
  
 <span data-ttu-id="1f03c-123">分離:</span><span class="sxs-lookup"><span data-stu-id="1f03c-123">Isolation</span></span>  
 <span data-ttu-id="1f03c-124">同時実行トランザクションによって行われる変更は、他の同時実行トランザクションによって行われる変更と相互に独立している必要があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-124">Modifications made by concurrent transactions must be isolated from the modifications made by any other concurrent transactions.</span></span> <span data-ttu-id="1f03c-125">トランザクションは、他の同時実行トランザクションが変更する前の状態のデータを認識するか、2 番目のトランザクションが完了した後のデータを認識するかのどちらかであり、中間の状態は認識しません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-125">A transaction either recognizes data in the state it was in before another concurrent transaction modified it, or it recognizes the data after the second transaction has completed, but it does not recognize an intermediate state.</span></span> <span data-ttu-id="1f03c-126">これをシリアル化可能性と呼んでいます。最初のデータを再度読み込み、一連のトランザクションを実行しても、元のトランザクションを実行したときと同じ状態で終了できるからです。</span><span class="sxs-lookup"><span data-stu-id="1f03c-126">This is referred to as serializability because it results in the ability to reload the starting data and replay a series of transactions to end up with the data in the same state it was in after the original transactions were performed.</span></span>  
  
 <span data-ttu-id="1f03c-127">Durability</span><span class="sxs-lookup"><span data-stu-id="1f03c-127">Durability</span></span>  
 <span data-ttu-id="1f03c-128">完全持続性トランザクションの完了後、その結果がシステム内で持続されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-128">After a fully durable transaction has completed, its effects are permanently in place in the system.</span></span> <span data-ttu-id="1f03c-129">システム障害が発生しても、変更結果は持続されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-129">The modifications persist even in the event of a system failure.</span></span> [!INCLUDE[ssSQL14](../includes/sssql14-md.md)] <span data-ttu-id="1f03c-130">以降は、遅延持続性トランザクションに対応しています。</span><span class="sxs-lookup"><span data-stu-id="1f03c-130">and later enable delayed durable transactions.</span></span> <span data-ttu-id="1f03c-131">遅延持続性トランザクションのコミットは、トランザクション ログ レコードがディスクに対して永続化される前に行われます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-131">Delayed durable transactions commit before the transaction log record is persisted to disk.</span></span> <span data-ttu-id="1f03c-132">トランザクションの遅延持続性について詳しくは、[トランザクションの持続性](../relational-databases/logs/control-transaction-durability.md)に関するトピックをご覧ください。</span><span class="sxs-lookup"><span data-stu-id="1f03c-132">For more information on delayed transaction durability see the topic [Transaction Durability](../relational-databases/logs/control-transaction-durability.md).</span></span>  
  
 <span data-ttu-id="1f03c-133">SQL プログラマは、データの論理的な一貫性が確保されるように、トランザクションを開始および終了しなければなりません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-133">SQL programmers are responsible for starting and ending transactions at points that enforce the logical consistency of the data.</span></span> <span data-ttu-id="1f03c-134">プログラマは、組織のビジネス ルールに合わせて、データが一貫した状態に保たれるようにデータ修正の順序を定義する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-134">The programmer must define the sequence of data modifications that leave the data in a consistent state relative to the organization's business rules.</span></span> <span data-ttu-id="1f03c-135">これらの変更指示ステートメントは 1 つのトランザクションに含め、[!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)]がトランザクションの物理的な整合性を設定できるようにします。</span><span class="sxs-lookup"><span data-stu-id="1f03c-135">The programmer includes these modification statements in a single transaction so that the [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] can enforce the physical integrity of the transaction.</span></span>  
  
 <span data-ttu-id="1f03c-136">[!INCLUDE[ssDE](../includes/ssde-md.md)]のインスタンスなど、企業のデータベース システムは、各トランザクションの整合性を確保するメカニズムを用意する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-136">It is the responsibility of an enterprise database system, such as an instance of the [!INCLUDE[ssDE](../includes/ssde-md.md)], to provide mechanisms ensuring the physical integrity of each transaction.</span></span> <span data-ttu-id="1f03c-137">[!INCLUDE[ssDE](../includes/ssde-md.md)]は、次の機能を提供します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-137">The [!INCLUDE[ssDE](../includes/ssde-md.md)] provides:</span></span>  
  
-   <span data-ttu-id="1f03c-138">トランザクションの分離性を保持するロック機能。</span><span class="sxs-lookup"><span data-stu-id="1f03c-138">Locking facilities that preserve transaction isolation.</span></span>  
  
-   <span data-ttu-id="1f03c-139">トランザクションの持続性を設定するログ機能。</span><span class="sxs-lookup"><span data-stu-id="1f03c-139">Logging facilities ensure transaction durability.</span></span> <span data-ttu-id="1f03c-140">完全持続性トランザクションでは、ログ レコードがディスクに書き込まれた後で、トランザクションがコミットされます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-140">For fully durable transactions the log record is hardened to disk before the transactions commits.</span></span> <span data-ttu-id="1f03c-141">したがって、サーバー ハードウェア、オペレーティング システム、または[!INCLUDE[ssDE](../includes/ssde-md.md)]のインスタンス自体で障害が発生した場合でも、データベース エンジンのインスタンスは再起動時にトランザクション ログを使用して、中断したトランザクションをシステム障害が発生した時点まで自動的にロールバックします。</span><span class="sxs-lookup"><span data-stu-id="1f03c-141">Thus, even if the server hardware, operating system, or the instance of the [!INCLUDE[ssDE](../includes/ssde-md.md)] itself fails, the instance uses the transaction logs upon restart to automatically roll back any uncompleted transactions to the point of the system failure.</span></span> <span data-ttu-id="1f03c-142">遅延持続性トランザクションのコミットは、トランザクション ログ レコードがディスクに書き込まれる前に行われます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-142">Delayed durable transactions commit before the transaction log record is hardened to disk.</span></span> <span data-ttu-id="1f03c-143">ログ レコードがディスクに書き込まれる前にシステム障害が発生した場合、このようなトランザクションは失われる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-143">Such transactions may be lost if there is a system failure before the log record is hardened to disk.</span></span> <span data-ttu-id="1f03c-144">トランザクションの遅延持続性について詳しくは、[トランザクションの持続性](../relational-databases/logs/control-transaction-durability.md)に関するトピックをご覧ください。</span><span class="sxs-lookup"><span data-stu-id="1f03c-144">For more information on delayed transaction durability see the topic [Transaction Durability](../relational-databases/logs/control-transaction-durability.md).</span></span>  
  
-   <span data-ttu-id="1f03c-145">トランザクションの原子性と一貫性を設定するトランザクション管理機能。</span><span class="sxs-lookup"><span data-stu-id="1f03c-145">Transaction management features that enforce transaction atomicity and consistency.</span></span> <span data-ttu-id="1f03c-146">トランザクションは開始したら、正常に完了する (コミットされる) 必要があります。正常に完了しない場合は、トランザクションの開始後に加えた変更がすべて、[!INCLUDE[ssDE](../includes/ssde-md.md)]によって取り消されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-146">After a transaction has started, it must be successfully completed (committed), or the [!INCLUDE[ssDE](../includes/ssde-md.md)] undoes all of the data modifications made since the transaction started.</span></span> <span data-ttu-id="1f03c-147">データを変更前の状態に戻す操作であるため、これをトランザクションのロールバックといいます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-147">This operation is referred to as rolling back a transaction because it returns the data to the state it was prior to those changes.</span></span>  
  
### <a name="controlling-transactions"></a><span data-ttu-id="1f03c-148">トランザクションの制御</span><span class="sxs-lookup"><span data-stu-id="1f03c-148">Controlling Transactions</span></span>  

 <span data-ttu-id="1f03c-149">アプリケーションは、主にトランザクションの開始タイミングと終了タイミングを指定してトランザクションを制御します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-149">Applications control transactions mainly by specifying when a transaction starts and ends.</span></span> <span data-ttu-id="1f03c-150">これについては、[!INCLUDE[tsql](../includes/tsql-md.md)] ステートメントまたはデータベース アプリケーション プログラミング インターフェイス (API) 関数を使用して指定できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-150">This can be specified by using either [!INCLUDE[tsql](../includes/tsql-md.md)] statements or database application programming interface (API) functions.</span></span> <span data-ttu-id="1f03c-151">また、トランザクションが完了せずに終了した場合、その原因となったエラーがシステムによって正しく処理される必要があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-151">The system must also be able to correctly handle errors that terminate a transaction before it completes.</span></span> <span data-ttu-id="1f03c-152">詳細については、「 [transact-sql&#41;&#40;トランザクションステートメント](/sql/t-sql/language-elements/transactions-transact-sql)」、「 [ODBC でのトランザクション」](https://technet.microsoft.com/library/ms131281.aspx) 、および「 [SQL Server Native Client (OLEDB) のトランザクション](https://msdn.microsoft.com/library/ms130918.aspx)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1f03c-152">For more information, see [Transaction Statements &#40;Transact-SQL&#41;](/sql/t-sql/language-elements/transactions-transact-sql), [Transactions in ODBC](https://technet.microsoft.com/library/ms131281.aspx) and [Transactions in SQL Server Native Client (OLEDB)](https://msdn.microsoft.com/library/ms130918.aspx).</span></span>  
  
 <span data-ttu-id="1f03c-153">既定では、トランザクションは接続レベルで管理されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-153">By default, transactions are managed at the connection level.</span></span> <span data-ttu-id="1f03c-154">接続時にトランザクションが開始すると、その接続で実行されるすべての [!INCLUDE[tsql](../includes/tsql-md.md)] ステートメントが、トランザクションが終了するまでそのトランザクションの一部になります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-154">When a transaction is started on a connection, all [!INCLUDE[tsql](../includes/tsql-md.md)] statements executed on that connection are part of the transaction until the transaction ends.</span></span> <span data-ttu-id="1f03c-155">ただし、複数のアクティブな結果セット (MARS) セッションでは、[!INCLUDE[tsql](../includes/tsql-md.md)] の明示的または暗黙的なトランザクションは、バッチ レベルで管理されるバッチスコープのトランザクションになります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-155">However, under a multiple active result set (MARS) session, a [!INCLUDE[tsql](../includes/tsql-md.md)] explicit or implicit transaction becomes a batch-scoped transaction that is managed at the batch level.</span></span> <span data-ttu-id="1f03c-156">バッチの完了時にバッチスコープのトランザクションがコミットまたはロールバックされていない場合、[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] により、トランザクションは自動的にロールバックされます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-156">When the batch completes, if the batch-scoped transaction is not committed or rolled back, it is automatically rolled back by [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="1f03c-157">詳細については、 [SQL Server の「複数のアクティブな結果セット (MARS)](https://msdn.microsoft.com/library/ms345109(v=SQL.90).aspx)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1f03c-157">For more information, see [Multiple Active Result Sets (MARS) in SQL Server](https://msdn.microsoft.com/library/ms345109(v=SQL.90).aspx).</span></span>  
  
#### <a name="starting-transactions"></a><span data-ttu-id="1f03c-158">トランザクションの開始</span><span class="sxs-lookup"><span data-stu-id="1f03c-158">Starting Transactions</span></span>  

 <span data-ttu-id="1f03c-159">[!INCLUDE[tsql](../includes/tsql-md.md)]のインスタンスでは、API 関数や [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] ステートメントを使用して、明示的、自動コミット、または暗黙のいずれかのトランザクションとしてトランザクションを開始できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-159">Using API functions and [!INCLUDE[tsql](../includes/tsql-md.md)] statements, you can start transactions in an instance of the [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] as explicit, autocommit, or implicit transactions.</span></span>  
  
 <span data-ttu-id="1f03c-160">**明示的なトランザクション**</span><span class="sxs-lookup"><span data-stu-id="1f03c-160">**Explicit Transactions**</span></span>  
 <span data-ttu-id="1f03c-161">明示的なトランザクションとは、API 関数またはステートメント ([!INCLUDE[tsql](../includes/tsql-md.md)]BEGIN TRANSACTION、COMMIT TRANSACTION、COMMIT WORK、ROLLBACK TRANSACTION、または ROLLBACK WORK[!INCLUDE[tsql](../includes/tsql-md.md)]) の使用により、トランザクションの開始と終了を明示的に定義したものです。</span><span class="sxs-lookup"><span data-stu-id="1f03c-161">An explicit transaction is one in which you explicitly define both the start and end of the transaction through an API function or by issuing the [!INCLUDE[tsql](../includes/tsql-md.md)] BEGIN TRANSACTION, COMMIT TRANSACTION, COMMIT WORK, ROLLBACK TRANSACTION, or ROLLBACK WORK [!INCLUDE[tsql](../includes/tsql-md.md)] statements.</span></span> <span data-ttu-id="1f03c-162">トランザクションが終了すると、接続は明示的なトランザクションを開始する前のトランザクション モード、つまり暗黙のトランザクション モードまたは自動コミット モードに戻ります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-162">When the transaction ends, the connection returns to the transaction mode it was in before the explicit transaction was started, either implicit or autocommit mode.</span></span>  
  
 <span data-ttu-id="1f03c-163">明示的なトランザクションでは、次のステートメントを除くすべての [!INCLUDE[tsql](../includes/tsql-md.md)] ステートメントを使用できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-163">You can use all [!INCLUDE[tsql](../includes/tsql-md.md)] statements in an explicit transaction, except for the following statements:</span></span>  
  
||||  
|-|-|-|  
|<span data-ttu-id="1f03c-164">ALTER DATABASE</span><span class="sxs-lookup"><span data-stu-id="1f03c-164">ALTER DATABASE</span></span>|<span data-ttu-id="1f03c-165">CREATE DATABASE</span><span class="sxs-lookup"><span data-stu-id="1f03c-165">CREATE DATABASE</span></span>|<span data-ttu-id="1f03c-166">DROP FULLTEXT INDEX</span><span class="sxs-lookup"><span data-stu-id="1f03c-166">DROP FULLTEXT INDEX</span></span>|  
|<span data-ttu-id="1f03c-167">ALTER FULLTEXT CATALOG</span><span class="sxs-lookup"><span data-stu-id="1f03c-167">ALTER FULLTEXT CATALOG</span></span>|<span data-ttu-id="1f03c-168">CREATE FULLTEXT CATALOG</span><span class="sxs-lookup"><span data-stu-id="1f03c-168">CREATE FULLTEXT CATALOG</span></span>|<span data-ttu-id="1f03c-169">RECONFIGURE</span><span class="sxs-lookup"><span data-stu-id="1f03c-169">RECONFIGURE</span></span>|  
|<span data-ttu-id="1f03c-170">ALTER FULLTEXT INDEX</span><span class="sxs-lookup"><span data-stu-id="1f03c-170">ALTER FULLTEXT INDEX</span></span>|<span data-ttu-id="1f03c-171">CREATE FULLTEXT INDEX</span><span class="sxs-lookup"><span data-stu-id="1f03c-171">CREATE FULLTEXT INDEX</span></span>|<span data-ttu-id="1f03c-172">RESTORE</span><span class="sxs-lookup"><span data-stu-id="1f03c-172">RESTORE</span></span>|  
|<span data-ttu-id="1f03c-173">BACKUP</span><span class="sxs-lookup"><span data-stu-id="1f03c-173">BACKUP</span></span>|<span data-ttu-id="1f03c-174">DROP DATABASE</span><span class="sxs-lookup"><span data-stu-id="1f03c-174">DROP DATABASE</span></span>|<span data-ttu-id="1f03c-175">フルテキスト システム ストアド プロシージャ</span><span class="sxs-lookup"><span data-stu-id="1f03c-175">Full-text system stored procedures</span></span>|  
|<span data-ttu-id="1f03c-176">CREATE DATABASE</span><span class="sxs-lookup"><span data-stu-id="1f03c-176">CREATE DATABASE</span></span>|<span data-ttu-id="1f03c-177">DROP FULLTEXT CATALOG</span><span class="sxs-lookup"><span data-stu-id="1f03c-177">DROP FULLTEXT CATALOG</span></span>|<span data-ttu-id="1f03c-178">明示的なトランザクションでも暗黙のトランザクションでも、データベース オプションを設定する sp_dboption および master データベースを変更するシステム プロシージャは使用できません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-178">sp_dboption to set database options or any system procedure that modifies the master database inside explicit or implicit transactions.</span></span>|  
  
> [!NOTE]  
>  <span data-ttu-id="1f03c-179">UPDATE STATISTICS は、明示的なトランザクションで使用できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-179">UPDATE STATISTICS can be used inside an explicit transaction.</span></span> <span data-ttu-id="1f03c-180">ただし、UPDATE STATISTICS は、このステートメントを含むトランザクションとは別にコミットされ、ロールバックすることはできません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-180">However, UPDATE STATISTICS commits independently of the enclosing transaction and cannot be rolled back.</span></span>  
  
 <span data-ttu-id="1f03c-181">**自動コミット トランザクション**</span><span class="sxs-lookup"><span data-stu-id="1f03c-181">**Autocommit Transactions**</span></span>  
 <span data-ttu-id="1f03c-182">自動コミット モードは、SQL Server データベース エンジンの既定のトランザクション管理モードです。</span><span class="sxs-lookup"><span data-stu-id="1f03c-182">Autocommit mode is the default transaction management mode of the SQL Server Database Engine.</span></span> <span data-ttu-id="1f03c-183">すべての Transact-SQL ステートメントは完了時にコミットされるか、ロールバックされます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-183">Every Transact-SQL statement is committed or rolled back when it completes.</span></span> <span data-ttu-id="1f03c-184">ステートメントが正常に完了した場合はコミットされ、エラーが検出された場合はロールバックされます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-184">If a statement completes successfully, it is committed; if it encounters any error, it is rolled back.</span></span> <span data-ttu-id="1f03c-185">この既定のモードが明示的トランザクションまたは暗黙のトランザクションでオーバーライドされていなければ、データベース エンジンのインスタンスへの接続は自動コミット モードで動作します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-185">A connection to an instance of the Database Engine operates in autocommit mode whenever this default mode has not been overridden by either explicit or implicit transactions.</span></span> <span data-ttu-id="1f03c-186">ADO、OLE DB、ODBC、および DB-Library の既定モードも自動コミット モードです。</span><span class="sxs-lookup"><span data-stu-id="1f03c-186">Autocommit mode is also the default mode for ADO, OLE DB, ODBC, and DB-Library.</span></span>  
  
 <span data-ttu-id="1f03c-187">**暗黙のトランザクション**</span><span class="sxs-lookup"><span data-stu-id="1f03c-187">**Implicit Transactions**</span></span>  
 <span data-ttu-id="1f03c-188">接続が暗黙のトランザクション モードで動作している場合、データベース エンジンのインスタンスでは、現在のトランザクションがコミットされるかロールバックされた後に新しいトランザクションが自動的に開始されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-188">When a connection is operating in implicit transaction mode, the instance of the Database Engine automatically starts a new transaction after the current transaction is committed or rolled back.</span></span> <span data-ttu-id="1f03c-189">トランザクションの開始を指定する必要はありません。各トランザクションをコミットするかロールバックするだけです。</span><span class="sxs-lookup"><span data-stu-id="1f03c-189">You do nothing to delineate the start of a transaction; you only commit or roll back each transaction.</span></span> <span data-ttu-id="1f03c-190">暗黙のトランザクション モードの場合、トランザクションが連鎖して生成されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-190">Implicit transaction mode generates a continuous chain of transactions.</span></span> <span data-ttu-id="1f03c-191">暗黙のトランザクション モードは、API 関数または [!INCLUDE[tsql](../includes/tsql-md.md)] SET IMPLICIT_TRANSACTIONS ON ステートメントのいずれかを使用して設定します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-191">Set implicit transaction mode on through either an API function or the [!INCLUDE[tsql](../includes/tsql-md.md)] SET IMPLICIT_TRANSACTIONS ON statement.</span></span>  
  
 <span data-ttu-id="1f03c-192">接続に対して暗黙のトランザクション モードをオンに設定した後、[!INCLUDE[ssDE](../includes/ssde-md.md)]のインスタンスで次のステートメントのうちのどれかが最初に実行されると、トランザクションが自動的に開始されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-192">After implicit transaction mode has been set on for a connection, the instance of the [!INCLUDE[ssDE](../includes/ssde-md.md)] automatically starts a transaction when it first executes any of these statements:</span></span>  
  
||||  
|-|-|-|  
|<span data-ttu-id="1f03c-193">ALTER TABLE</span><span class="sxs-lookup"><span data-stu-id="1f03c-193">ALTER TABLE</span></span>|<span data-ttu-id="1f03c-194">FETCH</span><span class="sxs-lookup"><span data-stu-id="1f03c-194">FETCH</span></span>|<span data-ttu-id="1f03c-195">REVOKE</span><span class="sxs-lookup"><span data-stu-id="1f03c-195">REVOKE</span></span>|  
|<span data-ttu-id="1f03c-196">CREATE</span><span class="sxs-lookup"><span data-stu-id="1f03c-196">CREATE</span></span>|<span data-ttu-id="1f03c-197">GRANT</span><span class="sxs-lookup"><span data-stu-id="1f03c-197">GRANT</span></span>|<span data-ttu-id="1f03c-198">SELECT</span><span class="sxs-lookup"><span data-stu-id="1f03c-198">SELECT</span></span>|  
|<span data-ttu-id="1f03c-199">DELETE</span><span class="sxs-lookup"><span data-stu-id="1f03c-199">DELETE</span></span>|<span data-ttu-id="1f03c-200">INSERT</span><span class="sxs-lookup"><span data-stu-id="1f03c-200">INSERT</span></span>|<span data-ttu-id="1f03c-201">TRUNCATE TABLE</span><span class="sxs-lookup"><span data-stu-id="1f03c-201">TRUNCATE TABLE</span></span>|  
|<span data-ttu-id="1f03c-202">DROP</span><span class="sxs-lookup"><span data-stu-id="1f03c-202">DROP</span></span>|<span data-ttu-id="1f03c-203">OPEN</span><span class="sxs-lookup"><span data-stu-id="1f03c-203">OPEN</span></span>|<span data-ttu-id="1f03c-204">UPDATE</span><span class="sxs-lookup"><span data-stu-id="1f03c-204">UPDATE</span></span>|  
  
 <span data-ttu-id="1f03c-205">**バッチスコープのトランザクション**</span><span class="sxs-lookup"><span data-stu-id="1f03c-205">**Batch-scoped Transactions**</span></span>  
 <span data-ttu-id="1f03c-206">複数のアクティブな結果セット (MARS) にのみ該当します。MARS セッションで開始された [!INCLUDE[tsql](../includes/tsql-md.md)] の明示的または暗黙的なトランザクションは、バッチスコープのトランザクションになります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-206">Applicable only to multiple active result sets (MARS), a [!INCLUDE[tsql](../includes/tsql-md.md)] explicit or implicit transaction that starts under a MARS session becomes a batch-scoped transaction.</span></span> <span data-ttu-id="1f03c-207">バッチの完了時にコミットまたはロールバックされていないバッチスコープのトランザクションは、[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] により自動的にロールバックされます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-207">A batch-scoped transaction that is not committed or rolled back when a batch completes is automatically rolled back by [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span></span>  
  
 <span data-ttu-id="1f03c-208">**分散トランザクション**</span><span class="sxs-lookup"><span data-stu-id="1f03c-208">**Distributed Transactions**</span></span>  
 <span data-ttu-id="1f03c-209">分散トランザクションは、リソース マネージャーと呼ばれる複数のサーバーに展開されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-209">Distributed transactions span two or more servers known as resource managers.</span></span> <span data-ttu-id="1f03c-210">トランザクションの管理はリソース マネージャー間で、トランザクション マネージャーと呼ばれるサーバー コンポーネントが調整する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-210">The management of the transaction must be coordinated between the resource managers by a server component called a transaction manager.</span></span> <span data-ttu-id="1f03c-211">[!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)]分散トランザクション コーディネーター (MS DTC) などのトランザクション マネージャー、または分散トランザクション処理に関する Open Group XA 仕様をサポートするその他のトランザクション マネージャーによって調整される分散トランザクションでは、[!INCLUDE[msCoName](../includes/msconame-md.md)]データベース エンジンをリソース マネージャーとして操作できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-211">Each instance of the [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] can operate as a resource manager in distributed transactions coordinated by transaction managers, such as [!INCLUDE[msCoName](../includes/msconame-md.md)] Distributed Transaction Coordinator (MS DTC), or other transaction managers that support the Open Group XA specification for distributed transaction processing.</span></span> <span data-ttu-id="1f03c-212">詳細については、MS DTC のドキュメントを参照してください。</span><span class="sxs-lookup"><span data-stu-id="1f03c-212">For more information, see the MS DTC documentation.</span></span>  
  
 <span data-ttu-id="1f03c-213">複数のデータベースにまたがる 1 つの[!INCLUDE[ssDE](../includes/ssde-md.md)]内のトランザクションは実質的には分散トランザクションです。</span><span class="sxs-lookup"><span data-stu-id="1f03c-213">A transaction within a single instance of the [!INCLUDE[ssDE](../includes/ssde-md.md)] that spans two or more databases is actually a distributed transaction.</span></span> <span data-ttu-id="1f03c-214">ただし、SQL Server インスタンスは分散トランザクションを内部で処理するため、ユーザーにはローカル トランザクションとして動作しているように見えます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-214">The instance manages the distributed transaction internally; to the user, it operates as a local transaction.</span></span>  
  
 <span data-ttu-id="1f03c-215">アプリケーションでは、分散トランザクションはローカル トランザクションとほぼ同様に管理されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-215">At the application, a distributed transaction is managed much the same as a local transaction.</span></span> <span data-ttu-id="1f03c-216">トランザクションの終了時に、アプリケーションがトランザクションのコミットまたはロールバックを要求します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-216">At the end of the transaction, the application requests the transaction to be either committed or rolled back.</span></span> <span data-ttu-id="1f03c-217">ただし、トランザクション マネージャーが分散コミットを別の方法で管理することによって、ネットワーク障害により一部のリソース マネージャーがトランザクションを正常にコミットし、その一方で他のリソース マネージャーがトランザクションをロールバックするという危険性を最小限に抑える必要があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-217">A distributed commit must be managed differently by the transaction manager to minimize the risk that a network failure may result in some resource managers successfully committing while others roll back the transaction.</span></span> <span data-ttu-id="1f03c-218">このため、コミット処理を準備フェーズとコミット フェーズの 2 フェーズで管理します。これを 2PC (2 フェーズ コミット) と呼びます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-218">This is achieved by managing the commit process in two phases (the prepare phase and the commit phase), which is known as a two-phase commit (2PC).</span></span>  
  
 <span data-ttu-id="1f03c-219">準備フェーズ</span><span class="sxs-lookup"><span data-stu-id="1f03c-219">Prepare phase</span></span>  
 <span data-ttu-id="1f03c-220">トランザクション マネージャーはコミット要求を受け取ると、そのトランザクションに関連するすべてのリソース マネージャーに準備コマンドを送ります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-220">When the transaction manager receives a commit request, it sends a prepare command to all of the resource managers involved in the transaction.</span></span> <span data-ttu-id="1f03c-221">各リソース マネージャーは、トランザクションを持続的にするために必要な処理をすべて実行し、そのトランザクションのログ イメージを含むすべてのバッファーをディスクにフラッシュします。</span><span class="sxs-lookup"><span data-stu-id="1f03c-221">Each resource manager then does everything required to make the transaction durable, and all buffers holding log images for the transaction are flushed to disk.</span></span> <span data-ttu-id="1f03c-222">リソース マネージャーの準備フェーズが完了すると、トランザクション マネージャーに準備の成否が通知されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-222">As each resource manager completes the prepare phase, it returns success or failure of the prepare to the transaction manager.</span></span> [!INCLUDE[ssSQL14](../includes/sssql14-md.md)] <span data-ttu-id="1f03c-223">では、トランザクションの遅延持続性が導入されました。</span><span class="sxs-lookup"><span data-stu-id="1f03c-223">introduced delayed transaction durability.</span></span> <span data-ttu-id="1f03c-224">遅延持続性トランザクションのコミットは、トランザクションのログ イメージがディスクにフラッシュされる前に行われます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-224">Delayed durable transactions commit before log images for the transaction are flushed to disk.</span></span> <span data-ttu-id="1f03c-225">トランザクションの遅延持続性について詳しくは、[トランザクションの持続性](../relational-databases/logs/control-transaction-durability.md)に関するトピックをご覧ください。</span><span class="sxs-lookup"><span data-stu-id="1f03c-225">For more information on delayed transaction durability see the topic [Transaction Durability](../relational-databases/logs/control-transaction-durability.md).</span></span>  
  
 <span data-ttu-id="1f03c-226">コミット フェーズ</span><span class="sxs-lookup"><span data-stu-id="1f03c-226">Commit phase</span></span>  
 <span data-ttu-id="1f03c-227">トランザクション マネージャーは、すべてのリソース マネージャーから準備の正常完了通知を受け取ると、リソース マネージャーにコミット コマンドを送ります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-227">If the transaction manager receives successful prepares from all of the resource managers, it sends commit commands to each resource manager.</span></span> <span data-ttu-id="1f03c-228">これにより、リソース マネージャーはコミットを完了できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-228">The resource managers can then complete the commit.</span></span> <span data-ttu-id="1f03c-229">すべてのリソース マネージャーがコミットの正常完了を報告した場合、トランザクション マネージャーは、アプリケーションに成功通知を送ります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-229">If all of the resource managers report a successful commit, the transaction manager then sends a success notification to the application.</span></span> <span data-ttu-id="1f03c-230">準備できなかったことを報告するリソース マネージャーがあった場合、トランザクション マネージャーはすべてのリソース マネージャーにロールバック コマンドを送り、アプリケーションにコミットできなかったことを報告します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-230">If any resource manager reported a failure to prepare, the transaction manager sends a rollback command to each resource manager and indicates the failure of the commit to the application.</span></span>  
  
 [!INCLUDE[ssDE](../includes/ssde-md.md)] <span data-ttu-id="1f03c-231">アプリケーションは分散トランザクションの管理に [!INCLUDE[tsql](../includes/tsql-md.md)] またはデータベース API のどちらも使用できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-231">applications can manage distributed transactions either through [!INCLUDE[tsql](../includes/tsql-md.md)] or the database API.</span></span> <span data-ttu-id="1f03c-232">詳細については、「[BEGIN DISTRIBUTED TRANSACTION &#40;Transact-SQL&#41;](/sql/t-sql/language-elements/begin-distributed-transaction-transact-sql)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1f03c-232">For more information, see [BEGIN DISTRIBUTED TRANSACTION &#40;Transact-SQL&#41;](/sql/t-sql/language-elements/begin-distributed-transaction-transact-sql).</span></span>  
  
#### <a name="ending-transactions"></a><span data-ttu-id="1f03c-233">トランザクションの終了</span><span class="sxs-lookup"><span data-stu-id="1f03c-233">Ending Transactions</span></span>  

 <span data-ttu-id="1f03c-234">トランザクションは、COMMIT ステートメント、ROLLBACK ステートメント、または対応する API 関数を使用して終了できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-234">You can end transactions with either a COMMIT or ROLLBACK statement, or through a corresponding API function.</span></span>  
  
 <span data-ttu-id="1f03c-235">COMMIT</span><span class="sxs-lookup"><span data-stu-id="1f03c-235">COMMIT</span></span>  
 <span data-ttu-id="1f03c-236">トランザクションが正常に完了した場合、そのトランザクションをコミットします。</span><span class="sxs-lookup"><span data-stu-id="1f03c-236">If a transaction is successful, commit it.</span></span> <span data-ttu-id="1f03c-237">COMMIT ステートメントは、トランザクションのすべての変更をデータベースの一部として組み込みます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-237">A COMMIT statement guarantees all of the transaction's modifications are made a permanent part of the database.</span></span> <span data-ttu-id="1f03c-238">また、COMMIT により、トランザクションで使用されていたロックなどのリソースが解放されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-238">A COMMIT also frees resources, such as locks, used by the transaction.</span></span>  
  
 <span data-ttu-id="1f03c-239">ROLLBACK</span><span class="sxs-lookup"><span data-stu-id="1f03c-239">ROLLBACK</span></span>  
 <span data-ttu-id="1f03c-240">トランザクションでエラーが発生した場合やユーザーがトランザクションを取り消す場合は、トランザクションをロールバックします。</span><span class="sxs-lookup"><span data-stu-id="1f03c-240">If an error occurs in a transaction, or if the user decides to cancel the transaction, then roll the transaction back.</span></span> <span data-ttu-id="1f03c-241">ROLLBACK ステートメントは、データをトランザクションの開始時点の状態に戻すことにより、トランザクションで行われた変更をすべて元に戻します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-241">A ROLLBACK statement backs out all modifications made in the transaction by returning the data to the state it was in at the start of the transaction.</span></span> <span data-ttu-id="1f03c-242">また、ROLLBACK により、トランザクションで保持されていたリソースが解放されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-242">A ROLLBACK also frees resources held by the transaction.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="1f03c-243">複数のアクティブな結果セット (MARS) をサポートできる接続では、保留中の実行要求がある間は、API 関数を使用して開始された明示的なトランザクションをコミットできません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-243">Under connections enabled to support multiple active result sets (MARS), an explicit transaction started through an API function cannot be committed while there are pending requests for execution.</span></span> <span data-ttu-id="1f03c-244">実行中の未処理の操作があるときに、このようなトランザクションをコミットしようとするとエラーが発生します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-244">Any attempt to commit this type of  transaction while there are outstanding operations running will result in an error.</span></span>  
  
#### <a name="errors-during-transaction-processing"></a><span data-ttu-id="1f03c-245">トランザクション処理中のエラー</span><span class="sxs-lookup"><span data-stu-id="1f03c-245">Errors During Transaction Processing</span></span>  

 <span data-ttu-id="1f03c-246">エラーによりトランザクションを正常に完了できない場合、[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] によってトランザクションが自動的にロールバックされ、そのトランザクションで保持されていたすべてのリソースが解放されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-246">If an error prevents the successful completion of a transaction, [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] automatically rolls back the transaction and frees all resources held by the transaction.</span></span> <span data-ttu-id="1f03c-247">[!INCLUDE[ssDE](../includes/ssde-md.md)]のインスタンスへのクライアントのネットワーク接続が切断された場合、ネットワークからインスタンスにこの切断が通知されると、その接続に対する未処理のトランザクションがすべてロールバックされます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-247">If the client's network connection to an instance of the [!INCLUDE[ssDE](../includes/ssde-md.md)] is broken, any outstanding transactions for the connection are rolled back when the network notifies the instance of the break.</span></span> <span data-ttu-id="1f03c-248">クライアント アプリケーションが失敗した場合、またはクライアント コンピューターがダウンするか再起動される場合も、接続が切断されます。[!INCLUDE[ssDE](../includes/ssde-md.md)]のインスタンスでは、ネットワークからこの切断が通知されると、未処理の接続がすべてロールバックされます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-248">If the client application fails or if the client computer goes down or is restarted, this also breaks the connection, and the instance of the [!INCLUDE[ssDE](../includes/ssde-md.md)] rolls back any outstanding connections when the network notifies it of the break.</span></span> <span data-ttu-id="1f03c-249">クライアントがアプリケーションからログオフした場合、未処理のトランザクションはすべてロールバックされます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-249">If the client logs off the application, any outstanding transactions are rolled back.</span></span>  
  
 <span data-ttu-id="1f03c-250">バッチでランタイム ステートメント エラー (制約違反など) が発生した場合、[!INCLUDE[ssDE](../includes/ssde-md.md)]の既定の動作として、エラーの原因となったステートメントだけがロールバックされます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-250">If a run-time statement error (such as a constraint violation) occurs in a batch, the default behavior in the [!INCLUDE[ssDE](../includes/ssde-md.md)] is to roll back only the statement that generated the error.</span></span> <span data-ttu-id="1f03c-251">この動作を変更するには、SET XACT_ABORT ステートメントを使用します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-251">You can change this behavior using the SET XACT_ABORT statement.</span></span> <span data-ttu-id="1f03c-252">SET XACT_ABORT ON の実行後、任意のランタイム ステートメント エラーにより、現在のトランザクションが自動的にロールバックされます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-252">After SET XACT_ABORT ON is executed, any run-time statement error causes an automatic rollback of the current transaction.</span></span> <span data-ttu-id="1f03c-253">構文エラーなどのコンパイル エラーは、SET XACT_ABORT の影響を受けません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-253">Compile errors, such as syntax errors, are not affected by SET XACT_ABORT.</span></span> <span data-ttu-id="1f03c-254">詳しくは、「[SET XACT_ABORT &#40;Transact-SQL&#41;](/sql/t-sql/statements/set-xact-abort-transact-sql)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="1f03c-254">For more information, see [SET XACT_ABORT &#40;Transact-SQL&#41;](/sql/t-sql/statements/set-xact-abort-transact-sql).</span></span>  
  
 <span data-ttu-id="1f03c-255">エラーが発生した場合は、修正措置 (COMMIT または ROLLBACK) をアプリケーション コードに含める必要があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-255">When errors occur, corrective action (COMMIT or ROLLBACK) should be included in application code.</span></span> <span data-ttu-id="1f03c-256">トランザクション内のエラーなど、エラーを処理するための効果的なツールとし [!INCLUDE[tsql](../includes/tsql-md.md)] て、CATCH コンストラクト。</span><span class="sxs-lookup"><span data-stu-id="1f03c-256">One effective tool for handling errors, including those in transactions, is the [!INCLUDE[tsql](../includes/tsql-md.md)] TRY...CATCH construct.</span></span> <span data-ttu-id="1f03c-257">トランザクションを含む例について詳しくは、「[TRY...CATCH &#40;Transact-SQL&#41;](/sql/t-sql/language-elements/try-catch-transact-sql)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="1f03c-257">For more information with examples that include transactions, see [TRY...CATCH &#40;Transact-SQL&#41;](/sql/t-sql/language-elements/try-catch-transact-sql).</span></span> <span data-ttu-id="1f03c-258">以降では [!INCLUDE[ssSQL11](../includes/sssql11-md.md)] 、THROW ステートメントを使用して例外を発生させ、実行を try...CATCH コンストラクト。</span><span class="sxs-lookup"><span data-stu-id="1f03c-258">Beginning with [!INCLUDE[ssSQL11](../includes/sssql11-md.md)], you can use the THROW statement to raise an exception and transfers execution to a CATCH block of a TRY...CATCH construct.</span></span> <span data-ttu-id="1f03c-259">詳しくは、「[THROW &#40;Transact-SQL&#41;](/sql/t-sql/language-elements/throw-transact-sql)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="1f03c-259">For more information, see [THROW &#40;Transact-SQL&#41;](/sql/t-sql/language-elements/throw-transact-sql).</span></span>  
  
##### <a name="compile-and-run-time-errors-in-autocommit-mode"></a><span data-ttu-id="1f03c-260">自動コミット モードでのコンパイル エラーと実行時エラー</span><span class="sxs-lookup"><span data-stu-id="1f03c-260">Compile and Run-time Errors in Autocommit mode</span></span>  

 <span data-ttu-id="1f03c-261">自動コミット モードの場合、[!INCLUDE[ssDE](../includes/ssde-md.md)]のインスタンスが 1 つの SQL ステートメントだけでなく、バッチ全体をロールバックしたように見える場合があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-261">In autocommit mode, it sometimes appears as if an instance of the [!INCLUDE[ssDE](../includes/ssde-md.md)] has rolled back an entire batch instead of just one SQL statement.</span></span> <span data-ttu-id="1f03c-262">これは、検出されたエラーが実行時エラーではなくコンパイル エラーの場合に発生します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-262">This happens if the error encountered is a compile error, not a run-time error.</span></span> <span data-ttu-id="1f03c-263">コンパイル エラーが起きると、[!INCLUDE[ssDE](../includes/ssde-md.md)]の実行プランが構築できず、バッチ内のどの処理も実行されません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-263">A compile error prevents the [!INCLUDE[ssDE](../includes/ssde-md.md)] from building an execution plan, so nothing in the batch is executed.</span></span> <span data-ttu-id="1f03c-264">エラーを生成したステートメントよりも前にあるすべてのステートメントがロールバックされたように見えますが、エラーによりバッチ内のどのステートメントも実行されませんでした。</span><span class="sxs-lookup"><span data-stu-id="1f03c-264">Although it appears that all of the statements before the one generating the error were rolled back, the error prevented anything in the batch from being executed.</span></span> <span data-ttu-id="1f03c-265">次の例では、3 番目のバッチ内のどの `INSERT` ステートメントも、コンパイル エラーにより実行されません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-265">In the following example, none of the `INSERT` statements in the third batch are executed because of a compile error.</span></span> <span data-ttu-id="1f03c-266">最初の 2 つの `INSERT` ステートメントが実行されないので、ロールバックされたように見えます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-266">It appears that the first two `INSERT` statements are rolled back when they are never executed.</span></span>  
  
```sql
CREATE TABLE TestBatch (Cola INT PRIMARY KEY, Colb CHAR(3));  
GO  
INSERT INTO TestBatch VALUES (1, 'aaa');  
INSERT INTO TestBatch VALUES (2, 'bbb');  
INSERT INTO TestBatch VALUSE (3, 'ccc');  -- Syntax error.  
GO  
SELECT * FROM TestBatch;  -- Returns no rows.  
GO  
```  
  
 <span data-ttu-id="1f03c-267">次の例では、3 番目の `INSERT` ステートメントによって、主キーが重複するという実行時エラーが生成されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-267">In the following example, the third `INSERT` statement generates a run-time duplicate primary key error.</span></span> <span data-ttu-id="1f03c-268">最初の 2 つの `INSERT` ステートメントは正常に完了しコミットされるので、実行時エラーの生成後も有効です。</span><span class="sxs-lookup"><span data-stu-id="1f03c-268">The first two `INSERT` statements are successful and committed, so they remain after the run-time error.</span></span>  
  
```sql  
CREATE TABLE TestBatch (Cola INT PRIMARY KEY, Colb CHAR(3));  
GO  
INSERT INTO TestBatch VALUES (1, 'aaa');  
INSERT INTO TestBatch VALUES (2, 'bbb');  
INSERT INTO TestBatch VALUES (1, 'ccc');  -- Duplicate key error.  
GO  
SELECT * FROM TestBatch;  -- Returns rows 1 and 2.  
GO  
```  
  
 <span data-ttu-id="1f03c-269">[!INCLUDE[ssDE](../includes/ssde-md.md)]では、名前の遅延解決を採用しています。つまり、オブジェクト名は実行時まで解決されません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-269">The [!INCLUDE[ssDE](../includes/ssde-md.md)] uses deferred name resolution, in which object names are not resolved until execution time.</span></span> <span data-ttu-id="1f03c-270">次の例では、最初の 2 つの `INSERT` ステートメントは正常に実行されてコミットされ、3 番目の `TestBatch` ステートメントで存在しないテーブルが参照され、実行時エラーになった後も、最初の 2 行は `INSERT` テーブル内に残ります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-270">In the following example, the first two `INSERT` statements are executed and committed, and those two rows remain in the `TestBatch` table after the third `INSERT` statement generates a run-time error by referring to a table that does not exist.</span></span>  
  
```sql
CREATE TABLE TestBatch (Cola INT PRIMARY KEY, Colb CHAR(3));  
GO  
INSERT INTO TestBatch VALUES (1, 'aaa');  
INSERT INTO TestBatch VALUES (2, 'bbb');  
INSERT INTO TestBch VALUES (3, 'ccc');  -- Table name error.  
GO  
SELECT * FROM TestBatch;  -- Returns rows 1 and 2.  
GO  
```  
  
 <span data-ttu-id="1f03c-271">[このガイドの [](#Top) ![トップに戻る] リンクで使用される矢印アイコン](media/uparrow16x16.gif "[トップに戻る] リンクで使用される矢印アイコン")</span><span class="sxs-lookup"><span data-stu-id="1f03c-271">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
##  <a name="locking-and-row-versioning-basics"></a><a name="Lock_Basics"></a> <span data-ttu-id="1f03c-272">ロックおよび行のバージョン管理の基礎</span><span class="sxs-lookup"><span data-stu-id="1f03c-272">Locking and Row Versioning Basics</span></span>  

 <span data-ttu-id="1f03c-273">[!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)]では、複数のユーザーが同時にアクセスしたときにトランザクションの整合性を保証し、データベースの一貫性を保つため、次のメカニズムを使用します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-273">The [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] uses the following mechanisms to ensure the integrity of transactions and maintain the consistency of databases when multiple users are accessing data at the same time:</span></span>  
  
-   <span data-ttu-id="1f03c-274">ロック</span><span class="sxs-lookup"><span data-stu-id="1f03c-274">Locking</span></span>  
  
     <span data-ttu-id="1f03c-275">トランザクションの要求があるたびに、そのトランザクションが依存する行、ページ、テーブルなどの各種リソースにロックがかかります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-275">Each transaction requests locks of different types on the resources, such as rows, pages, or tables, on which the transaction is dependent.</span></span> <span data-ttu-id="1f03c-276">ロックをかけると、ロックを要求したトランザクションにとって問題になるようなリソースの変更が行われないように、他のトランザクションがブロックされます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-276">The locks block other transactions from modifying the resources in a way that would cause problems for the transaction requesting the lock.</span></span> <span data-ttu-id="1f03c-277">各トランザクションは、ロックしたリソースに対する依存関係がなくなったときにロックを解放します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-277">Each transaction frees its locks when it no longer has a dependency on the locked resources.</span></span>  
  
-   <span data-ttu-id="1f03c-278">行のバージョン管理</span><span class="sxs-lookup"><span data-stu-id="1f03c-278">Row versioning</span></span>  
  
     <span data-ttu-id="1f03c-279">行のバージョン管理に基づく分離レベルが有効になっている場合、変更されたそれぞれの行のバージョンが[!INCLUDE[ssDE](../includes/ssde-md.md)]によって管理されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-279">When a row versioning-based isolation level is enabled, the [!INCLUDE[ssDE](../includes/ssde-md.md)] maintains versions of each row that is modified.</span></span> <span data-ttu-id="1f03c-280">すべての読み取りをロックで保護するのではなく、トランザクションで使用する行のバージョンを使い分けて、トランザクションまたはクエリの開始時点の状態のデータを参照できるようにすることをアプリケーションで指定できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-280">Applications can specify that a transaction use the row versions to view data as it existed at the start of the transaction or query instead of protecting all reads with locks.</span></span> <span data-ttu-id="1f03c-281">行のバージョン管理を使用することで、読み取り操作が原因で他のトランザクションがブロックされる可能性が大幅に減少します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-281">By using row versioning, the chance that a read operation will block other transactions is greatly reduced.</span></span>  
  
 <span data-ttu-id="1f03c-282">ロックおよび行のバージョン管理を実装することで、ユーザーがコミット前のデータを読み取ったり、複数のユーザーが同時に同一のデータを変更したりする危険性を回避できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-282">Locking and row versioning prevent users from reading uncommitted data and prevent multiple users from attempting to change the same data at the same time.</span></span> <span data-ttu-id="1f03c-283">ロックおよび行のバージョン管理を使用しなければ、クエリを実行してもデータベース内のコミット前のデータが返されて、予期しない結果になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-283">Without locking or row versioning, queries executed against that data could produce unexpected results by returning data that has not yet been committed in the database.</span></span>  
  
 <span data-ttu-id="1f03c-284">アプリケーション側でトランザクション分離レベルを選択して、トランザクションを他のトランザクションによる変更から保護するレベルを定義できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-284">Applications can choose transaction isolation levels, which define the level of protection for the transaction from modifications made by other transactions.</span></span> <span data-ttu-id="1f03c-285">個別の [!INCLUDE[tsql](../includes/tsql-md.md)] ステートメントに対してテーブルレベルのヒントを指定し、アプリケーションの要件に合わせて動作を細かく調整することもできます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-285">Table-level hints can be specified for individual [!INCLUDE[tsql](../includes/tsql-md.md)] statements to further tailor behavior to fit the requirements of the application.</span></span>  
  
### <a name="managing-concurrent-data-access"></a><span data-ttu-id="1f03c-286">同時実行データ アクセスの管理</span><span class="sxs-lookup"><span data-stu-id="1f03c-286">Managing Concurrent Data Access</span></span>  

 <span data-ttu-id="1f03c-287">ユーザーが同じリソースに同時にアクセスすることを、リソースへのアクセスを同時実行しているといいます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-287">Users who access a resource at the same time are said to be accessing the resource concurrently.</span></span> <span data-ttu-id="1f03c-288">同時実行データ アクセスには、他のユーザーが現在使用しているリソースを複数のユーザーが変更しようとしたときの悪影響を回避するためのメカニズムが必要です。</span><span class="sxs-lookup"><span data-stu-id="1f03c-288">Concurrent data access requires mechanisms to prevent adverse effects when multiple users try to modify resources that other users are actively using.</span></span>  
  
#### <a name="concurrency-effects"></a><span data-ttu-id="1f03c-289">コンカレンシーの影響</span><span class="sxs-lookup"><span data-stu-id="1f03c-289">Concurrency Effects</span></span>  

 <span data-ttu-id="1f03c-290">あるユーザーがデータを変更すると、同じデータを同時に読み取ったり変更している他のユーザーに影響します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-290">Users modifying data can affect other users who are reading or modifying the same data at the same time.</span></span> <span data-ttu-id="1f03c-291">このようなユーザーを、データに同時アクセスしているユーザーと呼びます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-291">These users are said to be accessing the data concurrently.</span></span> <span data-ttu-id="1f03c-292">データ ストレージ システムでコンカレンシーが制御されていない場合は、次のような副作用が生じることがあります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-292">If a data storage system has no concurrency control, users could see the following side effects:</span></span>  
  
-   <span data-ttu-id="1f03c-293">更新データの喪失</span><span class="sxs-lookup"><span data-stu-id="1f03c-293">Lost updates</span></span>  
  
     <span data-ttu-id="1f03c-294">この問題は、複数のトランザクションが同じ行を選択し、その行の元の値を更新すると発生します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-294">Lost updates occur when two or more transactions select the same row and then update the row based on the value originally selected.</span></span> <span data-ttu-id="1f03c-295">トランザクションは互いに相手を認識しません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-295">Each transaction is unaware of the other transactions.</span></span> <span data-ttu-id="1f03c-296">更新によって他のトランザクションによる更新データが上書きされれば、そのデータが失われてしまいます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-296">The last update overwrites updates made by the other transactions, which results in lost data.</span></span>  
  
     <span data-ttu-id="1f03c-297">たとえば、2 人の編集者が同じ文書のコピーを作成したとします。</span><span class="sxs-lookup"><span data-stu-id="1f03c-297">For example, two editors make an electronic copy of the same document.</span></span> <span data-ttu-id="1f03c-298">2 人が自分のコピーを変更し、その変更内容を保存して、元の文書を上書きしたとします。</span><span class="sxs-lookup"><span data-stu-id="1f03c-298">Each editor changes the copy independently and then saves the changed copy thereby overwriting the original document.</span></span> <span data-ttu-id="1f03c-299">変更したコピーを最後に保存した編集者により、他の編集者が行った変更が上書きされます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-299">The editor who saves the changed copy last overwrites the changes made by the other editor.</span></span> <span data-ttu-id="1f03c-300">1 人の編集者が終了してトランザクションをコミットするまで、他の編集者がファイルにアクセスできないようにすれば、この問題を防ぐことができます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-300">This problem could be avoided if one editor could not access the file until the other editor had finished and committed the transaction.</span></span>  
  
-   <span data-ttu-id="1f03c-301">非コミット依存 (ダーティ リード)</span><span class="sxs-lookup"><span data-stu-id="1f03c-301">Uncommitted dependency (dirty read)</span></span>  
  
     <span data-ttu-id="1f03c-302">非コミット依存は、トランザクションによって更新されている行を別のトランザクションが選択するときに発生します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-302">Uncommitted dependency occurs when a second transaction selects a row that is being updated by another transaction.</span></span> <span data-ttu-id="1f03c-303">2 番目のトランザクションが読み取るデータは、まだコミットされていないので、行を更新しているトランザクションによって変更される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-303">The second transaction is reading data that has not been committed yet and may be changed by the transaction updating the row.</span></span>  
  
     <span data-ttu-id="1f03c-304">たとえば、ある編集者が電子文書を変更しているとします。</span><span class="sxs-lookup"><span data-stu-id="1f03c-304">For example, an editor is making changes to an electronic document.</span></span> <span data-ttu-id="1f03c-305">その間、他の編集者はそれまでの変更が反映された文書を受け取って、読者に配布します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-305">During the changes, a second editor takes a copy of the document that includes all the changes made so far, and distributes the document to the intended audience.</span></span> <span data-ttu-id="1f03c-306">その後、最初の編集者がそれまでの変更を誤りと判断して取り消し、保存したとします。</span><span class="sxs-lookup"><span data-stu-id="1f03c-306">The first editor then decides the changes made so far are wrong and removes the edits and saves the document.</span></span> <span data-ttu-id="1f03c-307">配布されている文書には取り消した編集内容が含まれているため、既に存在しない文書として扱う必要があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-307">The distributed document contains edits that no longer exist and should be treated as if they never existed.</span></span> <span data-ttu-id="1f03c-308">最初の編集者が最後に変更を保存してトランザクションをコミットするまで、変更された文書をだれも読み取ることができないようにすれば、この問題を防ぐことができます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-308">This problem could be avoided if no one could read the changed document until the first editor does the final save of modifications and commits the transaction.</span></span>  
  
-   <span data-ttu-id="1f03c-309">不一致分析 (反復不能読み取り)</span><span class="sxs-lookup"><span data-stu-id="1f03c-309">Inconsistent analysis (nonrepeatable read)</span></span>  
  
     <span data-ttu-id="1f03c-310">不一致分析は、別のトランザクションが同じ行に数回アクセスし、それぞれの場合で異なったデータを読み取るときに発生します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-310">Inconsistent analysis occurs when a second transaction accesses the same row several times and reads different data each time.</span></span> <span data-ttu-id="1f03c-311">不一致分析は、あるトランザクションがデータを変更している間に別のトランザクションがそのデータを読み取るという点で非コミット依存と似ています。</span><span class="sxs-lookup"><span data-stu-id="1f03c-311">Inconsistent analysis is similar to uncommitted dependency in that another transaction is changing the data that a second transaction is reading.</span></span> <span data-ttu-id="1f03c-312">ただし不一致分析の場合、別のトランザクションが読み取るデータは変更を行ったトランザクションによってコミットされています。</span><span class="sxs-lookup"><span data-stu-id="1f03c-312">However, in inconsistent analysis, the data read by the second transaction was committed by the transaction that made the change.</span></span> <span data-ttu-id="1f03c-313">また、同じ行が複数回読み取られ、そのたびにトランザクションによって情報が変更されます。そのため、反復不能読み取りと呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-313">Also, inconsistent analysis involves multiple reads (two or more) of the same row, and each time the information is changed by another transaction; thus, the term nonrepeatable read.</span></span>  
  
     <span data-ttu-id="1f03c-314">たとえば、編集者が同じ文書を 2 回読んだ場合に、1 回目と 2 回目の間に執筆者が文書を変更したとします。</span><span class="sxs-lookup"><span data-stu-id="1f03c-314">For example, an editor reads the same document twice, but between each reading the writer rewrites the document.</span></span> <span data-ttu-id="1f03c-315">編集者が 2 回目に文書を読んだときには、内容が大幅に変更されていました。</span><span class="sxs-lookup"><span data-stu-id="1f03c-315">When the editor reads the document for the second time, it has changed.</span></span> <span data-ttu-id="1f03c-316">最初に読んだ内容と同じものは再現されません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-316">The original read was not repeatable.</span></span> <span data-ttu-id="1f03c-317">編集者が最終的に読み終わるまで執筆者が文書を変更できないようにすると、この問題を防ぐことができます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-317">This problem could be avoided if the writer could not change the document until the editor has finished reading it for the last time.</span></span>  
  
-   <span data-ttu-id="1f03c-318">ファントム読み取り</span><span class="sxs-lookup"><span data-stu-id="1f03c-318">Phantom reads</span></span>  
  
     <span data-ttu-id="1f03c-319">ファントム読み取りとは、2 つの同じクエリが実行されたときに 2 番目のクエリによって返された行のコレクションが異なる場合に発生する状況です。</span><span class="sxs-lookup"><span data-stu-id="1f03c-319">A phantom read is a situation that occurs when two identical queries are executed and the collection of rows returned by the second query is different.</span></span> <span data-ttu-id="1f03c-320">以下の例に、この状況がどのように発生するかを示します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-320">The example below shows how this may occur.</span></span> <span data-ttu-id="1f03c-321">次の 2 つのトランザクションが同時に実行されると仮定します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-321">Assume the two transactions below are executing at the same time.</span></span> <span data-ttu-id="1f03c-322">最初のトランザクションにある 2 つの SELECT ステートメントは、異なる結果を返す可能性があります。これは、これら 2 つのステートメントで使用されるデータが 2 番目のトランザクションの INSERT ステートメントで変更されるためです。</span><span class="sxs-lookup"><span data-stu-id="1f03c-322">The two SELECT statements in the first transaction may return different results because the INSERT statement in the second transaction changes the data used by both.</span></span>  
  
    ```sql  
    --Transaction 1  
    BEGIN TRAN;  
    SELECT ID FROM dbo.employee  
    WHERE ID > 5 and ID < 10;  
    --The INSERT statement from the second transaction occurs here.  
    SELECT ID FROM dbo.employee  
    WHERE ID > 5 and ID < 10;  
    COMMIT;  
    ```  
  
    ```sql  
    --Transaction 2  
    BEGIN TRAN;  
    INSERT INTO dbo.employee  
       SET name = 'New' WHERE ID = 5;  
    COMMIT;   
    ```  
  
-   <span data-ttu-id="1f03c-323">行の更新による読み取りの欠落および重複</span><span class="sxs-lookup"><span data-stu-id="1f03c-323">Missing and double reads caused by row updates</span></span>  
  
    -   <span data-ttu-id="1f03c-324">更新された行の欠落または更新された行の複数回表示</span><span class="sxs-lookup"><span data-stu-id="1f03c-324">Missing a updated row or seeing an updated row multiple times</span></span>  
  
         <span data-ttu-id="1f03c-325">READ 未確定レベルで実行されているトランザクションでは、現在のトランザクションによって読み取られたデータが他のトランザクションによって変更されるのを防ぐために、共有ロックは発行されません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-325">Transactions that are running at the READ UNCOMMITTED level do not issue shared locks to prevent other transactions from modifying data read by the current transaction.</span></span> <span data-ttu-id="1f03c-326">READ COMMITTED レベルで実行されるトランザクションでは共有ロックが取得されますが、行ロックまたはページ ロックは行が読み取られた時点で解放されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-326">Transactions that are running at the READ COMMITTED level do issue shared locks, but the row or page locks are released after the row is read.</span></span> <span data-ttu-id="1f03c-327">どちらの場合も、インデックスをスキャンしているときに、読み取り中の行のインデックス キー列が他のユーザーによって変更された場合は、このキーの変更によって行がスキャン前の位置に移動すると、その行は再び出現する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-327">In either case, when you are scanning an index, if another user changes the index key column of the row during your read, the row might appear again if the key change moved the row to a position ahead of your scan.</span></span> <span data-ttu-id="1f03c-328">同様に、キーの変更によって、既に読み取ったインデックスの位置に行が移動すると、その行は出現しない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-328">Similarly, the row might not appear if the key change moved the row to a position in the index that you had already read.</span></span> <span data-ttu-id="1f03c-329">この問題を回避するには、SERIALIZABLE または HOLDLOCK のヒントや、行のバージョン管理を使用します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-329">To avoid this, use the SERIALIZABLE or HOLDLOCK hint, or row versioning.</span></span> <span data-ttu-id="1f03c-330">詳細については、「[テーブル ヒント &#40;Transact-SQL&#41;](/sql/t-sql/queries/hints-transact-sql-table)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1f03c-330">For more information, see [Table Hints &#40;Transact-SQL&#41;](/sql/t-sql/queries/hints-transact-sql-table).</span></span>  
  
    -   <span data-ttu-id="1f03c-331">更新の対象でなかった 1 行または複数行の欠落</span><span class="sxs-lookup"><span data-stu-id="1f03c-331">Missing one or more rows that were not the target of update</span></span>  
  
         <span data-ttu-id="1f03c-332">READ UNCOMMITTED を使用している場合、クエリで割り当て順序スキャン (IAM ページの使用) によって行を読み取っているときに、他のトランザクションによってページ分割が発生すると、行が欠落する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-332">When you are using READ UNCOMMITTED, if your query reads rows using an allocation order scan (using IAM pages), you might miss rows if another transaction is causing a page split.</span></span> <span data-ttu-id="1f03c-333">READ COMMITTED を使用している場合は、ページ分割時にテーブル ロックが保持されているため、この問題は発生しません。また、クラスター化インデックスを含まないテーブルの場合は、更新時にページ分割が行われることはないため、この問題は発生しません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-333">This cannot occur when you are using read committed because a table lock is held during a page split and does not happen if the table does not have a clustered index, because updates do not cause page splits.</span></span>  
  
#### <a name="types-of-concurrency"></a><span data-ttu-id="1f03c-334">コンカレンシーの種類</span><span class="sxs-lookup"><span data-stu-id="1f03c-334">Types of Concurrency</span></span>  

 <span data-ttu-id="1f03c-335">多くのユーザーが同時にデータベースのデータを変更する場合、あるユーザーによる変更が別のユーザーによる変更に悪影響を及ぼすことを防ぐために、何らかの制御機構を実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-335">When many people attempt to modify data in a database at the same time, a system of controls must be implemented so that modifications made by one person do not adversely affect those of another person.</span></span> <span data-ttu-id="1f03c-336">この制御機構をコンカレンシー制御と呼びます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-336">This is called concurrency control.</span></span>  
  
 <span data-ttu-id="1f03c-337">コンカレンシー制御の原理は、制御方法によって次の 2 種類に分類されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-337">Concurrency control theory has two classifications for the methods of instituting concurrency control:</span></span>  
  
-   <span data-ttu-id="1f03c-338">ペシミスティック コンカレンシー</span><span class="sxs-lookup"><span data-stu-id="1f03c-338">Pessimistic concurrency control</span></span>  
  
     <span data-ttu-id="1f03c-339">ロック機構により、ユーザーが他のユーザーに影響するデータの変更を行うことを防ぎます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-339">A system of locks prevents users from modifying data in a way that affects other users.</span></span> <span data-ttu-id="1f03c-340">あるユーザーによる操作でロックがかかると、そのユーザーがロックを解放するまで他のユーザーはロックと競合する操作を実行できません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-340">After a user performs an action that causes a lock to be applied, other users cannot perform actions that would conflict with the lock until the owner releases it.</span></span> <span data-ttu-id="1f03c-341">この方式は、データの競合が多く、コンカレンシーによる競合が発生した場合にトランザクションをロールバックするコストに比べデータをロックして保護するコストの方が低い環境で主に使用されるので、ペシミスティック コンカレンシー制御と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-341">This is called pessimistic control because it is mainly used in environments where there is high contention for data, where the cost of protecting data with locks is less than the cost of rolling back transactions if concurrency conflicts occur.</span></span>  
  
-   <span data-ttu-id="1f03c-342">オプティミスティック コンカレンシー</span><span class="sxs-lookup"><span data-stu-id="1f03c-342">Optimistic concurrency control</span></span>  
  
     <span data-ttu-id="1f03c-343">オプティミスティック コンカレンシーでは、データを読み取る時点ではロックがかかりません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-343">In optimistic concurrency control, users do not lock data when they read it.</span></span> <span data-ttu-id="1f03c-344">データを更新するときに、そのユーザーが読み取ってから他のユーザーによる変更がなかったかが確認されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-344">When a user updates data, the system checks to see if another user changed the data after it was read.</span></span> <span data-ttu-id="1f03c-345">他のユーザーがデータを更新していた場合、エラーが発生します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-345">If another user updated the data, an error is raised.</span></span> <span data-ttu-id="1f03c-346">通常は、エラーが報告されたユーザーがトランザクションをロールバックして再実行します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-346">Typically, the user receiving the error rolls back the transaction and starts over.</span></span> <span data-ttu-id="1f03c-347">この方式は、データの競合が少なく、データを読み取るときにロックして保護するコストに比べトランザクションを必要に応じてロールバックするコストの方が低い環境で主に使用されるので、オプティミスティック同時実行制御と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-347">This is called optimistic because it is mainly used in environments where there is low contention for data, and where the cost of occasionally rolling back a transaction is lower than the cost of locking data when read.</span></span>  
  
 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] <span data-ttu-id="1f03c-348">ではさまざまなコンカレンシー制御がサポートされています。</span><span class="sxs-lookup"><span data-stu-id="1f03c-348">supports a range of concurrency control.</span></span> <span data-ttu-id="1f03c-349">接続のトランザクション分離レベルやカーソルのコンカレンシー オプションを選択することで、コンカレンシー制御の種類を指定できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-349">Users specify the type of concurrency control by selecting transaction isolation levels for connections or concurrency options on cursors.</span></span> <span data-ttu-id="1f03c-350">これらの属性を選択するには、[!INCLUDE[tsql](../includes/tsql-md.md)] ステートメントを使用するか、ADO、ADO.NET、OLE DB、ODBC などのデータベース API (アプリケーション プログラミング インターフェイス) のプロパティおよび属性を指定します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-350">These attributes can be defined using [!INCLUDE[tsql](../includes/tsql-md.md)] statements, or through the properties and attributes of database application programming interfaces (APIs) such as ADO, ADO.NET, OLE DB, and ODBC.</span></span>  
  
#### <a name="isolation-levels-in-the-database-engine"></a><span data-ttu-id="1f03c-351">データベース エンジンにおける分離レベル</span><span class="sxs-lookup"><span data-stu-id="1f03c-351">Isolation Levels in the Database Engine</span></span>  

 <span data-ttu-id="1f03c-352">各トランザクションでは、別のトランザクションによって行われたリソースまたはデータの変更から特定のトランザクションを分離する際の程度を定義する分離レベルを指定します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-352">Transactions specify an isolation level that defines the degree to which one transaction must be isolated from resource or data modifications made by other transactions.</span></span> <span data-ttu-id="1f03c-353">分離レベルは、ダーティ リードやファントム読み取りなど、コンカレンシーの副作用が許可されるのかという観点で定義されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-353">Isolation levels are described in terms of which concurrency side-effects, such as dirty reads or phantom reads, are allowed.</span></span>  
  
 <span data-ttu-id="1f03c-354">トランザクション分離レベルでは次のことを制御しています。</span><span class="sxs-lookup"><span data-stu-id="1f03c-354">Transaction isolation levels control:</span></span>  
  
-   <span data-ttu-id="1f03c-355">データの読み取り時にロックを獲得するかどうか、要求されるロックの種類。</span><span class="sxs-lookup"><span data-stu-id="1f03c-355">Whether locks are taken when data is read, and what type of locks are requested.</span></span>  
  
-   <span data-ttu-id="1f03c-356">読み取りロックの保持期間。</span><span class="sxs-lookup"><span data-stu-id="1f03c-356">How long the read locks are held.</span></span>  
  
-   <span data-ttu-id="1f03c-357">別のトランザクションによって変更された行を参照している読み取り操作で、次のことを行うかどうか。</span><span class="sxs-lookup"><span data-stu-id="1f03c-357">Whether a read operation referencing rows modified by another transaction:</span></span>  
  
    -   <span data-ttu-id="1f03c-358">その行に対する排他ロックが解放されるまでブロックする。</span><span class="sxs-lookup"><span data-stu-id="1f03c-358">Blocks until the exclusive lock on the row is freed.</span></span>  
  
    -   <span data-ttu-id="1f03c-359">ステートメントまたはトランザクションの開始時に存在していた行の、コミット済みのバージョンを取得する。</span><span class="sxs-lookup"><span data-stu-id="1f03c-359">Retrieves the committed version of the row that existed at the time the statement or transaction started.</span></span>  
  
    -   <span data-ttu-id="1f03c-360">コミットされていないデータ変更を読み取る。</span><span class="sxs-lookup"><span data-stu-id="1f03c-360">Reads the uncommitted data modification.</span></span>  
  
> [!IMPORTANT]  
>  <span data-ttu-id="1f03c-361">トランザクション分離レベルを選択しても、データ変更を保護するために獲得したロックは影響を受けません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-361">Choosing a transaction isolation level does not affect the locks acquired to protect data modifications.</span></span> <span data-ttu-id="1f03c-362">トランザクションでは、設定されたトランザクション分離レベルに関係なく、常に、そのトランザクションで変更するデータについて排他ロックを獲得し、トランザクションが完了するまでそのロックを保持します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-362">A transaction always gets an exclusive lock on any data it modifies, and holds that lock until the transaction completes, regardless of the isolation level set for that transaction.</span></span> <span data-ttu-id="1f03c-363">トランザクション分離レベルでは主に、読み取り操作に対して、他のトランザクションによって行われる変更の影響からの保護レベルを定義します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-363">For read operations, transaction isolation levels primarily define the level of protection from the effects of modifications made by other transactions.</span></span>  
  
 <span data-ttu-id="1f03c-364">分離レベルが低いほど多くのユーザーが同時にデータにアクセスできるようになりますが、ユーザーに影響が及ぶ可能性があるコンカレンシーの影響 (ダーティ リードや更新データの喪失) の種類が多くなります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-364">A lower isolation level increases the ability of many users to access data at the same time, but increases the number of concurrency effects (such as dirty reads or lost updates) users might encounter.</span></span> <span data-ttu-id="1f03c-365">反対に、分離レベルが高いほど、ユーザーに影響が及ぶ可能性があるコンカレンシーの影響の種類は減りますが、必要なシステム リソースが増加し、あるトランザクションによって別のトランザクションがブロックされる状況も多くなります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-365">Conversely, a higher isolation level reduces the types of concurrency effects that users may encounter, but requires more system resources and increases the chances that one transaction will block another.</span></span> <span data-ttu-id="1f03c-366">適切な分離レベルの選択は、アプリケーションのデータ整合性の要件と各分離レベルのオーバーヘッドとのバランスによって決まります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-366">Choosing the appropriate isolation level depends on balancing the data integrity requirements of the application against the overhead of each isolation level.</span></span> <span data-ttu-id="1f03c-367">最も高い分離レベルの SERIALIZABLE は、トランザクションで読み取り操作が繰り返し実行されるたびに、そのトランザクションで完全に同じデータが取得されることを保証します。このことの実現には、マルチユーザー システムにおいて他のユーザーが影響を受ける可能性が高いロック レベルが適用されています。</span><span class="sxs-lookup"><span data-stu-id="1f03c-367">The highest isolation level, serializable, guarantees that a transaction will retrieve exactly the same data every time it repeats a read operation, but it does this by performing a level of locking that is likely to impact other users in multi-user systems.</span></span> <span data-ttu-id="1f03c-368">最も低い分離レベルは READ UNCOMMITTED ですが、このレベルでは、他のトランザクションによって変更され、まだコミットされていないデータを取得する場合があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-368">The lowest isolation level, read uncommitted, may retrieve data that has been modified but not committed by other transactions.</span></span> <span data-ttu-id="1f03c-369">READ UNCOMMITTED レベルではコンカレンシーのすべての副作用が発生する可能性がありますが、このレベルでは読み取りロックやバージョン管理が行われないのでオーバーヘッドが最小限に抑えられます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-369">All of the concurrency side effects can happen in read uncommitted, but there is no read locking or versioning, so overhead is minimized.</span></span>  
  
##### <a name="database-engine-isolation-levels"></a><span data-ttu-id="1f03c-370">データベース エンジンの分離レベル</span><span class="sxs-lookup"><span data-stu-id="1f03c-370">Database Engine Isolation Levels</span></span>  

 <span data-ttu-id="1f03c-371">ISO 標準では、次に示す分離レベルが定義されています。それらのすべてが [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)]でサポートされます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-371">The ISO standard defines the following isolation levels, all of which are supported by the [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)]:</span></span>  
  
|<span data-ttu-id="1f03c-372">Isolation Level</span><span class="sxs-lookup"><span data-stu-id="1f03c-372">Isolation Level</span></span>|<span data-ttu-id="1f03c-373">定義</span><span class="sxs-lookup"><span data-stu-id="1f03c-373">Definition</span></span>|  
|---------------------|----------------|  
|<span data-ttu-id="1f03c-374">READ UNCOMMITTED</span><span class="sxs-lookup"><span data-stu-id="1f03c-374">Read uncommitted</span></span>|<span data-ttu-id="1f03c-375">物理的に破損したデータを読み取らないことのみが保証されるようにトランザクションを分離する、最も低い分離レベル。</span><span class="sxs-lookup"><span data-stu-id="1f03c-375">The lowest isolation level where transactions are isolated only enough to ensure that physically corrupt data is not read.</span></span> <span data-ttu-id="1f03c-376">このレベルではダーティ リードが許可されるため、トランザクションで行われたコミットされていない変更を、他のトランザクションで読み取ることが可能です。</span><span class="sxs-lookup"><span data-stu-id="1f03c-376">In this level, dirty reads are allowed, so one transaction may see not-yet-committed changes made by other transactions.</span></span>|  
|<span data-ttu-id="1f03c-377">READ COMMITTED</span><span class="sxs-lookup"><span data-stu-id="1f03c-377">Read committed</span></span>|<span data-ttu-id="1f03c-378">トランザクションは、別のトランザクションが以前に読み取った (変更されていない) データを読み取ることができるので、最初のトランザクションが完了するまで待機する必要がありません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-378">Allows a transaction to read data previously read (not modified) by another transaction without waiting for the first transaction to complete.</span></span> <span data-ttu-id="1f03c-379">[!INCLUDE[ssDE](../includes/ssde-md.md)]は、(選択されたデータに対して取得された) 書き込みロックをトランザクションの終わりまで保持しますが、読み取りロックは SELECT 操作の実行が終わると解放します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-379">The [!INCLUDE[ssDE](../includes/ssde-md.md)] keeps write locks (acquired on selected data) until the end of the transaction, but read locks are released as soon as the SELECT operation is performed.</span></span> <span data-ttu-id="1f03c-380">これは[!INCLUDE[ssDE](../includes/ssde-md.md)]の既定のレベルです。</span><span class="sxs-lookup"><span data-stu-id="1f03c-380">This is the [!INCLUDE[ssDE](../includes/ssde-md.md)] default level.</span></span>|  
|<span data-ttu-id="1f03c-381">REPEATABLE READ</span><span class="sxs-lookup"><span data-stu-id="1f03c-381">Repeatable read</span></span>|<span data-ttu-id="1f03c-382">[!INCLUDE[ssDE](../includes/ssde-md.md)]は、選択されたデータに対して取得された読み取り/書き込みロックをトランザクションの終わりまで保持します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-382">The [!INCLUDE[ssDE](../includes/ssde-md.md)] keeps read and write locks that are acquired on selected data until the end of the transaction.</span></span> <span data-ttu-id="1f03c-383">ただし、範囲ロックが管理されないため、ファントム読み取りが発生する可能性はあります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-383">However, because range-locks are not managed, phantom reads can occur.</span></span>|  
|<span data-ttu-id="1f03c-384">シリアル化可能</span><span class="sxs-lookup"><span data-stu-id="1f03c-384">Serializable</span></span>|<span data-ttu-id="1f03c-385">各トランザクションが完全に分離される、最も高い分離レベル。</span><span class="sxs-lookup"><span data-stu-id="1f03c-385">The highest level where transactions are completely isolated from one another.</span></span> <span data-ttu-id="1f03c-386">[!INCLUDE[ssDE](../includes/ssde-md.md)]は、選択されたデータに対して取得された読み取り/書き込みロックを保持し、トランザクションの終わりに開放します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-386">The [!INCLUDE[ssDE](../includes/ssde-md.md)] keeps read and write locks acquired on selected data to be released at the end of the transaction.</span></span> <span data-ttu-id="1f03c-387">範囲指定付きの WHERE 句を SELECT 操作に使用する場合には、特にファントム読み取りを回避するために範囲ロックが取得されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-387">Range-locks are acquired when a SELECT operation uses a ranged WHERE clause, especially to avoid phantom reads.</span></span><br /><br /> <span data-ttu-id="1f03c-388">**注:** SERIALIZABLE 分離レベルが要求された場合、レプリケートされたテーブルの DDL 操作やトランザクションが失敗することがあります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-388">**Note:** DDL operations and transactions on replicated tables may fail when serializable isolation level is requested.</span></span> <span data-ttu-id="1f03c-389">レプリケーションのクエリで使用されるヒントは、SERIALIZABLE 分離レベルと互換性がない可能性があるためです。</span><span class="sxs-lookup"><span data-stu-id="1f03c-389">This is because replication queries use hints that may be incompatible with serializable isolation level.</span></span>|  
  
 <span data-ttu-id="1f03c-390">また、[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] では、行のバージョン管理を使用する 2 つの追加トランザクション分離レベルがサポートされます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-390">[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] also supports two additional transaction isolation levels that use row versioning.</span></span> <span data-ttu-id="1f03c-391">1 つは、READ COMMITTED 分離の実装であり、1 つはトランザクション分離レベルである "スナップショット" です。</span><span class="sxs-lookup"><span data-stu-id="1f03c-391">One is an implementation of read committed isolation, and one is a transaction isolation level, snapshot.</span></span>  
  
|<span data-ttu-id="1f03c-392">行のバージョン管理分離レベル</span><span class="sxs-lookup"><span data-stu-id="1f03c-392">Row Versioning Isolation Level</span></span>|<span data-ttu-id="1f03c-393">定義</span><span class="sxs-lookup"><span data-stu-id="1f03c-393">Definition</span></span>|  
|------------------------------------|----------------|  
|<span data-ttu-id="1f03c-394">READ COMMITTED SNAPSHOT</span><span class="sxs-lookup"><span data-stu-id="1f03c-394">Read Committed Snapshot</span></span>|<span data-ttu-id="1f03c-395">READ_COMMITTED_SNAPSHOT データベース オプションが ON に設定されている場合、READ COMMITTED 分離では、行のバージョン管理を使用して読み取りの一貫性をステートメント レベルで維持します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-395">When the READ_COMMITTED_SNAPSHOT database option is set ON, read committed isolation uses row versioning to provide statement-level read consistency.</span></span> <span data-ttu-id="1f03c-396">読み取り操作にはテーブル レベルの SCH-S ロックだけが必要であり、ページ ロックや行ロックは不要です。</span><span class="sxs-lookup"><span data-stu-id="1f03c-396">Read operations require only SCH-S table level locks and no page or row locks.</span></span> <span data-ttu-id="1f03c-397">つまりデータベース エンジンでは行のバージョン管理が使用され、各ステートメントでは、トランザクション全体で一貫性のあるデータのスナップショットが使用されます。このスナップショットは、ステートメント開始時点に存在したデータのスナップショットです。</span><span class="sxs-lookup"><span data-stu-id="1f03c-397">That is, the Database Engine uses row versioning to present each statement with a transactionally consistent snapshot of the data as it existed at the start of the statement.</span></span> <span data-ttu-id="1f03c-398">ただし、ロックは、他のトランザクションがデータを更新するのを防ぐために使用されることはありません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-398">Locks are not used to protect the data from updates by other transactions.</span></span> <span data-ttu-id="1f03c-399">ユーザー定義関数から返されるデータは、そのユーザー定義関数を含んでいるステートメントの開始後にコミットされたものである可能性があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-399">A user-defined function can return data that was committed after the time the statement containing the UDF began.</span></span><br /><br /> <span data-ttu-id="1f03c-400">READ_COMMITTED_SNAPSHOT データベース オプションが OFF (既定) に設定されている場合は、READ_COMMITTED 分離に共有ロックが使用されます。これにより、現在のトランザクションでの読み取り操作中に他のトランザクションによって行が変更されるのを防ぐことができます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-400">When the READ_COMMITTED_SNAPSHOT database option is set OFF, which is the default setting, read committed isolation uses shared locks to prevent other transactions from modifying rows while the current transaction is running a read operation.</span></span> <span data-ttu-id="1f03c-401">また、ステートメントが他のトランザクションで変更された行を読み取ろうとしても、そのトランザクションが完了するまでステートメントはブロックされます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-401">The shared locks also block the statement from reading rows modified by other transactions until the other transaction is completed.</span></span> <span data-ttu-id="1f03c-402">どちらの実装も READ COMMITTED 分離の ISO 定義に準拠しています。</span><span class="sxs-lookup"><span data-stu-id="1f03c-402">Both implementations meet the ISO definition of read committed isolation.</span></span>|  
|<span data-ttu-id="1f03c-403">スナップショット</span><span class="sxs-lookup"><span data-stu-id="1f03c-403">Snapshot</span></span>|<span data-ttu-id="1f03c-404">スナップショット分離レベルでは、行のバージョン管理を使用して読み取りの一貫性をトランザクション レベルで維持します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-404">The snapshot isolation level uses row versioning to provide transaction-level read consistency.</span></span> <span data-ttu-id="1f03c-405">読み取り操作では、ページ ロックも行ロックも獲得しません。テーブル レベルの SCH-S ロックだけを獲得します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-405">Read operations acquire no page or row locks; only SCH-S table locks are acquired.</span></span> <span data-ttu-id="1f03c-406">別のトランザクションによって変更された行を読み取るときは、トランザクションの開始時に存在していた行のバージョンを取得します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-406">When reading rows modified by another transaction, they retrieve the version of the row that existed when the transaction started.</span></span> <span data-ttu-id="1f03c-407">データベースに対してスナップショット分離を使用できるのは、ALLOW_SNAPSHOT_ISOLATION データベース オプションが ON に設定されている場合のみです。</span><span class="sxs-lookup"><span data-stu-id="1f03c-407">You can only use Snapshot isolation against a database when the ALLOW_SNAPSHOT_ISOLATION database option is set ON.</span></span> <span data-ttu-id="1f03c-408">既定では、ユーザー データベースのこのオプションは OFF に設定されています。</span><span class="sxs-lookup"><span data-stu-id="1f03c-408">By default, this option is set OFF for user databases.</span></span><br /><br /> <span data-ttu-id="1f03c-409">**注意:** [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] では、メタデータのバージョン管理はサポートされません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-409">**Note:**  [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] does not support versioning of metadata.</span></span> <span data-ttu-id="1f03c-410">そのため、スナップショット分離下で実行されている明示的なトランザクションでは、実行できる DDL 操作に制限があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-410">For this reason, there are restrictions on what DDL operations can be performed in an explicit transaction that is running under snapshot isolation.</span></span> <span data-ttu-id="1f03c-411">スナップショット分離下では、BEGIN TRANSACTION ステートメントの後に、ALTER TABLE、CREATE INDEX、CREATE XML INDEX、ALTER INDEX、DROP INDEX、DBCC REINDEX、ALTER PARTITION FUNCTION、ALTER PARTITION SCHEME などの DDL ステートメントを実行することはできません。共通言語ランタイム (CLR) の DDL ステートメントも同様です。</span><span class="sxs-lookup"><span data-stu-id="1f03c-411">The following DDL statements are not permitted under snapshot isolation after a BEGIN TRANSACTION statement: ALTER TABLE, CREATE INDEX, CREATE XML INDEX, ALTER INDEX, DROP INDEX, DBCC REINDEX, ALTER PARTITION FUNCTION, ALTER PARTITION SCHEME, or any common language runtime (CLR) DDL statement.</span></span> <span data-ttu-id="1f03c-412">暗黙のトランザクション内でスナップショット分離を使用しているときには、これらのステートメントは許可されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-412">These statements are permitted when you are using snapshot isolation within implicit transactions.</span></span> <span data-ttu-id="1f03c-413">暗黙的なトランザクションとは、原則的に、DDL ステートメントでもスナップショット分離のセマンティックを適用することのできる単一のステートメントをいいます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-413">An implicit transaction, by definition, is a single statement that makes it possible to enforce the semantics of snapshot isolation, even with DDL statements.</span></span> <span data-ttu-id="1f03c-414">この原則に反した場合、エラー 3961 が発生し、"データベース '%.\*ls' でスナップショット分離トランザクションが失敗しました。ステートメントからアクセスされるオブジェクトが、このトランザクションの開始後に別の同時トランザクションの DDL ステートメントで変更されました。</span><span class="sxs-lookup"><span data-stu-id="1f03c-414">Violations of this principle can cause error 3961: "Snapshot isolation transaction failed in database '%.\*ls' because the object accessed by the statement has been modified by a DDL statement in another concurrent transaction since the start of this transaction.</span></span> <span data-ttu-id="1f03c-415">メタデータはバージョン管理されないため、この操作は許可されません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-415">It is not allowed because the metadata is not versioned.</span></span> <span data-ttu-id="1f03c-416">メタデータに対する同時更新は、スナップショット分離と組み合わせると一貫性を損なう結果になる可能性があります。" というメッセージが表示されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-416">A concurrent update to metadata could lead to inconsistency if mixed with snapshot isolation."</span></span>|  
  
 <span data-ttu-id="1f03c-417">次の表に、各分離レベルで許容されているコンカレンシーの副作用を示します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-417">The following table shows the concurrency side effects enabled by the different isolation levels.</span></span>  
  
|<span data-ttu-id="1f03c-418">分離レベル</span><span class="sxs-lookup"><span data-stu-id="1f03c-418">Isolation level</span></span>|<span data-ttu-id="1f03c-419">ダーティ リード</span><span class="sxs-lookup"><span data-stu-id="1f03c-419">Dirty read</span></span>|<span data-ttu-id="1f03c-420">反復不可能読み取り</span><span class="sxs-lookup"><span data-stu-id="1f03c-420">Nonrepeatable read</span></span>|<span data-ttu-id="1f03c-421">ファントム</span><span class="sxs-lookup"><span data-stu-id="1f03c-421">Phantom</span></span>|  
|---------------------|----------------|------------------------|-------------|  
|<span data-ttu-id="1f03c-422">**READ UNCOMMITTED**</span><span class="sxs-lookup"><span data-stu-id="1f03c-422">**Read uncommitted**</span></span>|<span data-ttu-id="1f03c-423">はい</span><span class="sxs-lookup"><span data-stu-id="1f03c-423">Yes</span></span>|<span data-ttu-id="1f03c-424">はい</span><span class="sxs-lookup"><span data-stu-id="1f03c-424">Yes</span></span>|<span data-ttu-id="1f03c-425">はい</span><span class="sxs-lookup"><span data-stu-id="1f03c-425">Yes</span></span>|  
|<span data-ttu-id="1f03c-426">**READ COMMITTED**</span><span class="sxs-lookup"><span data-stu-id="1f03c-426">**Read committed**</span></span>|<span data-ttu-id="1f03c-427">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-427">No</span></span>|<span data-ttu-id="1f03c-428">はい</span><span class="sxs-lookup"><span data-stu-id="1f03c-428">Yes</span></span>|<span data-ttu-id="1f03c-429">はい</span><span class="sxs-lookup"><span data-stu-id="1f03c-429">Yes</span></span>|  
|<span data-ttu-id="1f03c-430">**REPEATABLE READ**</span><span class="sxs-lookup"><span data-stu-id="1f03c-430">**Repeatable read**</span></span>|<span data-ttu-id="1f03c-431">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-431">No</span></span>|<span data-ttu-id="1f03c-432">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-432">No</span></span>|<span data-ttu-id="1f03c-433">はい</span><span class="sxs-lookup"><span data-stu-id="1f03c-433">Yes</span></span>|  
|<span data-ttu-id="1f03c-434">**スナップショット**</span><span class="sxs-lookup"><span data-stu-id="1f03c-434">**Snapshot**</span></span>|<span data-ttu-id="1f03c-435">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-435">No</span></span>|<span data-ttu-id="1f03c-436">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-436">No</span></span>|<span data-ttu-id="1f03c-437">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-437">No</span></span>|  
|<span data-ttu-id="1f03c-438">**SERIALIZABLE**</span><span class="sxs-lookup"><span data-stu-id="1f03c-438">**Serializable**</span></span>|<span data-ttu-id="1f03c-439">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-439">No</span></span>|<span data-ttu-id="1f03c-440">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-440">No</span></span>|<span data-ttu-id="1f03c-441">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-441">No</span></span>|  
  
 <span data-ttu-id="1f03c-442">各トランザクション分離レベルによって制御される特定のロックまたは行のバージョン管理の種類について詳しくは、「[SET TRANSACTION ISOLATION LEVEL &#40;Transact-SQL&#41;](/sql/t-sql/statements/set-transaction-isolation-level-transact-sql)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="1f03c-442">For more information about the specific types of locking or row versioning controlled by each transaction isolation level, see [SET TRANSACTION ISOLATION LEVEL &#40;Transact-SQL&#41;](/sql/t-sql/statements/set-transaction-isolation-level-transact-sql).</span></span>  
  
 <span data-ttu-id="1f03c-443">トランザクションの分離レベルは、[!INCLUDE[tsql](../includes/tsql-md.md)] を使用するかデータベース API を使用して設定できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-443">Transaction isolation levels can be set using [!INCLUDE[tsql](../includes/tsql-md.md)] or through a database API.</span></span>  
  
 [!INCLUDE[tsql](../includes/tsql-md.md)]  
 [!INCLUDE[tsql](../includes/tsql-md.md)] <span data-ttu-id="1f03c-444">スクリプトでは、SET TRANSACTION ISOLATION LEVEL ステートメントが使用されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-444">scripts use the SET TRANSACTION ISOLATION LEVEL statement.</span></span>  
  
 <span data-ttu-id="1f03c-445">ADO (ADO)</span><span class="sxs-lookup"><span data-stu-id="1f03c-445">ADO</span></span>  
 <span data-ttu-id="1f03c-446">ADO アプリケーションでは、**Connection** オブジェクトの `IsolationLevel` プロパティが adXactReadUncommitted、adXactReadCommitted、adXactRepeatableRead、または adXactReadSerializable に設定されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-446">ADO applications set the `IsolationLevel` property of the **Connection** object to adXactReadUncommitted, adXactReadCommitted, adXactRepeatableRead, or adXactReadSerializable.</span></span>  
  
 <span data-ttu-id="1f03c-447">ADO.NET</span><span class="sxs-lookup"><span data-stu-id="1f03c-447">ADO.NET</span></span>  
 <span data-ttu-id="1f03c-448">`System.Data.SqlClient` マネージド名前空間を使用している ADO.NET アプリケーションは、`SqlConnection.BeginTransaction` メソッドを呼び出し、*IsolationLevel* オプションを Unspecified、Chaos、ReadUncommitted、ReadCommitted、RepeatableRead、Serializable、および Snapshot に設定することができます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-448">ADO.NET applications using the `System.Data.SqlClient` managed namespace can call the `SqlConnection.BeginTransaction` method and set the *IsolationLevel* option to Unspecified, Chaos, ReadUncommitted, ReadCommitted, RepeatableRead, Serializable, and Snapshot.</span></span>  
  
 <span data-ttu-id="1f03c-449">OLE DB (OLE DB)</span><span class="sxs-lookup"><span data-stu-id="1f03c-449">OLE DB</span></span>  
 <span data-ttu-id="1f03c-450">トランザクションを開始するとき、OLE DB を使用するアプリケーションは、*isoLevel* を ISOLATIONLEVEL_READUNCOMMITTED、ISOLATIONLEVEL_READCOMMITTED、ISOLATIONLEVEL_REPEATABLEREAD、ISOLATIONLEVEL_SNAPSHOT、または ISOLATIONLEVEL_SERIALIZABLE に設定して、`ITransactionLocal::StartTransaction` を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-450">When starting a transaction, applications using OLE DB call `ITransactionLocal::StartTransaction` with *isoLevel* set to ISOLATIONLEVEL_READUNCOMMITTED, ISOLATIONLEVEL_READCOMMITTED, ISOLATIONLEVEL_REPEATABLEREAD, ISOLATIONLEVEL_SNAPSHOT, or ISOLATIONLEVEL_SERIALIZABLE.</span></span>  
  
 <span data-ttu-id="1f03c-451">トランザクション分離レベルを自動コミット モードで指定する場合、OLE DB アプリケーションは、DBPROPSET_SESSION プロパティの DBPROP_SESS_AUTOCOMMITISOLEVELS を DBPROPVAL_TI_CHAOS、DBPROPVAL_TI_READUNCOMMITTED、DBPROPVAL_TI_BROWSE、DBPROPVAL_TI_CURSORSTABILITY、DBPROPVAL_TI_READCOMMITTED、DBPROPVAL_TI_REPEATABLEREAD、DBPROPVAL_TI_SERIALIZABLE、DBPROPVAL_TI_ISOLATED、または DBPROPVAL_TI_SNAPSHOT に設定できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-451">When specifying the transaction isolation level in autocommit mode, OLE DB applications can set the DBPROPSET_SESSION property DBPROP_SESS_AUTOCOMMITISOLEVELS to DBPROPVAL_TI_CHAOS, DBPROPVAL_TI_READUNCOMMITTED, DBPROPVAL_TI_BROWSE, DBPROPVAL_TI_CURSORSTABILITY, DBPROPVAL_TI_READCOMMITTED, DBPROPVAL_TI_REPEATABLEREAD, DBPROPVAL_TI_SERIALIZABLE, DBPROPVAL_TI_ISOLATED, or DBPROPVAL_TI_SNAPSHOT.</span></span>  
  
 <span data-ttu-id="1f03c-452">ODBC</span><span class="sxs-lookup"><span data-stu-id="1f03c-452">ODBC</span></span>  
 <span data-ttu-id="1f03c-453">ODBC アプリケーションは、*Attribute* を SQL_ATTR_TXN_ISOLATION に設定し、*ValuePtr* を SQL_TXN_READ_UNCOMMITTED、SQL_TXN_READ_COMMITTED、SQL_TXN_REPEATABLE_READ、または SQL_TXN_SERIALIZABLE に設定して、`SQLSetConnectAttr` を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-453">ODBC applications call `SQLSetConnectAttr` with *Attribute* set to SQL_ATTR_TXN_ISOLATION and *ValuePtr* set to SQL_TXN_READ_UNCOMMITTED, SQL_TXN_READ_COMMITTED, SQL_TXN_REPEATABLE_READ, or SQL_TXN_SERIALIZABLE.</span></span>  
  
 <span data-ttu-id="1f03c-454">スナップショット トランザクションでは、アプリケーションは、Attribute を SQL_COPT_SS_TXN_ISOLATION に設定し、ValuePtr を SQL_TXN_SS_SNAPSHOT に設定して、`SQLSetConnectAttr` を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-454">For snapshot transactions, applications call `SQLSetConnectAttr` with Attribute set to SQL_COPT_SS_TXN_ISOLATION and ValuePtr set to SQL_TXN_SS_SNAPSHOT.</span></span> <span data-ttu-id="1f03c-455">スナップショット トランザクションは、SQL_COPT_SS_TXN_ISOLATION または SQL_ATTR_TXN_ISOLATION のいずれかを使用して取得できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-455">A snapshot transaction can be retrieved using either SQL_COPT_SS_TXN_ISOLATION or SQL_ATTR_TXN_ISOLATION.</span></span>  
  
 <span data-ttu-id="1f03c-456">[このガイドの [](#Top) ![トップに戻る] リンクで使用される矢印アイコン](media/uparrow16x16.gif "[トップに戻る] リンクで使用される矢印アイコン")</span><span class="sxs-lookup"><span data-stu-id="1f03c-456">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
##  <a name="locking-in-the-database-engine"></a><a name="Lock_Engine"></a> <span data-ttu-id="1f03c-457">データベース エンジンのロック</span><span class="sxs-lookup"><span data-stu-id="1f03c-457">Locking in the Database Engine</span></span>  

 <span data-ttu-id="1f03c-458">[!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)]では、"ロック" というメカニズムを使用して、複数のユーザーによる同じデータへの同時アクセスが同期されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-458">Locking is a mechanism used by the [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] to synchronize access by multiple users to the same piece of data at the same time.</span></span>  
  
 <span data-ttu-id="1f03c-459">トランザクションでは、データの読み取りや変更など、データの現在の状態に対する依存関係を取得する前に、そのトランザクションを、別のトランザクションで同じデータが変更される影響から保護する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-459">Before a transaction acquires a dependency on the current state of a piece of data, such as by reading or modifying the data, it must protect itself from the effects of another transaction modifying the same data.</span></span> <span data-ttu-id="1f03c-460">トランザクションでは、データのロックを要求することにより、この問題に対処しています。</span><span class="sxs-lookup"><span data-stu-id="1f03c-460">The transaction does this by requesting a lock on the piece of data.</span></span> <span data-ttu-id="1f03c-461">ロックには、共有ロックや排他ロックなど複数のモードがあります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-461">Locks have different modes, such as shared or exclusive.</span></span> <span data-ttu-id="1f03c-462">ロック モードは、データに対するトランザクションの依存関係の度合いを定義します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-462">The lock mode defines the level of dependency the transaction has on the data.</span></span> <span data-ttu-id="1f03c-463">別のトランザクションに既に許可されているロックのモードと競合するロックを、トランザクションに許可することはできません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-463">No transaction can be granted a lock that would conflict with the mode of a lock already granted on that data to another transaction.</span></span> <span data-ttu-id="1f03c-464">トランザクションで、あるデータに対して既に許可されたロックと競合するロックのモードが要求された場合、[!INCLUDE[ssDE](../includes/ssde-md.md)]のインスタンスにより、既に許可されたロックが解放されるまで、要求を行ったトランザクションは保留されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-464">If a transaction requests a lock mode that conflicts with a lock that has already been granted on the same data, the instance of the [!INCLUDE[ssDE](../includes/ssde-md.md)] will pause the requesting transaction until the first lock is released.</span></span>  
  
 <span data-ttu-id="1f03c-465">トランザクションでデータが変更される場合、そのトランザクションでは、トランザクションが完了するまでロックを保持して、データの変更を保護します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-465">When a transaction modifies a piece of data, it holds the lock protecting the modification until the end of the transaction.</span></span> <span data-ttu-id="1f03c-466">トランザクションが読み取り操作を保護するために取得したロックの保持期間は、トランザクションの分離レベルの設定により異なります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-466">How long a transaction holds the locks acquired to protect read operations depends on the transaction isolation level setting.</span></span> <span data-ttu-id="1f03c-467">トランザクションで保持されているすべてのロックは、トランザクションが完了 (コミットまたはロールバック) した時点で解放されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-467">All locks held by a transaction are released when the transaction completes (either commits or rolls back).</span></span>  
  
 <span data-ttu-id="1f03c-468">通常、アプリケーションから、ロックが直接要求されることはありません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-468">Applications do not typically request locks directly.</span></span> <span data-ttu-id="1f03c-469">ロックは、[!INCLUDE[ssDE](../includes/ssde-md.md)]のロック マネージャーにより、内部で管理されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-469">Locks are managed internally by a part of the [!INCLUDE[ssDE](../includes/ssde-md.md)] called the lock manager.</span></span> <span data-ttu-id="1f03c-470">[!INCLUDE[ssDE](../includes/ssde-md.md)]のインスタンスで [!INCLUDE[tsql](../includes/tsql-md.md)] ステートメントが処理されると、[!INCLUDE[ssDE](../includes/ssde-md.md)]のクエリ プロセッサにより、アクセスするリソースが判断されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-470">When an instance of the [!INCLUDE[ssDE](../includes/ssde-md.md)] processes a [!INCLUDE[tsql](../includes/tsql-md.md)] statement, the [!INCLUDE[ssDE](../includes/ssde-md.md)] query processor determines which resources are to be accessed.</span></span> <span data-ttu-id="1f03c-471">クエリ プロセッサでは、アクセスの種類とトランザクションの分離レベルの設定に基づいて、各リソースを保護するために必要なロックの種類が決定されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-471">The query processor determines what types of locks are required to protect each resource based on the type of access and the transaction isolation level setting.</span></span> <span data-ttu-id="1f03c-472">その後、クエリ プロセッサから、ロック マネージャーに適切なロックが要求されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-472">The query processor then requests the appropriate locks from the lock manager.</span></span> <span data-ttu-id="1f03c-473">ロック マネージャーでは、別のトランザクションで保持されているロックに競合するロックがない場合、要求されたロックを許可します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-473">The lock manager grants the locks if there are no conflicting locks held by other transactions.</span></span>  
  
### <a name="lock-granularity-and-hierarchies"></a><span data-ttu-id="1f03c-474">ロックの粒度と階層</span><span class="sxs-lookup"><span data-stu-id="1f03c-474">Lock Granularity and Hierarchies</span></span>  

 <span data-ttu-id="1f03c-475">[!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)]では、複数粒度のロックがサポートされており、種類の異なるリソースをトランザクションでロックできます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-475">The [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] has multigranular locking that allows different types of resources to be locked by a transaction.</span></span> <span data-ttu-id="1f03c-476">[!INCLUDE[ssDE](../includes/ssde-md.md)]により、タスクに適したレベルでリソースが自動的にロックされるので、最小限のコストでロックされます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-476">To minimize the cost of locking, the [!INCLUDE[ssDE](../includes/ssde-md.md)] locks resources automatically at a level appropriate to the task.</span></span> <span data-ttu-id="1f03c-477">ロックの粒度を細かくすると (行単位など)、コンカレンシーが高くなります。ただし、多くの行をロックすると、ロック数が増えるのでオーバーヘッドが増大します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-477">Locking at a smaller granularity, such as rows, increases concurrency but has a higher overhead because more locks must be held if many rows are locked.</span></span> <span data-ttu-id="1f03c-478">ロックの粒度を粗くすると (テーブル単位など)、テーブル全体がロックされるので、他のトランザクションがそのテーブルにアクセスできなくなります。このため、コンカレンシーが低下します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-478">Locking at a larger granularity, such as tables, are expensive in terms of concurrency because locking an entire table restricts access to any part of the table by other transactions.</span></span> <span data-ttu-id="1f03c-479">ただし、ロック数が減るので、オーバーヘッドは減少します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-479">However, it has a lower overhead because fewer locks are being maintained.</span></span>  
  
 <span data-ttu-id="1f03c-480">[!INCLUDE[ssDE](../includes/ssde-md.md)]ではリソースを完全に保護するために、多くの場合、レベルの異なる粒度でロックを取得する必要が生じます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-480">The [!INCLUDE[ssDE](../includes/ssde-md.md)] often has to acquire locks at multiple levels of granularity to fully protect a resource.</span></span> <span data-ttu-id="1f03c-481">この複数レベルの粒度でのロックのグループを、ロック階層と呼びます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-481">This group of locks at multiple levels of granularity is called a lock hierarchy.</span></span> <span data-ttu-id="1f03c-482">たとえば、[!INCLUDE[ssDE](../includes/ssde-md.md)]のインスタンスは、インデックスの読み取りを完全に保護するために、行の共有ロックと、ページやテーブルのインテント共有ロックを取得しなければならない場合があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-482">For example, to fully protect a read of an index, an instance of the [!INCLUDE[ssDE](../includes/ssde-md.md)] may have to acquire share locks on rows and intent share locks on the pages and table.</span></span>  
  
 <span data-ttu-id="1f03c-483">次の表に、[!INCLUDE[ssDE](../includes/ssde-md.md)]がロックできるリソースを示します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-483">The following table shows the resources that the [!INCLUDE[ssDE](../includes/ssde-md.md)] can lock.</span></span>  
  
|<span data-ttu-id="1f03c-484">リソース</span><span class="sxs-lookup"><span data-stu-id="1f03c-484">Resource</span></span>|<span data-ttu-id="1f03c-485">説明</span><span class="sxs-lookup"><span data-stu-id="1f03c-485">Description</span></span>|  
|--------------|-----------------|  
|<span data-ttu-id="1f03c-486">RID</span><span class="sxs-lookup"><span data-stu-id="1f03c-486">RID</span></span>|<span data-ttu-id="1f03c-487">ヒープ内の 1 行をロックするのに使用される行識別子 (ROWID)。</span><span class="sxs-lookup"><span data-stu-id="1f03c-487">A row identifier used to lock a single row within a heap.</span></span>|  
|<span data-ttu-id="1f03c-488">KEY</span><span class="sxs-lookup"><span data-stu-id="1f03c-488">KEY</span></span>|<span data-ttu-id="1f03c-489">シリアル化可能なトランザクションのキー範囲の保護に使用されるインデックス内の行ロック。</span><span class="sxs-lookup"><span data-stu-id="1f03c-489">A row lock within an index used to protect key ranges in serializable transactions.</span></span>|  
|<span data-ttu-id="1f03c-490">PAGE</span><span class="sxs-lookup"><span data-stu-id="1f03c-490">PAGE</span></span>|<span data-ttu-id="1f03c-491">データ ページやインデックス ページなど、データベース内の 8 KB のページ。</span><span class="sxs-lookup"><span data-stu-id="1f03c-491">An 8-kilobyte (KB) page in a database, such as data or index pages.</span></span>|  
|<span data-ttu-id="1f03c-492">EXTENT</span><span class="sxs-lookup"><span data-stu-id="1f03c-492">EXTENT</span></span>|<span data-ttu-id="1f03c-493">データ ページやインデックス ページなど、連続した 8 ページのグループ。</span><span class="sxs-lookup"><span data-stu-id="1f03c-493">A contiguous group of eight pages, such as data or index pages.</span></span>|  
|<span data-ttu-id="1f03c-494">HoBT</span><span class="sxs-lookup"><span data-stu-id="1f03c-494">HoBT</span></span>|<span data-ttu-id="1f03c-495">ヒープまたは B ツリー。</span><span class="sxs-lookup"><span data-stu-id="1f03c-495">A heap or B-tree.</span></span> <span data-ttu-id="1f03c-496">B ツリー (インデックス)、またはクラスター化インデックスのないテーブルのヒープ データ ページを保護するロックです。</span><span class="sxs-lookup"><span data-stu-id="1f03c-496">A lock protecting a B-tree (index) or the heap data pages in a table that does not have a clustered index.</span></span>|  
|<span data-ttu-id="1f03c-497">TABLE</span><span class="sxs-lookup"><span data-stu-id="1f03c-497">TABLE</span></span>|<span data-ttu-id="1f03c-498">すべてのデータとインデックスを含むテーブル全体。</span><span class="sxs-lookup"><span data-stu-id="1f03c-498">The entire table, including all data and indexes.</span></span>|  
|<span data-ttu-id="1f03c-499">FILE</span><span class="sxs-lookup"><span data-stu-id="1f03c-499">FILE</span></span>|<span data-ttu-id="1f03c-500">データベース ファイル。</span><span class="sxs-lookup"><span data-stu-id="1f03c-500">A database file.</span></span>|  
|<span data-ttu-id="1f03c-501">APPLICATION</span><span class="sxs-lookup"><span data-stu-id="1f03c-501">APPLICATION</span></span>|<span data-ttu-id="1f03c-502">アプリケーションにより指定されたリソース。</span><span class="sxs-lookup"><span data-stu-id="1f03c-502">An application-specified resource.</span></span>|  
|<span data-ttu-id="1f03c-503">METADATA</span><span class="sxs-lookup"><span data-stu-id="1f03c-503">METADATA</span></span>|<span data-ttu-id="1f03c-504">メタデータのロック。</span><span class="sxs-lookup"><span data-stu-id="1f03c-504">Metadata locks.</span></span>|  
|<span data-ttu-id="1f03c-505">ALLOCATION_UNIT</span><span class="sxs-lookup"><span data-stu-id="1f03c-505">ALLOCATION_UNIT</span></span>|<span data-ttu-id="1f03c-506">アロケーション ユニット。</span><span class="sxs-lookup"><span data-stu-id="1f03c-506">An allocation unit.</span></span>|  
|<span data-ttu-id="1f03c-507">DATABASE</span><span class="sxs-lookup"><span data-stu-id="1f03c-507">DATABASE</span></span>|<span data-ttu-id="1f03c-508">データベース全体。</span><span class="sxs-lookup"><span data-stu-id="1f03c-508">The entire database.</span></span>|  
  
> [!NOTE]  
>  <span data-ttu-id="1f03c-509">HoBT ロックおよび TABLE ロックは、[ALTER TABLE](/sql/t-sql/statements/alter-table-transact-sql) の LOCK_ESCALATION オプションの影響を受ける可能性があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-509">HoBT and TABLE locks can be affected by the LOCK_ESCALATION option of [ALTER TABLE](/sql/t-sql/statements/alter-table-transact-sql).</span></span>  
  
### <a name="lock-modes"></a><span data-ttu-id="1f03c-510">ロック モード</span><span class="sxs-lookup"><span data-stu-id="1f03c-510">Lock Modes</span></span>  

 <span data-ttu-id="1f03c-511">[!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)]は、さまざまなロック モードを使用してリソースをロックします。これにより、同時に実行されている複数のトランザクションがリソースにアクセスする方法が決まります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-511">The [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] locks resources using different lock modes that determine how the resources can be accessed by concurrent transactions.</span></span>  
  
 <span data-ttu-id="1f03c-512">次の表に、[!INCLUDE[ssDE](../includes/ssde-md.md)]のリソース ロック モードを示します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-512">The following table shows the resource lock modes that the [!INCLUDE[ssDE](../includes/ssde-md.md)] uses.</span></span>  
  
|<span data-ttu-id="1f03c-513">ロック モード</span><span class="sxs-lookup"><span data-stu-id="1f03c-513">Lock mode</span></span>|<span data-ttu-id="1f03c-514">説明</span><span class="sxs-lookup"><span data-stu-id="1f03c-514">Description</span></span>|  
|---------------|-----------------|  
|<span data-ttu-id="1f03c-515">共有 (S)</span><span class="sxs-lookup"><span data-stu-id="1f03c-515">Shared (S)</span></span>|<span data-ttu-id="1f03c-516">SELECT ステートメントなど、データの変更や更新を伴わない読み取り操作で使用します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-516">Used for read operations that do not change or update data, such as a SELECT statement.</span></span>|  
|<span data-ttu-id="1f03c-517">更新 (U)</span><span class="sxs-lookup"><span data-stu-id="1f03c-517">Update (U)</span></span>|<span data-ttu-id="1f03c-518">更新可能なリソースに使用します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-518">Used on resources that can be updated.</span></span> <span data-ttu-id="1f03c-519">複数のセッションがリソースを読み取り、ロックして、後で更新する可能性がある場合に発生する一般的な形式のデッドロックを防ぎます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-519">Prevents a common form of deadlock that occurs when multiple sessions are reading, locking, and potentially updating resources later.</span></span>|  
|<span data-ttu-id="1f03c-520">排他 (X)</span><span class="sxs-lookup"><span data-stu-id="1f03c-520">Exclusive (X)</span></span>|<span data-ttu-id="1f03c-521">INSERT、UPDATE、DELETE などのデータ変更操作に使用します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-521">Used for data-modification operations, such as INSERT, UPDATE, or DELETE.</span></span> <span data-ttu-id="1f03c-522">複数の更新操作により 1 つのリソースを同時に更新しないようにするためのロック モードです。</span><span class="sxs-lookup"><span data-stu-id="1f03c-522">Ensures that multiple updates cannot be made to the same resource at the same time.</span></span>|  
|<span data-ttu-id="1f03c-523">Intent</span><span class="sxs-lookup"><span data-stu-id="1f03c-523">Intent</span></span>|<span data-ttu-id="1f03c-524">ロック階層を設定するのに使用します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-524">Used to establish a lock hierarchy.</span></span> <span data-ttu-id="1f03c-525">インテント ロックの種類にはインテント共有 (IS)、インテント排他 (IX)、およびインテント排他付き共有 (SIX) があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-525">The types of intent locks are: intent shared (IS), intent exclusive (IX), and shared with intent exclusive (SIX).</span></span>|  
|<span data-ttu-id="1f03c-526">スキーマ</span><span class="sxs-lookup"><span data-stu-id="1f03c-526">Schema</span></span>|<span data-ttu-id="1f03c-527">テーブルのスキーマに依存する操作を行うときに使用します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-527">Used when an operation dependent on the schema of a table is executing.</span></span> <span data-ttu-id="1f03c-528">スキーマ ロックの種類には、スキーマ修正 (Sch-M) およびスキーマ安定度 (Sch-S) があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-528">The types of schema locks are: schema modification (Sch-M) and schema stability (Sch-S).</span></span>|  
|<span data-ttu-id="1f03c-529">一括更新 (BU)</span><span class="sxs-lookup"><span data-stu-id="1f03c-529">Bulk Update (BU)</span></span>|<span data-ttu-id="1f03c-530">データを一括でテーブルにコピーするときに **TABLOCK** ヒントを指定して使用します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-530">Used when bulk copying data into a table and the **TABLOCK** hint is specified.</span></span>|  
|<span data-ttu-id="1f03c-531">キー範囲</span><span class="sxs-lookup"><span data-stu-id="1f03c-531">Key-range</span></span>|<span data-ttu-id="1f03c-532">トランザクション分離レベルが SERIALIZABLE のとき、クエリにより読み取られる行の範囲を保護します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-532">Protects the range of rows read by a query when using the serializable transaction isolation level.</span></span> <span data-ttu-id="1f03c-533">シリアル化可能トランザクションのクエリを再度実行した場合に対象となるような行を、他のトランザクションは挿入できなくなります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-533">Ensures that other transactions cannot insert rows that would qualify for the queries of the serializable transaction if the queries were run again.</span></span>|  
  
#### <a name="shared-locks"></a><span data-ttu-id="1f03c-534">共有ロック</span><span class="sxs-lookup"><span data-stu-id="1f03c-534">Shared Locks</span></span>  

 <span data-ttu-id="1f03c-535">共有 (S) ロックを設定すると、同時に実行されている複数のトランザクションがペシミスティック コンカレンシー制御の下でリソースの読み取り (SELECT) を行います。</span><span class="sxs-lookup"><span data-stu-id="1f03c-535">Shared (S) locks allow concurrent transactions to read (SELECT) a resource under pessimistic concurrency control.</span></span> <span data-ttu-id="1f03c-536">他のトランザクションは、リソースに共有 (S) ロックがかけられている間はデータを変更できません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-536">No other transactions can modify the data while shared (S) locks exist on the resource.</span></span> <span data-ttu-id="1f03c-537">リソースにかけられている共有 (S) ロックは、読み取りが完了するとすぐに解除されます。ただし、トランザクションの分離レベルが REPEATABLE READ 以上に設定されている場合や、トランザクションの間、ロック ヒントを使用して共有 (S) ロックを保つ場合を除きます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-537">Shared (S) locks on a resource are released as soon as the read operation completes, unless the transaction isolation level is set to repeatable read or higher, or a locking hint is used to retain the shared (S) locks for the duration of the transaction.</span></span>  
  
#### <a name="update-locks"></a><span data-ttu-id="1f03c-538">更新ロック</span><span class="sxs-lookup"><span data-stu-id="1f03c-538">Update Locks</span></span>  

 <span data-ttu-id="1f03c-539">更新 (U) ロックは、一般的な形式のデッドロックを防ぎます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-539">Update (U) locks prevent a common form of deadlock.</span></span> <span data-ttu-id="1f03c-540">REPEATABLE READ または SERIALIZABLE のトランザクションは、データを読み取るときにリソース (ページまたは行) に共有 (S) ロックをかけます。その後、行を変更しますが、そのときにロックを排他 (X) ロックに変換する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-540">In a repeatable read or serializable transaction, the transaction reads data, acquiring a shared (S) lock on the resource (page or row), and then modifies the data, which requires lock conversion to an exclusive (X) lock.</span></span> <span data-ttu-id="1f03c-541">2 つのトランザクションが 1 つのリソースに対して共有ロックをかけデータを同時に更新する場合、一方のトランザクションは排他 (X) ロックへの変換を試みます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-541">If two transactions acquire shared-mode locks on a resource and then attempt to update data concurrently, one transaction attempts the lock conversion to an exclusive (X) lock.</span></span> <span data-ttu-id="1f03c-542">一方のトランザクションの排他ロックは、もう一方のトランザクションの共有ロックとは両立しないので、共有ロックから排他ロックへの変換が待機状態になります。つまり、ロック待機となります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-542">The shared-mode-to-exclusive lock conversion must wait because the exclusive lock for one transaction is not compatible with the shared-mode lock of the other transaction; a lock wait occurs.</span></span> <span data-ttu-id="1f03c-543">もう一方のトランザクションも更新のために排他 (X) ロックの取得を試みます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-543">The second transaction attempts to acquire an exclusive (X) lock for its update.</span></span> <span data-ttu-id="1f03c-544">この場合、2 つのトランザクションが排他 (X) ロックへの変換を行っており、相手方のトランザクションが共有ロックを解除するのを待っている状態なので、デッドロックが発生します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-544">Because both transactions are converting to exclusive (X) locks, and they are each waiting for the other transaction to release its shared-mode lock, a deadlock occurs.</span></span>  
  
 <span data-ttu-id="1f03c-545">このような潜在的なデッドロックの問題を解決するには、更新 (U) ロックを使用します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-545">To avoid this potential deadlock problem, update (U) locks are used.</span></span> <span data-ttu-id="1f03c-546">更新 (U) ロックでは、1 つのリソースを一度にロックできるトランザクションは、1 つだけです。</span><span class="sxs-lookup"><span data-stu-id="1f03c-546">Only one transaction can obtain an update (U) lock to a resource at a time.</span></span> <span data-ttu-id="1f03c-547">トランザクションがリソースを変更する場合に更新 (U) ロックが排他 (X) ロックに変換されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-547">If a transaction modifies a resource, the update (U) lock is converted to an exclusive (X) lock.</span></span>  
  
#### <a name="exclusive-locks"></a><span data-ttu-id="1f03c-548">排他ロック</span><span class="sxs-lookup"><span data-stu-id="1f03c-548">Exclusive Locks</span></span>  

 <span data-ttu-id="1f03c-549">排他 (X) ロックは、同時に実行されている複数のトランザクションが同じリソースにアクセスすることを防ぎます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-549">Exclusive (X) locks prevent access to a resource by concurrent transactions.</span></span> <span data-ttu-id="1f03c-550">排他 (X) ロックをかけたトランザクション以外はデータを変更できませんが、NOLOCK ヒントまたは READ UNCOMMITTED 分離レベルが指定されている場合に限り、読み取り操作は行うことができます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-550">With an exclusive (X) lock, no other transactions can modify data; read operations can take place only with the use of the NOLOCK hint or read uncommitted isolation level.</span></span>  
  
 <span data-ttu-id="1f03c-551">INSERT、UPDATE、DELETE などのデータ変更ステートメントの中では、変更操作と読み取り操作が組み合わせて使用されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-551">Data modification statements, such as INSERT, UPDATE, and DELETE combine both modification and read operations.</span></span> <span data-ttu-id="1f03c-552">最初に読み取り操作でデータを取得してから、必要な変更操作を実行します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-552">The statement first performs read operations to acquire data before performing the required modification operations.</span></span> <span data-ttu-id="1f03c-553">したがって、一般的にデータ変更ステートメントには共有ロックおよび排他ロックの両方が必要です。</span><span class="sxs-lookup"><span data-stu-id="1f03c-553">Data modification statements, therefore, typically request both shared locks and exclusive locks.</span></span> <span data-ttu-id="1f03c-554">たとえば、UPDATE ステートメントによって、他のテーブルとの結合を基にテーブルの行を変更するとします。</span><span class="sxs-lookup"><span data-stu-id="1f03c-554">For example, an UPDATE statement might modify rows in one table based on a join with another table.</span></span> <span data-ttu-id="1f03c-555">このとき、結合テーブルの読み取る行に対する共有ロックと、更新する行に対する排他ロックが要求されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-555">In this case, the UPDATE statement requests shared locks on the rows read in the join table in addition to requesting exclusive locks on the updated rows.</span></span>  
  
#### <a name="intent-locks"></a><span data-ttu-id="1f03c-556">インテント ロック</span><span class="sxs-lookup"><span data-stu-id="1f03c-556">Intent Locks</span></span>  

 <span data-ttu-id="1f03c-557">[!INCLUDE[ssDE](../includes/ssde-md.md)]ではインテント ロックを使用して、下位のロック階層に位置するリソースに共有 (S) ロックまたは排他 (X) ロックがかかるのを保護します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-557">The [!INCLUDE[ssDE](../includes/ssde-md.md)] uses intent locks to protect placing a shared (S) lock or exclusive (X) lock on a resource lower in the lock hierarchy.</span></span> <span data-ttu-id="1f03c-558">インテント ロックの命名の由来は、ロックのタイミングが下位レベルのロックよりも前であり、下位レベルでロックをかける意図 (intent) を示すためです。</span><span class="sxs-lookup"><span data-stu-id="1f03c-558">Intent locks are named intent locks because they are acquired before a lock at the lower level, and therefore signal intent to place locks at a lower level.</span></span>  
  
 <span data-ttu-id="1f03c-559">インテント ロックの用途は次の 2 つです。</span><span class="sxs-lookup"><span data-stu-id="1f03c-559">Intent locks serve two purposes:</span></span>  
  
-   <span data-ttu-id="1f03c-560">他のトランザクションが上位のリソースを変更することにより下位レベルのロックを無効にしてしまうことを防ぐ。</span><span class="sxs-lookup"><span data-stu-id="1f03c-560">To prevent other transactions from modifying the higher-level resource in a way that would invalidate the lock at the lower level.</span></span>  
  
-   <span data-ttu-id="1f03c-561">[!INCLUDE[ssDE](../includes/ssde-md.md)]によって高い粒度でロックの競合を検出する効率を向上する。</span><span class="sxs-lookup"><span data-stu-id="1f03c-561">To improve the efficiency of the [!INCLUDE[ssDE](../includes/ssde-md.md)] in detecting lock conflicts at the higher level of granularity.</span></span>  
  
 <span data-ttu-id="1f03c-562">たとえば、あるテーブルのページまたは行の共有 (S) ロックを要求する前に、テーブル レベルの共有インテント ロックを要求するとします。</span><span class="sxs-lookup"><span data-stu-id="1f03c-562">For example, a shared intent lock is requested at the table level before shared (S) locks are requested on pages or rows within that table.</span></span> <span data-ttu-id="1f03c-563">テーブル レベルのインテント ロックを設定すると、それ以降、別のトランザクションによってそのページを含むテーブルに排他 (X) ロックがかけられる状態を回避することができます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-563">Setting an intent lock at the table level prevents another transaction from subsequently acquiring an exclusive (X) lock on the table containing that page.</span></span> <span data-ttu-id="1f03c-564">インテント ロックを使用すればパフォーマンスが向上します。[!INCLUDE[ssDE](../includes/ssde-md.md)]では、トランザクションがテーブルに対して安全にロックをかけることができるかどうかを判断する際に、テーブル レベルのインテント ロックを調べるだけで済みます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-564">Intent locks improve performance because the [!INCLUDE[ssDE](../includes/ssde-md.md)] examines intent locks only at the table level to determine if a transaction can safely acquire a lock on that table.</span></span> <span data-ttu-id="1f03c-565">これにより、トランザクションがテーブル全体をロックできるかどうかを判断するために、テーブルの各行や各ページのロックを調べる必要がなくなります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-565">This removes the requirement to examine every row or page lock on the table to determine if a transaction can lock the entire table.</span></span>  
  
 <span data-ttu-id="1f03c-566">インテント ロックにはインテント共有 (IS)、インテント排他 (IX)、およびインテント排他付き共有 (SIX) があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-566">Intent locks include intent shared (IS), intent exclusive (IX), and shared with intent exclusive (SIX).</span></span>  
  
|<span data-ttu-id="1f03c-567">ロック モード</span><span class="sxs-lookup"><span data-stu-id="1f03c-567">Lock mode</span></span>|<span data-ttu-id="1f03c-568">説明</span><span class="sxs-lookup"><span data-stu-id="1f03c-568">Description</span></span>|  
|---------------|-----------------|  
|<span data-ttu-id="1f03c-569">インテント共有 (IS)</span><span class="sxs-lookup"><span data-stu-id="1f03c-569">Intent shared (IS)</span></span>|<span data-ttu-id="1f03c-570">下位の階層に位置するリソースの (すべてではなく) 一部に対し、要求されているかかけられている共有ロックを保護します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-570">Protects requested or acquired shared locks on some (but not all) resources lower in the hierarchy.</span></span>|  
|<span data-ttu-id="1f03c-571">インテント排他 (IX)</span><span class="sxs-lookup"><span data-stu-id="1f03c-571">Intent exclusive (IX)</span></span>|<span data-ttu-id="1f03c-572">下位の階層に位置するリソースの (すべてではなく) 一部に対し、要求されているかかけられている排他ロックを保護します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-572">Protects requested or acquired exclusive locks on some (but not all) resources lower in the hierarchy.</span></span> <span data-ttu-id="1f03c-573">IX は IS のスーパーセットです。また、下位のリソースに対する共有ロックの要求を保護します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-573">IX is a superset of IS, and it also protects requesting shared locks on lower level resources.</span></span>|  
|<span data-ttu-id="1f03c-574">インテント排他付き共有 (SIX)</span><span class="sxs-lookup"><span data-stu-id="1f03c-574">Shared with intent exclusive (SIX)</span></span>|<span data-ttu-id="1f03c-575">下位の階層に位置するすべてのリソースに対し、要求されているかかけられている共有ロックを保護し、下位のリソースの (すべてではなく) 一部のインテント排他ロックを保護します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-575">Protects requested or acquired shared locks on all resources lower in the hierarchy and intent exclusive locks on some (but not all) of the lower level resources.</span></span> <span data-ttu-id="1f03c-576">上位リソースで同時実行している IS ロックは可能です。</span><span class="sxs-lookup"><span data-stu-id="1f03c-576">Concurrent IS locks at the top-level resource are allowed.</span></span> <span data-ttu-id="1f03c-577">たとえば、テーブルに対し SIX ロックをかけると、変更中のページにインテント排他ロックが、変更中の行に排他ロックがかかります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-577">For example, acquiring a SIX lock on a table also acquires intent exclusive locks on the pages being modified and exclusive locks on the modified rows.</span></span> <span data-ttu-id="1f03c-578">1 つのリソースに対しては、一度に 1 つの SIX ロックしかかけられません。その結果、他のトランザクションによってリソースが更新されることはなくなりますが、他のトランザクションはテーブル レベルの IS ロックをかけることで下位のリソースを読み取ることができます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-578">There can be only one SIX lock per resource at one time, preventing updates to the resource made by other transactions, although other transactions can read resources lower in the hierarchy by obtaining IS locks at the table level.</span></span>|  
|<span data-ttu-id="1f03c-579">インテント更新 (IU)</span><span class="sxs-lookup"><span data-stu-id="1f03c-579">Intent update (IU)</span></span>|<span data-ttu-id="1f03c-580">下位の階層に位置するすべてのリソースに対し、要求または取得された更新ロックを保護します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-580">Protects requested or acquired update locks on all resources lower in the hierarchy.</span></span> <span data-ttu-id="1f03c-581">IU ロックはページ リソースに対してのみ使用します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-581">IU locks are used only on page resources.</span></span> <span data-ttu-id="1f03c-582">更新操作が発生すると、IU ロックは IX ロックに変換されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-582">IU locks are converted to IX locks if an update operation takes place.</span></span>|  
|<span data-ttu-id="1f03c-583">共有インテント更新 (SIU)</span><span class="sxs-lookup"><span data-stu-id="1f03c-583">Shared intent update (SIU)</span></span>|<span data-ttu-id="1f03c-584">S ロックと IU ロックを個別にかけるか、同時にかけるかして組み合わせたものです。</span><span class="sxs-lookup"><span data-stu-id="1f03c-584">A combination of S and IU locks, as a result of acquiring these locks separately and simultaneously holding both locks.</span></span> <span data-ttu-id="1f03c-585">たとえば、トランザクションで PAGLOCK ヒントを指定してクエリを実行してから更新操作を実行するとします。</span><span class="sxs-lookup"><span data-stu-id="1f03c-585">For example, a transaction executes a query with the PAGLOCK hint and then executes an update operation.</span></span> <span data-ttu-id="1f03c-586">PAGLOCK ヒントを指定したクエリで S ロックをかけ、更新操作で IU ロックをかけます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-586">The query with the PAGLOCK hint acquires the S lock, and the update operation acquires the IU lock.</span></span>|  
|<span data-ttu-id="1f03c-587">更新インテント排他 (UIX)</span><span class="sxs-lookup"><span data-stu-id="1f03c-587">Update intent exclusive (UIX)</span></span>|<span data-ttu-id="1f03c-588">U ロックと IX ロックを個別にかけるか、同時にかけるかして組み合わせたものです。</span><span class="sxs-lookup"><span data-stu-id="1f03c-588">A combination of U and IX locks, as a result of acquiring these locks separately and simultaneously holding both locks.</span></span>|  
  
#### <a name="schema-locks"></a><span data-ttu-id="1f03c-589">スキーマ ロック</span><span class="sxs-lookup"><span data-stu-id="1f03c-589">Schema Locks</span></span>  

 <span data-ttu-id="1f03c-590">[!INCLUDE[ssDE](../includes/ssde-md.md)]は、テーブルにデータ定義言語 (DDL) 操作 (列の追加やテーブルの削除など) を行うときにスキーマ修正 (Sch-M) ロックを使用します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-590">The [!INCLUDE[ssDE](../includes/ssde-md.md)] uses schema modification (Sch-M) locks during a table data definition language (DDL) operation, such as adding a column or dropping a table.</span></span> <span data-ttu-id="1f03c-591">ロックが保持されている場合、Sch-M ロックはテーブルへの同時アクセスを防ぎます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-591">During the time that it is held, the Sch-M lock prevents concurrent access to the table.</span></span> <span data-ttu-id="1f03c-592">つまり、Sch-M ロックは、ロックが解除されるまで外部からの操作をすべてブロックします。</span><span class="sxs-lookup"><span data-stu-id="1f03c-592">This means the Sch-M lock blocks all outside operations until the lock is released.</span></span>  
  
 <span data-ttu-id="1f03c-593">テーブルの切り捨てなど一部のデータ操作言語 (DML) 操作では、同時操作によって影響を受けるテーブルへのアクセスを防ぐために Sch-M ロックを使用します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-593">Some data manipulation language (DML) operations, such as table truncation, use Sch-M locks to prevent access to affected tables by concurrent operations.</span></span>  
  
 <span data-ttu-id="1f03c-594">[!INCLUDE[ssDE](../includes/ssde-md.md)]は、クエリをコンパイルして実行する際にスキーマ安定度 (Sch-S) ロックを使用します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-594">The [!INCLUDE[ssDE](../includes/ssde-md.md)] uses schema stability (Sch-S) locks when compiling and executing queries.</span></span> <span data-ttu-id="1f03c-595">Sch-S ロックは、排他 (X) ロックを含めて、どのトランザクション ロックもブロックしません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-595">Sch-S locks do not block any transactional locks, including exclusive (X) locks.</span></span> <span data-ttu-id="1f03c-596">したがって、その他のトランザクション (テーブルを X ロックするトランザクションなど) は、クエリのコンパイル中も継続して実行されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-596">Therefore, other transactions, including those with X locks on a table, continue to run while a query is being compiled.</span></span> <span data-ttu-id="1f03c-597">ただし、Sch-M ロックを取得する DDL 同時操作や DML 同時操作をテーブルに対して実行することはできません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-597">However, concurrent DDL operations, and concurrent DML operations that acquire Sch-M locks, cannot be performed on the table.</span></span>  
  
#### <a name="bulk-update-locks"></a><span data-ttu-id="1f03c-598">一括更新ロック</span><span class="sxs-lookup"><span data-stu-id="1f03c-598">Bulk Update Locks</span></span>  

 <span data-ttu-id="1f03c-599">一括更新 (BU) ロックをかけると、同時に複数のスレッドによりデータを同一のテーブルに一括で読み込むことができますが、一括読み込みに参加していない他のプロセスは、その間テーブルにアクセスできません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-599">Bulk update (BU) locks allow multiple threads to bulk load data concurrently into the same table while preventing other processes that are not bulk loading data from accessing the table.</span></span> <span data-ttu-id="1f03c-600">次に示す両方の条件に該当する場合、[!INCLUDE[ssDE](../includes/ssde-md.md)]では一括更新 (BU) ロックが使用されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-600">The [!INCLUDE[ssDE](../includes/ssde-md.md)] uses bulk update (BU) locks when both of the following conditions are true.</span></span>  
  
-   <span data-ttu-id="1f03c-601">Transact-SQL の BULK INSERT ステートメント、OPENROWSET(BULK) 関数、またはいずれかの BULK INSERT API コマンド (.NET の SqlBulkCopy、OLEDB の高速読み込み API、ODBC の一括コピー API など) を使用してテーブルにデータを一括コピーする場合。</span><span class="sxs-lookup"><span data-stu-id="1f03c-601">You use the Transact-SQL BULK INSERT statement, or the OPENROWSET(BULK) function, or you use one of the Bulk Insert API commands such as .NET SqlBulkCopy, OLEDB Fast Load APIs, or the ODBC Bulk Copy APIs to bulk copy data into a table.</span></span>  
  
-   <span data-ttu-id="1f03c-602">**TABLOCK** ヒントを指定した場合または **sp_tableoption** を使用して **table lock on bulk load** テーブル オプションを設定した場合。</span><span class="sxs-lookup"><span data-stu-id="1f03c-602">The **TABLOCK** hint is specified or the **table lock on bulk load** table option is set using **sp_tableoption**.</span></span>  
  
> [!TIP]  
>  <span data-ttu-id="1f03c-603">より制限の少ない一括更新ロックを保持する BULK INSERT ステートメントとは異なり、TABLOCK ヒントが指定された INSERT INTO...SELECT は、テーブルに対する排他的な (X) ロックを保持します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-603">Unlike the BULK INSERT statement, which holds a less restrictive Bulk Update lock, INSERT INTO...SELECT with the TABLOCK hint holds an exclusive (X) lock on the table.</span></span> <span data-ttu-id="1f03c-604">したがって、並列挿入操作を使用して行を挿入することはできません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-604">This means that you cannot insert rows using parallel insert operations.</span></span>  
  
#### <a name="key-range-locks"></a><span data-ttu-id="1f03c-605">キー範囲ロック</span><span class="sxs-lookup"><span data-stu-id="1f03c-605">Key-Range Locks</span></span>  

 <span data-ttu-id="1f03c-606">キー範囲ロックは、SERIALIZABLE トランザクション分離レベルの状態で、[!INCLUDE[tsql](../includes/tsql-md.md)] ステートメントで読み取っているレコード セットに含まれている行の範囲を暗黙的に保護します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-606">Key-range locks protect a range of rows implicitly included in a record set being read by a [!INCLUDE[tsql](../includes/tsql-md.md)] statement while using the serializable transaction isolation level.</span></span> <span data-ttu-id="1f03c-607">キー範囲ロックを使用すると、ファントム読み取りを回避できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-607">Key-range locking prevents phantom reads.</span></span> <span data-ttu-id="1f03c-608">行間のキー範囲を保護することで、トランザクションからアクセスするレコード セットへのファントム挿入やファントム削除も回避されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-608">By protecting the ranges of keys between rows, it also prevents phantom insertions or deletions into a record set accessed by a transaction.</span></span>  
  
### <a name="lock-compatibility"></a><span data-ttu-id="1f03c-609">ロックの互換性</span><span class="sxs-lookup"><span data-stu-id="1f03c-609">Lock Compatibility</span></span>  

 <span data-ttu-id="1f03c-610">ロックの互換性により、複数のトランザクションが同じリソースのロックを同時に獲得できるかどうかが制御されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-610">Lock compatibility controls whether multiple transactions can acquire locks on the same resource at the same time.</span></span> <span data-ttu-id="1f03c-611">リソースが別のトランザクションによって既にロックされている場合、要求されたロックのモードと既存のロックのモードに互換性がある場合のみ、新しいロック要求の許可が可能になります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-611">If a resource is already locked by another transaction, a new lock request can be granted only if the mode of the requested lock is compatible with the mode of the existing lock.</span></span> <span data-ttu-id="1f03c-612">要求されたロックのモードと既存のロックとの互換性がない場合、新しいロックを要求しているトランザクションは、既存のロックが解除されるか、またはロックがタイムアウトするのを待機します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-612">If the mode of the requested lock is not compatible with the existing lock, the transaction requesting the new lock waits for the existing lock to be released or for the lock timeout interval to expire.</span></span> <span data-ttu-id="1f03c-613">たとえば、排他ロックと互換性があるロック モードはありません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-613">For example, no lock modes are compatible with exclusive locks.</span></span> <span data-ttu-id="1f03c-614">排他 (X) ロックが保持されている間は、その排他 (X) ロックが解除されるまで、他のトランザクションはこのリソースに対してどの種類のロック (共有、更新、排他) も獲得できません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-614">While an exclusive (X) lock is held, no other transaction can acquire a lock of any kind (shared, update, or exclusive) on that resource until the exclusive (X) lock is released.</span></span> <span data-ttu-id="1f03c-615">リソースに共有 (S) ロックが適用されている場合は、他のトランザクションもそのアイテムの共有ロックまたは更新 (U) ロックを獲得できます。最初のトランザクションが完了している必要はありません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-615">Alternatively, if a shared (S) lock has been applied to a resource, other transactions can also acquire a shared lock or an update (U) lock on that item even if the first transaction has not completed.</span></span> <span data-ttu-id="1f03c-616">ただし、共有ロックが解除されないと、他のトランザクションは排他ロックを獲得できません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-616">However, other transactions cannot acquire an exclusive lock until the shared lock has been released.</span></span>  
  
 <span data-ttu-id="1f03c-617">次の表に、最も一般的に使用されるロック モードの互換性を示します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-617">The following table shows the compatibility of the most commonly encountered lock modes.</span></span>  
  
||<span data-ttu-id="1f03c-618">既に許可されているモード</span><span class="sxs-lookup"><span data-stu-id="1f03c-618">Existing granted mode</span></span>||||||  
|------|---------------------------|------|------|------|------|------|  
|<span data-ttu-id="1f03c-619">**要求されたモード**</span><span class="sxs-lookup"><span data-stu-id="1f03c-619">**Requested mode**</span></span>|<span data-ttu-id="1f03c-620">**IS**</span><span class="sxs-lookup"><span data-stu-id="1f03c-620">**IS**</span></span>|<span data-ttu-id="1f03c-621">**S**</span><span class="sxs-lookup"><span data-stu-id="1f03c-621">**S**</span></span>|<span data-ttu-id="1f03c-622">**U**</span><span class="sxs-lookup"><span data-stu-id="1f03c-622">**U**</span></span>|<span data-ttu-id="1f03c-623">**IX**</span><span class="sxs-lookup"><span data-stu-id="1f03c-623">**IX**</span></span>|<span data-ttu-id="1f03c-624">**SIX**</span><span class="sxs-lookup"><span data-stu-id="1f03c-624">**SIX**</span></span>|<span data-ttu-id="1f03c-625">**X**</span><span class="sxs-lookup"><span data-stu-id="1f03c-625">**X**</span></span>|  
|<span data-ttu-id="1f03c-626">**インテント共有 (IS)**</span><span class="sxs-lookup"><span data-stu-id="1f03c-626">**Intent shared (IS)**</span></span>|<span data-ttu-id="1f03c-627">はい</span><span class="sxs-lookup"><span data-stu-id="1f03c-627">Yes</span></span>|<span data-ttu-id="1f03c-628">はい</span><span class="sxs-lookup"><span data-stu-id="1f03c-628">Yes</span></span>|<span data-ttu-id="1f03c-629">はい</span><span class="sxs-lookup"><span data-stu-id="1f03c-629">Yes</span></span>|<span data-ttu-id="1f03c-630">はい</span><span class="sxs-lookup"><span data-stu-id="1f03c-630">Yes</span></span>|<span data-ttu-id="1f03c-631">はい</span><span class="sxs-lookup"><span data-stu-id="1f03c-631">Yes</span></span>|<span data-ttu-id="1f03c-632">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-632">No</span></span>|  
|<span data-ttu-id="1f03c-633">**共有 (S)**</span><span class="sxs-lookup"><span data-stu-id="1f03c-633">**Shared (S)**</span></span>|<span data-ttu-id="1f03c-634">はい</span><span class="sxs-lookup"><span data-stu-id="1f03c-634">Yes</span></span>|<span data-ttu-id="1f03c-635">はい</span><span class="sxs-lookup"><span data-stu-id="1f03c-635">Yes</span></span>|<span data-ttu-id="1f03c-636">はい</span><span class="sxs-lookup"><span data-stu-id="1f03c-636">Yes</span></span>|<span data-ttu-id="1f03c-637">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-637">No</span></span>|<span data-ttu-id="1f03c-638">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-638">No</span></span>|<span data-ttu-id="1f03c-639">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-639">No</span></span>|  
|<span data-ttu-id="1f03c-640">**更新 (U)**</span><span class="sxs-lookup"><span data-stu-id="1f03c-640">**Update (U)**</span></span>|<span data-ttu-id="1f03c-641">はい</span><span class="sxs-lookup"><span data-stu-id="1f03c-641">Yes</span></span>|<span data-ttu-id="1f03c-642">はい</span><span class="sxs-lookup"><span data-stu-id="1f03c-642">Yes</span></span>|<span data-ttu-id="1f03c-643">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-643">No</span></span>|<span data-ttu-id="1f03c-644">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-644">No</span></span>|<span data-ttu-id="1f03c-645">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-645">No</span></span>|<span data-ttu-id="1f03c-646">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-646">No</span></span>|  
|<span data-ttu-id="1f03c-647">**インテント排他 (IX)**</span><span class="sxs-lookup"><span data-stu-id="1f03c-647">**Intent exclusive (IX)**</span></span>|<span data-ttu-id="1f03c-648">はい</span><span class="sxs-lookup"><span data-stu-id="1f03c-648">Yes</span></span>|<span data-ttu-id="1f03c-649">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-649">No</span></span>|<span data-ttu-id="1f03c-650">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-650">No</span></span>|<span data-ttu-id="1f03c-651">はい</span><span class="sxs-lookup"><span data-stu-id="1f03c-651">Yes</span></span>|<span data-ttu-id="1f03c-652">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-652">No</span></span>|<span data-ttu-id="1f03c-653">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-653">No</span></span>|  
|<span data-ttu-id="1f03c-654">**インテント排他付き共有 (SIX)**</span><span class="sxs-lookup"><span data-stu-id="1f03c-654">**Shared with intent exclusive (SIX)**</span></span>|<span data-ttu-id="1f03c-655">はい</span><span class="sxs-lookup"><span data-stu-id="1f03c-655">Yes</span></span>|<span data-ttu-id="1f03c-656">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-656">No</span></span>|<span data-ttu-id="1f03c-657">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-657">No</span></span>|<span data-ttu-id="1f03c-658">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-658">No</span></span>|<span data-ttu-id="1f03c-659">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-659">No</span></span>|<span data-ttu-id="1f03c-660">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-660">No</span></span>|  
|<span data-ttu-id="1f03c-661">**排他 (X)**</span><span class="sxs-lookup"><span data-stu-id="1f03c-661">**Exclusive (X)**</span></span>|<span data-ttu-id="1f03c-662">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-662">No</span></span>|<span data-ttu-id="1f03c-663">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-663">No</span></span>|<span data-ttu-id="1f03c-664">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-664">No</span></span>|<span data-ttu-id="1f03c-665">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-665">No</span></span>|<span data-ttu-id="1f03c-666">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-666">No</span></span>|<span data-ttu-id="1f03c-667">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-667">No</span></span>|  
  
> [!NOTE]  
>  <span data-ttu-id="1f03c-668">インテント排他 (IX) はすべての行ではなく一部の行を更新することを指定するものなので、IX ロックは IX ロック モードと互換性があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-668">An intent exclusive (IX) lock is compatible with an IX lock mode because IX means the intention is to update only some of the rows rather than all of them.</span></span> <span data-ttu-id="1f03c-669">一部の行を読み取ったり更新したりする他のトランザクションも、他のトランザクションによって更新されている同じ行でない限り、許可されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-669">Other transactions that attempt to read or update some of the rows are also permitted as long as they are not the same rows being updated by other transactions.</span></span> <span data-ttu-id="1f03c-670">また、2 つのトランザクションが同じ行を更新しようとする場合は、両方のトランザクションにテーブル レベルとページ レベルの IX ロックが許可されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-670">Further, if two transactions attempt to update the same row, both transactions will be granted an IX lock at table and page level.</span></span> <span data-ttu-id="1f03c-671">ただし、行レベルの X ロックは一方のトランザクションに許可されるため、</span><span class="sxs-lookup"><span data-stu-id="1f03c-671">However, one transaction will be granted an X lock at row level.</span></span> <span data-ttu-id="1f03c-672">もう一方のトランザクションは、行レベルのロックが解除されるまで待機する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-672">The other transaction must wait until the row-level lock is removed.</span></span>  
  
 <span data-ttu-id="1f03c-673">次の表を使用すると、[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] で使用できるすべてのロック モードの互換性を確認できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-673">Use the following table to determine the compatibility of all the lock modes available in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span></span>  
  
 <span data-ttu-id="1f03c-674">![ロックの互換性を示す表の図](media/lockconflicttable.gif "ロックの互換性を示す表の図")</span><span class="sxs-lookup"><span data-stu-id="1f03c-674">![Diagram showing lock compatibility matrix](media/lockconflicttable.gif "Diagram showing lock compatibility matrix")</span></span>  
  
### <a name="key-range-locking"></a><span data-ttu-id="1f03c-675">キー範囲ロック</span><span class="sxs-lookup"><span data-stu-id="1f03c-675">Key-Range Locking</span></span>  

 <span data-ttu-id="1f03c-676">キー範囲ロックは、SERIALIZABLE トランザクション分離レベルの状態で、[!INCLUDE[tsql](../includes/tsql-md.md)] ステートメントで読み取っているレコード セットに含まれている行の範囲を暗黙的に保護します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-676">Key-range locks protect a range of rows implicitly included in a record set being read by a [!INCLUDE[tsql](../includes/tsql-md.md)] statement while using the serializable transaction isolation level.</span></span> <span data-ttu-id="1f03c-677">SERIALIZABLE 分離レベルでは、トランザクション中に実行されるクエリは、そのトランザクション内で実行されるたびに同一の行セットを取得する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-677">The serializable isolation level requires that any query executed during a transaction must obtain the same set of rows every time it is executed during the transaction.</span></span> <span data-ttu-id="1f03c-678">キー範囲ロックではこの要件を満たすために、新しい行のキーが SERIALIZABLE トランザクションで読み取られるキー範囲内にある場合に、他のトランザクションが新しい行を挿入できないようにします。</span><span class="sxs-lookup"><span data-stu-id="1f03c-678">A key range lock protects this requirement by preventing other transactions from inserting new rows whose keys would fall in the range of keys read by the serializable transaction.</span></span>  
  
 <span data-ttu-id="1f03c-679">キー範囲ロックを使用すると、ファントム読み取りを回避できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-679">Key-range locking prevents phantom reads.</span></span> <span data-ttu-id="1f03c-680">各行のキー範囲を保護することで、トランザクションからアクセスされるレコード セットへのファントム挿入も回避されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-680">By protecting the ranges of keys between rows, it also prevents phantom insertions into a set of records accessed by a transaction.</span></span>  
  
 <span data-ttu-id="1f03c-681">キー範囲ロックは、キー範囲の開始値と終了値を指定して、インデックスに対して設定されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-681">A key-range lock is placed on an index, specifying a beginning and ending key value.</span></span> <span data-ttu-id="1f03c-682">このロックでは、範囲内のキー値を持つ行を挿入、更新、または削除する操作がブロックされます。挿入操作、更新操作、または削除操作では、最初にインデックスに対するロックを取得する必要があるためです。</span><span class="sxs-lookup"><span data-stu-id="1f03c-682">This lock blocks any attempt to insert, update, or delete any row with a key value that falls in the range because those operations would first have to acquire a lock on the index.</span></span> <span data-ttu-id="1f03c-683">たとえば、シリアル化可能なトランザクションでは、**'** AAA **'** と **'** CZZ **'** の間のキー値を持つすべての行を読み取る SELECT ステートメントを実行できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-683">For example, a serializable transaction could issue a SELECT statement that reads all rows whose key values are between **'** AAA **'** and **'** CZZ **'**.</span></span> <span data-ttu-id="1f03c-684">**'** AAA **'** から **'** CZZ **'** の範囲内のキー値にキー範囲ロックをかけると、他のトランザクションからは **'** ADG **'** 、 **'** BBD **'** 、 **'** CAL **'** など、その範囲内のキー値を持つ行は挿入されません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-684">A key-range lock on the key values in the range from **'** AAA **'** to **'** CZZ **'** prevents other transactions from inserting rows with key values anywhere in that range, such as **'** ADG **'**, **'** BBD **'**, or **'** CAL **'**.</span></span>  
  
#### <a name="key-range-lock-modes"></a><span data-ttu-id="1f03c-685">キー範囲ロック モード</span><span class="sxs-lookup"><span data-stu-id="1f03c-685">Key-Range Lock Modes</span></span>  

 <span data-ttu-id="1f03c-686">キー範囲ロックには、範囲-行形式で指定される範囲と行のコンポーネントが含まれています。</span><span class="sxs-lookup"><span data-stu-id="1f03c-686">Key-range locks include both a range and a row component specified in range-row format:</span></span>  
  
-   <span data-ttu-id="1f03c-687">範囲は 2 つの連続したインデックス エントリ間の範囲を保護するロック モードを表します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-687">Range represents the lock mode protecting the range between two consecutive index entries.</span></span>  
  
-   <span data-ttu-id="1f03c-688">行はインデックス エントリを保護するロック モードを表します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-688">Row represents the lock mode protecting the index entry.</span></span>  
  
-   <span data-ttu-id="1f03c-689">モードは使用する組み合わされたロック モードを表します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-689">Mode represents the combined lock mode used.</span></span> <span data-ttu-id="1f03c-690">キー範囲ロック モードは 2 つの部分から成ります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-690">Key-range lock modes consist of two parts.</span></span> <span data-ttu-id="1f03c-691">最初の部分はインデックス範囲 (Range*T*) をロックするのに使用するロックの種類を表し、その次の部分は特定のキー (*K*) をロックするのに使用するロックの種類を表します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-691">The first represents the type of lock used to lock the index range (Range*T*) and the second represents the lock type used to lock a specific key (*K*).</span></span> <span data-ttu-id="1f03c-692">Range*T*-*K* のように、2 つの部分はハイフン (-) で連結されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-692">The two parts are connected with a hyphen (-), such as Range*T*-*K*.</span></span>  
  
    |<span data-ttu-id="1f03c-693">Range</span><span class="sxs-lookup"><span data-stu-id="1f03c-693">Range</span></span>|<span data-ttu-id="1f03c-694">行</span><span class="sxs-lookup"><span data-stu-id="1f03c-694">Row</span></span>|<span data-ttu-id="1f03c-695">モード</span><span class="sxs-lookup"><span data-stu-id="1f03c-695">Mode</span></span>|<span data-ttu-id="1f03c-696">説明</span><span class="sxs-lookup"><span data-stu-id="1f03c-696">Description</span></span>|  
    |-----------|---------|----------|-----------------|  
    |<span data-ttu-id="1f03c-697">RangeS</span><span class="sxs-lookup"><span data-stu-id="1f03c-697">RangeS</span></span>|<span data-ttu-id="1f03c-698">S</span><span class="sxs-lookup"><span data-stu-id="1f03c-698">S</span></span>|<span data-ttu-id="1f03c-699">RangeS-S</span><span class="sxs-lookup"><span data-stu-id="1f03c-699">RangeS-S</span></span>|<span data-ttu-id="1f03c-700">共有範囲。共有リソース ロック、シリアル化可能範囲スキャン。</span><span class="sxs-lookup"><span data-stu-id="1f03c-700">Shared range, shared resource lock; serializable range scan.</span></span>|  
    |<span data-ttu-id="1f03c-701">RangeS</span><span class="sxs-lookup"><span data-stu-id="1f03c-701">RangeS</span></span>|<span data-ttu-id="1f03c-702">U</span><span class="sxs-lookup"><span data-stu-id="1f03c-702">U</span></span>|<span data-ttu-id="1f03c-703">RangeS-U</span><span class="sxs-lookup"><span data-stu-id="1f03c-703">RangeS-U</span></span>|<span data-ttu-id="1f03c-704">共有範囲。更新リソース ロック。シリアル化可能更新スキャン。</span><span class="sxs-lookup"><span data-stu-id="1f03c-704">Shared range, update resource lock; serializable update scan.</span></span>|  
    |<span data-ttu-id="1f03c-705">RangeI</span><span class="sxs-lookup"><span data-stu-id="1f03c-705">RangeI</span></span>|<span data-ttu-id="1f03c-706">[Null]</span><span class="sxs-lookup"><span data-stu-id="1f03c-706">Null</span></span>|<span data-ttu-id="1f03c-707">RangeI-N</span><span class="sxs-lookup"><span data-stu-id="1f03c-707">RangeI-N</span></span>|<span data-ttu-id="1f03c-708">挿入範囲。NULL リソース ロック。新しいキーをインデックスに挿入する前に範囲をテストするのに使用します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-708">Insert range, null resource lock; used to test ranges before inserting a new key into an index.</span></span>|  
    |<span data-ttu-id="1f03c-709">RangeX</span><span class="sxs-lookup"><span data-stu-id="1f03c-709">RangeX</span></span>|<span data-ttu-id="1f03c-710">X</span><span class="sxs-lookup"><span data-stu-id="1f03c-710">X</span></span>|<span data-ttu-id="1f03c-711">RangeX-X</span><span class="sxs-lookup"><span data-stu-id="1f03c-711">RangeX-X</span></span>|<span data-ttu-id="1f03c-712">排他範囲。排他リソース ロック。範囲内のキーを更新するのに使用します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-712">Exclusive range, exclusive resource lock; used when updating a key in a range.</span></span>|  
  
> [!NOTE]  
>  <span data-ttu-id="1f03c-713">内部 NULL ロック モードは、他のすべてのロック モードと互換性があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-713">The internal Null lock mode is compatible with all other lock modes.</span></span>  
  
 <span data-ttu-id="1f03c-714">各キー範囲ロック モードには、重なり合うキーと範囲に対して取得されるロックが、どのロックと互換性があるかを示す互換性マトリックスがあります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-714">Key-range lock modes have a compatibility matrix that shows which locks are compatible with other locks obtained on overlapping keys and ranges.</span></span>  
  
||<span data-ttu-id="1f03c-715">既に許可されているモード</span><span class="sxs-lookup"><span data-stu-id="1f03c-715">Existing granted mode</span></span>|||||||  
|------|---------------------------|------|------|------|------|------|------|  
|<span data-ttu-id="1f03c-716">**要求されたモード**</span><span class="sxs-lookup"><span data-stu-id="1f03c-716">**Requested mode**</span></span>|<span data-ttu-id="1f03c-717">**S**</span><span class="sxs-lookup"><span data-stu-id="1f03c-717">**S**</span></span>|<span data-ttu-id="1f03c-718">**U**</span><span class="sxs-lookup"><span data-stu-id="1f03c-718">**U**</span></span>|<span data-ttu-id="1f03c-719">**X**</span><span class="sxs-lookup"><span data-stu-id="1f03c-719">**X**</span></span>|<span data-ttu-id="1f03c-720">**RangeS-S**</span><span class="sxs-lookup"><span data-stu-id="1f03c-720">**RangeS-S**</span></span>|<span data-ttu-id="1f03c-721">**RangeS-U**</span><span class="sxs-lookup"><span data-stu-id="1f03c-721">**RangeS-U**</span></span>|<span data-ttu-id="1f03c-722">**RangeI-N**</span><span class="sxs-lookup"><span data-stu-id="1f03c-722">**RangeI-N**</span></span>|<span data-ttu-id="1f03c-723">**RangeX-X**</span><span class="sxs-lookup"><span data-stu-id="1f03c-723">**RangeX-X**</span></span>|  
|<span data-ttu-id="1f03c-724">**共有 (S)**</span><span class="sxs-lookup"><span data-stu-id="1f03c-724">**Shared (S)**</span></span>|<span data-ttu-id="1f03c-725">はい</span><span class="sxs-lookup"><span data-stu-id="1f03c-725">Yes</span></span>|<span data-ttu-id="1f03c-726">はい</span><span class="sxs-lookup"><span data-stu-id="1f03c-726">Yes</span></span>|<span data-ttu-id="1f03c-727">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-727">No</span></span>|<span data-ttu-id="1f03c-728">はい</span><span class="sxs-lookup"><span data-stu-id="1f03c-728">Yes</span></span>|<span data-ttu-id="1f03c-729">はい</span><span class="sxs-lookup"><span data-stu-id="1f03c-729">Yes</span></span>|<span data-ttu-id="1f03c-730">はい</span><span class="sxs-lookup"><span data-stu-id="1f03c-730">Yes</span></span>|<span data-ttu-id="1f03c-731">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-731">No</span></span>|  
|<span data-ttu-id="1f03c-732">**更新 (U)**</span><span class="sxs-lookup"><span data-stu-id="1f03c-732">**Update (U)**</span></span>|<span data-ttu-id="1f03c-733">はい</span><span class="sxs-lookup"><span data-stu-id="1f03c-733">Yes</span></span>|<span data-ttu-id="1f03c-734">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-734">No</span></span>|<span data-ttu-id="1f03c-735">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-735">No</span></span>|<span data-ttu-id="1f03c-736">はい</span><span class="sxs-lookup"><span data-stu-id="1f03c-736">Yes</span></span>|<span data-ttu-id="1f03c-737">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-737">No</span></span>|<span data-ttu-id="1f03c-738">はい</span><span class="sxs-lookup"><span data-stu-id="1f03c-738">Yes</span></span>|<span data-ttu-id="1f03c-739">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-739">No</span></span>|  
|<span data-ttu-id="1f03c-740">**排他 (X)**</span><span class="sxs-lookup"><span data-stu-id="1f03c-740">**Exclusive (X)**</span></span>|<span data-ttu-id="1f03c-741">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-741">No</span></span>|<span data-ttu-id="1f03c-742">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-742">No</span></span>|<span data-ttu-id="1f03c-743">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-743">No</span></span>|<span data-ttu-id="1f03c-744">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-744">No</span></span>|<span data-ttu-id="1f03c-745">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-745">No</span></span>|<span data-ttu-id="1f03c-746">はい</span><span class="sxs-lookup"><span data-stu-id="1f03c-746">Yes</span></span>|<span data-ttu-id="1f03c-747">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-747">No</span></span>|  
|<span data-ttu-id="1f03c-748">**RangeS-S**</span><span class="sxs-lookup"><span data-stu-id="1f03c-748">**RangeS-S**</span></span>|<span data-ttu-id="1f03c-749">はい</span><span class="sxs-lookup"><span data-stu-id="1f03c-749">Yes</span></span>|<span data-ttu-id="1f03c-750">はい</span><span class="sxs-lookup"><span data-stu-id="1f03c-750">Yes</span></span>|<span data-ttu-id="1f03c-751">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-751">No</span></span>|<span data-ttu-id="1f03c-752">はい</span><span class="sxs-lookup"><span data-stu-id="1f03c-752">Yes</span></span>|<span data-ttu-id="1f03c-753">はい</span><span class="sxs-lookup"><span data-stu-id="1f03c-753">Yes</span></span>|<span data-ttu-id="1f03c-754">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-754">No</span></span>|<span data-ttu-id="1f03c-755">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-755">No</span></span>|  
|<span data-ttu-id="1f03c-756">**RangeS-U**</span><span class="sxs-lookup"><span data-stu-id="1f03c-756">**RangeS-U**</span></span>|<span data-ttu-id="1f03c-757">はい</span><span class="sxs-lookup"><span data-stu-id="1f03c-757">Yes</span></span>|<span data-ttu-id="1f03c-758">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-758">No</span></span>|<span data-ttu-id="1f03c-759">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-759">No</span></span>|<span data-ttu-id="1f03c-760">はい</span><span class="sxs-lookup"><span data-stu-id="1f03c-760">Yes</span></span>|<span data-ttu-id="1f03c-761">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-761">No</span></span>|<span data-ttu-id="1f03c-762">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-762">No</span></span>|<span data-ttu-id="1f03c-763">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-763">No</span></span>|  
|<span data-ttu-id="1f03c-764">**RangeI-N**</span><span class="sxs-lookup"><span data-stu-id="1f03c-764">**RangeI-N**</span></span>|<span data-ttu-id="1f03c-765">はい</span><span class="sxs-lookup"><span data-stu-id="1f03c-765">Yes</span></span>|<span data-ttu-id="1f03c-766">はい</span><span class="sxs-lookup"><span data-stu-id="1f03c-766">Yes</span></span>|<span data-ttu-id="1f03c-767">はい</span><span class="sxs-lookup"><span data-stu-id="1f03c-767">Yes</span></span>|<span data-ttu-id="1f03c-768">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-768">No</span></span>|<span data-ttu-id="1f03c-769">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-769">No</span></span>|<span data-ttu-id="1f03c-770">はい</span><span class="sxs-lookup"><span data-stu-id="1f03c-770">Yes</span></span>|<span data-ttu-id="1f03c-771">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-771">No</span></span>|  
|<span data-ttu-id="1f03c-772">**RangeX-X**</span><span class="sxs-lookup"><span data-stu-id="1f03c-772">**RangeX-X**</span></span>|<span data-ttu-id="1f03c-773">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-773">No</span></span>|<span data-ttu-id="1f03c-774">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-774">No</span></span>|<span data-ttu-id="1f03c-775">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-775">No</span></span>|<span data-ttu-id="1f03c-776">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-776">No</span></span>|<span data-ttu-id="1f03c-777">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-777">No</span></span>|<span data-ttu-id="1f03c-778">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-778">No</span></span>|<span data-ttu-id="1f03c-779">いいえ</span><span class="sxs-lookup"><span data-stu-id="1f03c-779">No</span></span>|  
  
#### <a name="conversion-locks"></a><span data-ttu-id="1f03c-780">変換ロック</span><span class="sxs-lookup"><span data-stu-id="1f03c-780">Conversion Locks</span></span>  

 <span data-ttu-id="1f03c-781">変換ロックは、キー範囲ロックが別のロックと重なり合うときに作成されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-781">Conversion locks are created when a key-range lock overlaps another lock.</span></span>  
  
|<span data-ttu-id="1f03c-782">ロック 1</span><span class="sxs-lookup"><span data-stu-id="1f03c-782">Lock 1</span></span>|<span data-ttu-id="1f03c-783">ロック 2</span><span class="sxs-lookup"><span data-stu-id="1f03c-783">Lock 2</span></span>|<span data-ttu-id="1f03c-784">変換ロック</span><span class="sxs-lookup"><span data-stu-id="1f03c-784">Conversion lock</span></span>|  
|------------|------------|---------------------|  
|<span data-ttu-id="1f03c-785">S</span><span class="sxs-lookup"><span data-stu-id="1f03c-785">S</span></span>|<span data-ttu-id="1f03c-786">RangeI-N</span><span class="sxs-lookup"><span data-stu-id="1f03c-786">RangeI-N</span></span>|<span data-ttu-id="1f03c-787">RangeI-S</span><span class="sxs-lookup"><span data-stu-id="1f03c-787">RangeI-S</span></span>|  
|<span data-ttu-id="1f03c-788">U</span><span class="sxs-lookup"><span data-stu-id="1f03c-788">U</span></span>|<span data-ttu-id="1f03c-789">RangeI-N</span><span class="sxs-lookup"><span data-stu-id="1f03c-789">RangeI-N</span></span>|<span data-ttu-id="1f03c-790">RangeI-U</span><span class="sxs-lookup"><span data-stu-id="1f03c-790">RangeI-U</span></span>|  
|<span data-ttu-id="1f03c-791">X</span><span class="sxs-lookup"><span data-stu-id="1f03c-791">X</span></span>|<span data-ttu-id="1f03c-792">RangeI-N</span><span class="sxs-lookup"><span data-stu-id="1f03c-792">RangeI-N</span></span>|<span data-ttu-id="1f03c-793">RangeI-X</span><span class="sxs-lookup"><span data-stu-id="1f03c-793">RangeI-X</span></span>|  
|<span data-ttu-id="1f03c-794">RangeI-N</span><span class="sxs-lookup"><span data-stu-id="1f03c-794">RangeI-N</span></span>|<span data-ttu-id="1f03c-795">RangeS-S</span><span class="sxs-lookup"><span data-stu-id="1f03c-795">RangeS-S</span></span>|<span data-ttu-id="1f03c-796">RangeX-S</span><span class="sxs-lookup"><span data-stu-id="1f03c-796">RangeX-S</span></span>|  
|<span data-ttu-id="1f03c-797">RangeI-N</span><span class="sxs-lookup"><span data-stu-id="1f03c-797">RangeI-N</span></span>|<span data-ttu-id="1f03c-798">RangeS-U</span><span class="sxs-lookup"><span data-stu-id="1f03c-798">RangeS-U</span></span>|<span data-ttu-id="1f03c-799">RangeX-U</span><span class="sxs-lookup"><span data-stu-id="1f03c-799">RangeX-U</span></span>|  
  
 <span data-ttu-id="1f03c-800">変換ロックは、同時実行プロセスを実行しているときなど、さまざまな環境で短時間発生することがあります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-800">Conversion locks can be observed for a short period of time under different complex circumstances, sometimes while running concurrent processes.</span></span>  
  
#### <a name="serializable-range-scan-singleton-fetch-delete-and-insert"></a><span data-ttu-id="1f03c-801">シリアル化可能な範囲スキャン、単一フェッチ、削除、および挿入</span><span class="sxs-lookup"><span data-stu-id="1f03c-801">Serializable Range Scan, Singleton Fetch, Delete, and Insert</span></span>  

 <span data-ttu-id="1f03c-802">キー範囲ロックは、次の操作のシリアル化を保証します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-802">Key-range locking ensures that the following operations are serializable:</span></span>  
  
-   <span data-ttu-id="1f03c-803">範囲スキャン クエリ</span><span class="sxs-lookup"><span data-stu-id="1f03c-803">Range scan query</span></span>  
  
-   <span data-ttu-id="1f03c-804">存在しない行の単一フェッチ</span><span class="sxs-lookup"><span data-stu-id="1f03c-804">Singleton fetch of nonexistent row</span></span>  
  
-   <span data-ttu-id="1f03c-805">削除操作</span><span class="sxs-lookup"><span data-stu-id="1f03c-805">Delete operation</span></span>  
  
-   <span data-ttu-id="1f03c-806">挿入操作</span><span class="sxs-lookup"><span data-stu-id="1f03c-806">Insert operation</span></span>  
  
 <span data-ttu-id="1f03c-807">キー範囲ロックを実行する前に次の条件を満たしておく必要があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-807">Before key-range locking can occur, the following conditions must be satisfied:</span></span>  
  
-   <span data-ttu-id="1f03c-808">トランザクション分離レベルを SERIALIZABLE に設定する。</span><span class="sxs-lookup"><span data-stu-id="1f03c-808">The transaction-isolation level must be set to SERIALIZABLE.</span></span>  
  
-   <span data-ttu-id="1f03c-809">クエリ プロセッサではインデックスを使用して範囲フィルター述語を実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-809">The query processor must use an index to implement the range filter predicate.</span></span> <span data-ttu-id="1f03c-810">たとえば、SELECT ステートメントで WHERE 句を使用すると、述語ColumnX BETWEEN N **'** AAA **'** AND N **'** CZZ **'** を使用して範囲条件を設定できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-810">For example, the WHERE clause in a SELECT statement could establish a range condition with this predicate: ColumnX BETWEEN N **'** AAA **'** AND N **'** CZZ **'**.</span></span> <span data-ttu-id="1f03c-811">**ColumnX** がインデックス キーに含まれている場合、キー範囲ロックだけを取得できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-811">A key-range lock can only be acquired if **ColumnX** is covered by an index key.</span></span>  
  
#### <a name="examples"></a><span data-ttu-id="1f03c-812">例</span><span class="sxs-lookup"><span data-stu-id="1f03c-812">Examples</span></span>  

 <span data-ttu-id="1f03c-813">次のテーブルとインデックスは、この後のキー範囲ロックの例の基準として使用されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-813">The following table and index are used as a basis for the key-range locking examples that follow.</span></span>  
  
 <span data-ttu-id="1f03c-814">![インデックス B-Tree を持つデータベース テーブルの図](media/btree4.gif "インデックス B-Tree を持つデータベース テーブルの図")</span><span class="sxs-lookup"><span data-stu-id="1f03c-814">![Database table with index b-tree illustration](media/btree4.gif "Database table with index b-tree illustration")</span></span>  
  
##### <a name="range-scan-query"></a><span data-ttu-id="1f03c-815">範囲スキャン クエリ</span><span class="sxs-lookup"><span data-stu-id="1f03c-815">Range Scan Query</span></span>  

 <span data-ttu-id="1f03c-816">範囲スキャン クエリを確実にシリアル化するには、同じトランザクション内で同じクエリを実行するたびに同じ結果が返されるようにします。</span><span class="sxs-lookup"><span data-stu-id="1f03c-816">To ensure a range scan query is serializable, the same query should return the same results each time it is executed within the same transaction.</span></span> <span data-ttu-id="1f03c-817">他のトランザクションによる範囲スキャン クエリ内に新しい行を挿入しないでください。これはファントム挿入になります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-817">New rows must not be inserted within the range scan query by other transactions; otherwise, these become phantom inserts.</span></span> <span data-ttu-id="1f03c-818">たとえば、上の図のテーブルとインデックスを使用する次のクエリについて考えます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-818">For example, the following query uses the table and index in the previous illustration:</span></span>  
  
```sql  
SELECT name  
    FROM mytable  
    WHERE name BETWEEN 'A' AND 'C';  
```  
  
 <span data-ttu-id="1f03c-819">名前が Adam と Dale の間に含まれるデータ行の範囲に対応するインデックス エントリにキー範囲ロックを設定し、上のクエリで指定した範囲内に新しい行を追加、削除することを禁止します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-819">Key-range locks are placed on the index entries corresponding to the range of data rows where the name is between the values Adam and Dale, preventing new rows qualifying in the previous query from being added or deleted.</span></span> <span data-ttu-id="1f03c-820">この範囲の最初の名前は Adam ですが、このインデックス エントリに対する RangeS-S モードのキー範囲ロックによって、Abigail など英字 A で始まる新しい名前を Adam の前に追加することが禁止されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-820">Although the first name in this range is Adam, the RangeS-S mode key-range lock on this index entry ensures that no new names beginning with the letter A can be added before Adam, such as Abigail.</span></span> <span data-ttu-id="1f03c-821">同様に、インデックス エントリ Dale に対する RangeS-S キー範囲ロックによって、Clive など英字 C で始まる新しい名前を Carlos の後に追加することが禁止されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-821">Similarly, the RangeS-S key-range lock on the index entry for Dale ensures that no new names beginning with the letter C can be added after Carlos, such as Clive.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="1f03c-822">保持される RangeS-S ロック数は *n* + 1 個です。*n* はクエリに該当する行数です。</span><span class="sxs-lookup"><span data-stu-id="1f03c-822">The number of RangeS-S locks held is *n*+1, where *n* is the number of rows that satisfy the query.</span></span>  
  
##### <a name="singleton-fetch-of-nonexistent-data"></a><span data-ttu-id="1f03c-823">存在しないデータの単一フェッチ</span><span class="sxs-lookup"><span data-stu-id="1f03c-823">Singleton Fetch of Nonexistent Data</span></span>  

 <span data-ttu-id="1f03c-824">トランザクション内のクエリで存在しない行を選択しようとする場合、同じトランザクション内で再度そのクエリを実行しても、同じ結果を返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-824">If a query within a transaction attempts to select a row that does not exist, issuing the query at a later point within the same transaction has to return the same result.</span></span> <span data-ttu-id="1f03c-825">どのトランザクションも、存在しない行を追加することはできません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-825">No other transaction can be allowed to insert that nonexistent row.</span></span> <span data-ttu-id="1f03c-826">たとえば、次のクエリについて考えてみます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-826">For example, given this query:</span></span>  
  
```sql 
SELECT name  
    FROM mytable  
    WHERE name = 'Bill';  
```  
  
 <span data-ttu-id="1f03c-827">名前 `Ben` は隣接するインデックス エントリである `Bing` と `Bill` の間に挿入されるため、この名前範囲に対応するインデックス エントリにキー範囲ロックが設定されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-827">A key-range lock is placed on the index entry corresponding to the name range from `Ben` to `Bing` because the name `Bill` would be inserted between these two adjacent index entries.</span></span> <span data-ttu-id="1f03c-828">RangeS-S モードのキー範囲ロックは、インデックス エントリ `Bing` に設定されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-828">The RangeS-S mode key-range lock is placed on the index entry `Bing`.</span></span> <span data-ttu-id="1f03c-829">これにより、`Bill` などの値がインデックス エントリの `Ben` と `Bing` の間に挿入されるのを防ぎます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-829">This prevents any other transaction from inserting values, such as `Bill`, between the index entries `Ben` and `Bing`.</span></span>  
  
##### <a name="delete-operation"></a><span data-ttu-id="1f03c-830">削除操作。</span><span class="sxs-lookup"><span data-stu-id="1f03c-830">Delete Operation</span></span>  

 <span data-ttu-id="1f03c-831">トランザクション内で値を削除する場合、削除処理を実行するトランザクションの間、値が存在する範囲をロックする必要はありません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-831">When deleting a value within a transaction, the range the value falls into does not have to be locked for the duration of the transaction performing the delete operation.</span></span> <span data-ttu-id="1f03c-832">シリアル化可能性を維持するには、削除するキー値をトランザクションの終了時までロックするだけで十分です。</span><span class="sxs-lookup"><span data-stu-id="1f03c-832">Locking the deleted key value until the end of the transaction is sufficient to maintain serializability.</span></span> <span data-ttu-id="1f03c-833">たとえば、次の DELETE ステートメントについて考えてみます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-833">For example, given this DELETE statement:</span></span>  
  
```sql  
DELETE mytable  
    WHERE name = 'Bob';  
```  
  
 <span data-ttu-id="1f03c-834">`Bob` に対応するインデックス エントリに排他 (X) ロックを設定します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-834">An exclusive (X) lock is placed on the index entry corresponding to the name `Bob`.</span></span> <span data-ttu-id="1f03c-835">他のトランザクションは、削除する値 `Bob` の前後に値を挿入したり、削除することができます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-835">Other transactions can insert or delete values before or after the deleted value `Bob`.</span></span> <span data-ttu-id="1f03c-836">ただし、値 `Bob` の読み取り、挿入、または削除を試みるトランザクションは、削除を実行中のトランザクションがコミットまたはロールバックするまでブロックされます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-836">However, any transaction that attempts to read, insert, or delete the value `Bob` will be blocked until the deleting transaction either commits or rolls back.</span></span>  
  
 <span data-ttu-id="1f03c-837">範囲削除は、行ロック、ページ ロック、またはテーブル ロックの 3 つの基本的なロック モードを使用して実行できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-837">Range delete can be executed using three basic lock modes: row, page, or table lock.</span></span> <span data-ttu-id="1f03c-838">そのうちどのモードを使用するかは、クエリ オプティマイザーにより決定されるか、または ROWLOCK、PAGLOCK、TABLOCK などのオプティマイザー ヒントによってユーザーが指定できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-838">The row, page, or table locking strategy is decided by query optimizer or can be specified by the user through optimizer hints such as ROWLOCK, PAGLOCK, or TABLOCK.</span></span> <span data-ttu-id="1f03c-839">PAGLOCK または TABLOCK を使用した場合、すべての行をインデックス ページから削除すると、[!INCLUDE[ssDE](../includes/ssde-md.md)]によりすぐにインデックス ページの割り当てが解除されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-839">When PAGLOCK or TABLOCK is used, the [!INCLUDE[ssDE](../includes/ssde-md.md)] immediately deallocates an index page if all rows are deleted from this page.</span></span> <span data-ttu-id="1f03c-840">対照的に、ROWLOCK を使用する場合、削除対象のすべての行には削除のマークが付けられるだけです。これらは、後でバックグラウンド タスクによってインデックス ページから削除されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-840">In contrast, when ROWLOCK is used, all deleted rows are marked only as deleted; they are removed from the index page later using a background task.</span></span>  
  
##### <a name="insert-operation"></a><span data-ttu-id="1f03c-841">挿入操作</span><span class="sxs-lookup"><span data-stu-id="1f03c-841">Insert Operation</span></span>  

 <span data-ttu-id="1f03c-842">トランザクション内で値を挿入する場合、挿入処理を行うトランザクションの実行中、その値が含まれている範囲をロックする必要はありません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-842">When inserting a value within a transaction, the range the value falls into does not have to be locked for the duration of the transaction performing the insert operation.</span></span> <span data-ttu-id="1f03c-843">シリアル化可能性を維持するには、挿入するキー値をトランザクションの終了時までロックするだけで十分です。</span><span class="sxs-lookup"><span data-stu-id="1f03c-843">Locking the inserted key value until the end of the transaction is sufficient to maintain serializability.</span></span> <span data-ttu-id="1f03c-844">たとえば、次の INSERT ステートメントについて考えてみます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-844">For example, given this INSERT statement:</span></span>  
  
```sql  
INSERT mytable VALUES ('Dan');  
```  
  
 <span data-ttu-id="1f03c-845">範囲をテストするために、David という名前に対応するインデックス エントリに RangeI-N モードのキー範囲ロックを設定します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-845">The RangeI-N mode key-range lock is placed on the index entry corresponding to the name David to test the range.</span></span> <span data-ttu-id="1f03c-846">ロックが許可されると、`Dan` が挿入され、値 `Dan` に排他 (X) ロックが設定されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-846">If the lock is granted, `Dan` is inserted and an exclusive (X) lock is placed on the value `Dan`.</span></span> <span data-ttu-id="1f03c-847">RangeI-N モードのキー範囲ロックは範囲のテストだけに必要で、挿入処理を行うトランザクションの実行中は保持されません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-847">The RangeI-N mode key-range lock is necessary only to test the range and is not held for the duration of the transaction performing the insert operation.</span></span> <span data-ttu-id="1f03c-848">他のトランザクションは、挿入する値 `Dan` の前後に値を挿入したり、前後の値を削除できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-848">Other transactions can insert or delete values before or after the inserted value `Dan`.</span></span> <span data-ttu-id="1f03c-849">ただし、値 `Dan` の読み取り、挿入、または削除を試みるトランザクションは、挿入を実行中のトランザクションがコミットまたはロールバックするまでロックされます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-849">However, any transaction attempting to read, insert, or delete the value `Dan` will be locked until the inserting transaction either commits or rolls back.</span></span>  
  
### <a name="dynamic-locking"></a><span data-ttu-id="1f03c-850">動的ロック</span><span class="sxs-lookup"><span data-stu-id="1f03c-850">Dynamic Locking</span></span>  

 <span data-ttu-id="1f03c-851">行ロックなど、レベルの低いロックを使用すると、2 つのトランザクションが同時にデータの同じ部分に対するロックを要求する可能性が減ってコンカレンシーが高まります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-851">Using low-level locks, such as row locks, increases concurrency by decreasing the probability that two transactions will request locks on the same piece of data at the same time.</span></span> <span data-ttu-id="1f03c-852">同時に、ロックの数も増えるので、ロックを管理するために多くのリソースが必要になります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-852">Using low-level locks also increases the number of locks and the resources needed to manage them.</span></span> <span data-ttu-id="1f03c-853">テーブルまたはページに対する高レベルのロックはオーバーヘッドが減りますが、コンカレンシーは低下します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-853">Using high-level table or page locks lowers overhead, but at the expense of lowering concurrency.</span></span>  
  
 <span data-ttu-id="1f03c-854">![コストと粒度を示す図](media/lockcht.gif "コストと粒度を示す図")</span><span class="sxs-lookup"><span data-stu-id="1f03c-854">![Diagram showing cost versus granularity](media/lockcht.gif "Diagram showing cost versus granularity")</span></span>  
  
 <span data-ttu-id="1f03c-855">[!INCLUDE[msCoName](../includes/msconame-md.md)] [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] は、動的ロック ストラテジによって最もコストの低いロックを判断します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-855">The [!INCLUDE[msCoName](../includes/msconame-md.md)] [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] uses a dynamic locking strategy to determine the most cost-effective locks.</span></span> <span data-ttu-id="1f03c-856">[!INCLUDE[ssDE](../includes/ssde-md.md)]はクエリを実行する際に、スキーマおよびクエリの特性に基づいて最適なロックを自動的に判断します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-856">The [!INCLUDE[ssDE](../includes/ssde-md.md)] automatically determines what locks are most appropriate when the query is executed, based on the characteristics of the schema and query.</span></span> <span data-ttu-id="1f03c-857">たとえば、インデックス スキャンの実行時に、インデックス内でのページレベルのロックが選択されます。これにより、ロックのオーバーヘッドを減少させることができます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-857">For example, to reduce the overhead of locking, the optimizer may choose page-level locks in an index when performing an index scan.</span></span>  
  
 <span data-ttu-id="1f03c-858">動的ロックには次の利点があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-858">Dynamic locking has the following advantages:</span></span>  
  
-   <span data-ttu-id="1f03c-859">データベースの管理が簡略化されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-859">Simplified database administration.</span></span> <span data-ttu-id="1f03c-860">データベース管理者がロック エスカレーションのしきい値を調整する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-860">Database administrators do not have to adjust lock escalation thresholds.</span></span>  
  
-   <span data-ttu-id="1f03c-861">パフォーマンスが高まります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-861">Increased performance.</span></span> <span data-ttu-id="1f03c-862">[!INCLUDE[ssDE](../includes/ssde-md.md)]によりタスクに適したロックが使用されるので、システム オーバーヘッドが最小になります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-862">The [!INCLUDE[ssDE](../includes/ssde-md.md)] minimizes system overhead by using locks appropriate to the task.</span></span>  
  
-   <span data-ttu-id="1f03c-863">アプリケーション開発者が開発に専念できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-863">Application developers can concentrate on development.</span></span> <span data-ttu-id="1f03c-864">ロックは[!INCLUDE[ssDE](../includes/ssde-md.md)]により自動的に調整されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-864">The [!INCLUDE[ssDE](../includes/ssde-md.md)] adjusts locking automatically.</span></span>  
  
 <span data-ttu-id="1f03c-865">[!INCLUDE[ssKatmai](../includes/sskatmai-md.md)]以降のバージョンでは、LOCK_ESCALATION オプションの導入により、ロックのエスカレーションの動作が変更されました。</span><span class="sxs-lookup"><span data-stu-id="1f03c-865">In [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] and later versions, the behavior of lock escalation has changed with the introduction of the LOCK_ESCALATION option.</span></span> <span data-ttu-id="1f03c-866">詳細については、「 [ALTER TABLE](/sql/t-sql/statements/alter-table-transact-sql)の LOCK_ESCALATION オプション」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1f03c-866">For more information, see the LOCK_ESCALATION option of [ALTER TABLE](/sql/t-sql/statements/alter-table-transact-sql).</span></span>  
  
### <a name="deadlocking"></a><span data-ttu-id="1f03c-867">デッドロック</span><span class="sxs-lookup"><span data-stu-id="1f03c-867">Deadlocking</span></span>  

 <span data-ttu-id="1f03c-868">デッドロックは、複数のタスクが永続的に相互ブロックすることで発生します。つまり、一方のタスクがロックを試みているリソースに他方のタスクがロックを獲得していて、これが相互に行われるとデッドロックが発生します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-868">A deadlock occurs when two or more tasks permanently block each other by each task having a lock on a resource which the other tasks are trying to lock.</span></span> <span data-ttu-id="1f03c-869">次に例を示します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-869">For example:</span></span>  
  
-   <span data-ttu-id="1f03c-870">トランザクション A が行 1 の共有ロックを取得します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-870">Transaction A acquires a share lock on row 1.</span></span>  
  
-   <span data-ttu-id="1f03c-871">トランザクション B が行 2 の共有ロックを取得します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-871">Transaction B acquires a share lock on row 2.</span></span>  
  
-   <span data-ttu-id="1f03c-872">トランザクション A が行 2 の排他ロックを要求しますが、トランザクション B が完了し、B が保持している行 2 の共有ロックが解放されるまで A はブロックされます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-872">Transaction A now requests an exclusive lock on row 2, and is blocked until transaction B finishes and releases the share lock it has on row 2.</span></span>  
  
-   <span data-ttu-id="1f03c-873">このとき、トランザクション B が行 1 の排他ロックを要求すると、トランザクション A が完了し、A が保持している行 1 の共有ロックが解放されるまで B はブロックされます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-873">Transaction B now requests an exclusive lock on row 1, and is blocked until transaction A finishes and releases the share lock it has on row 1.</span></span>  
  
 <span data-ttu-id="1f03c-874">トランザクション A は、トランザクション B が完了するまで完了できませんが、トランザクション B もトランザクション A によってブロックされます。この状態は、循環依存関係とも呼ばれます。トランザクション A がトランザクション B に依存し、トランザクション B がトランザクション A に依存するため、依存関係が循環します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-874">Transaction A cannot complete until transaction B completes, but transaction B is blocked by transaction A. This condition is also called a cyclic dependency: Transaction A has a dependency on transaction B, and transaction B closes the circle by having a dependency on transaction A.</span></span>  
  
 <span data-ttu-id="1f03c-875">デッドロックになったどちらのトランザクションも、外部処理からデッドロックを解除されない限り、永久的に待機を続けます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-875">Both transactions in a deadlock will wait forever unless the deadlock is broken by an external process.</span></span> <span data-ttu-id="1f03c-876">[!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)]のデッドロック モニターでは、デッドロックになったタスクがあるかどうかの確認が定期的に行われます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-876">The [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] deadlock monitor periodically checks for tasks that are in a deadlock.</span></span> <span data-ttu-id="1f03c-877">モニターによって循環依存関係が検出されると、一方のタスクがデッドロックの犠牲者として選択され、そのトランザクションはエラーで終了されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-877">If the monitor detects a cyclic dependency, it chooses one of the tasks as a victim and terminates its transaction with an error.</span></span> <span data-ttu-id="1f03c-878">その結果、もう一方のタスクのトランザクションを完了できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-878">This allows the other task to complete its transaction.</span></span> <span data-ttu-id="1f03c-879">トランザクションがエラーで終了したアプリケーションは、そのトランザクションを再試行できます。通常は、デッドロックの一方のトランザクションが完了してからこのトランザクションも完了します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-879">The application with the transaction that terminated with an error can retry the transaction, which usually completes after the other deadlocked transaction has finished.</span></span>  
  
 <span data-ttu-id="1f03c-880">デッドロックが、通常のブロッキングと混同されることがあります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-880">Deadlocking is often confused with normal blocking.</span></span> <span data-ttu-id="1f03c-881">あるトランザクションが、別のトランザクションによってロックされているリソースのロックを要求すると、ロックを要求したトランザクションはロックが解放されるまで待機します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-881">When a transaction requests a lock on a resource locked by another transaction, the requesting transaction waits until the lock is released.</span></span> <span data-ttu-id="1f03c-882">既定では、LOCK_TIMEOUT を設定しない限り、[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] のトランザクションはタイムアウトになりません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-882">By default, [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] transactions do not time out, unless LOCK_TIMEOUT is set.</span></span> <span data-ttu-id="1f03c-883">この場合、ロックを要求したトランザクションはブロックされているだけで、デッドロックが発生しているわけではありません。つまり、ロックを要求したトランザクションは、ロックを所有しているトランザクションをブロックする操作を行っていません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-883">The requesting transaction is blocked, not deadlocked, because the requesting transaction has not done anything to block the transaction owning the lock.</span></span> <span data-ttu-id="1f03c-884">最終的には、ロックを所有しているトランザクションが完了してロックが解放され、ロックを要求したトランザクションがロックを取得し、続行されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-884">Eventually, the owning transaction will complete and release the lock, and then the requesting transaction will be granted the lock and proceed.</span></span>  
  
 <span data-ttu-id="1f03c-885">デッドロックは、「破壊的な支配」と呼ばれることもあります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-885">Deadlocks are sometimes called a deadly embrace.</span></span>  
  
 <span data-ttu-id="1f03c-886">デッドロックの状態は、リレーショナル データベース管理システムだけでなく、複数のスレッドを使用していれば、どのようなシステムでも発生する可能性があります。また、データベース オブジェクトのロック以外でも発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-886">Deadlock is a condition that can occur on any system with multiple threads, not just on a relational database management system, and can occur for resources other than locks on database objects.</span></span> <span data-ttu-id="1f03c-887">たとえば、マルチスレッド オペレーティング システムの 1 つのスレッドが、メモリのブロックなど、1 つ以上のリソースを取得するとします。</span><span class="sxs-lookup"><span data-stu-id="1f03c-887">For example, a thread in a multithreaded operating system might acquire one or more resources, such as blocks of memory.</span></span> <span data-ttu-id="1f03c-888">取得しようとしているリソースが別のスレッドに所有されている場合、最初のスレッドはリソースを所有しているスレッドがそのリソースを解放するまで待機することになります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-888">If the resource being acquired is currently owned by another thread, the first thread may have to wait for the owning thread to release the target resource.</span></span> <span data-ttu-id="1f03c-889">このとき、待機しているスレッドのことを「そのリソースについて、所有側のスレッドに対する依存関係がある」といいます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-889">The waiting thread is said to have a dependency on the owning thread for that particular resource.</span></span> <span data-ttu-id="1f03c-890">[!INCLUDE[ssDE](../includes/ssde-md.md)]のインスタンスでは、メモリやスレッドなど、データベース以外のリソースを取得するときにデッドロックが発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-890">In an instance of the [!INCLUDE[ssDE](../includes/ssde-md.md)], sessions can deadlock when acquiring nondatabase resources, such as memory or threads.</span></span>  
  
 <span data-ttu-id="1f03c-891">![トランザクションのデッドロックを示す図](media/dedlck1.gif "トランザクションのデッドロックを示す図")</span><span class="sxs-lookup"><span data-stu-id="1f03c-891">![Diagram showing transaction deadlock](media/dedlck1.gif "Diagram showing transaction deadlock")</span></span>  
  
 <span data-ttu-id="1f03c-892">この例では、トランザクション T1 は **Part** テーブルのロック リソースに関して、トランザクション T2 に依存関係があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-892">In the illustration, transaction T1 has a dependency on transaction T2 for the **Part** table lock resource.</span></span> <span data-ttu-id="1f03c-893">同様に、**Supplier** テーブルのロック リソースに関しては、トランザクション T2 がトランザクション T1 に対する依存関係を持っています。</span><span class="sxs-lookup"><span data-stu-id="1f03c-893">Similarly, transaction T2 has a dependency on transaction T1 for the **Supplier** table lock resource.</span></span> <span data-ttu-id="1f03c-894">これらの依存関係は相互に働くため、トランザクション T1 と T2 の間でデッドロックが発生します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-894">Because these dependencies form a cycle, there is a deadlock between transactions T1 and T2.</span></span>  
  
 <span data-ttu-id="1f03c-895">デッドロックは、テーブルがパーティション分割されており、ALTER TABLE の LOCK_ESCALATION 設定が AUTO に設定されている場合にも発生することがあります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-895">Deadlocks can also occur when a table is partitioned and the LOCK_ESCALATION setting of ALTER TABLE is set to AUTO.</span></span> <span data-ttu-id="1f03c-896">LOCK_ESCALATION が AUTO に設定されている場合、がテーブル [!INCLUDE[ssDE](../includes/ssde-md.md)] レベルではなく HoBT レベルでテーブルパーティションをロックできるようにすることで、同時実行性が向上します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-896">When LOCK_ESCALATION is set to AUTO, concurrency increases by allowing the [!INCLUDE[ssDE](../includes/ssde-md.md)] to lock table partitions at the HoBT level instead of at the TABLE level.</span></span> <span data-ttu-id="1f03c-897">ただし、個々のトランザクションがテーブルのパーティション ロックを保持し、他のトランザクション パーティションのどこかをロックする必要がある場合、デッドロックが発生します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-897">However, when separate transactions hold partition locks in a table and want a lock somewhere on the other transactions partition, this causes a deadlock.</span></span> <span data-ttu-id="1f03c-898">このタイプのデッドロックは、LOCK_ESCALATION を TABLE に設定することで回避できますが、この設定を行うと、パーティションに対して大規模な更新を行う際にテーブル ロックを獲得するまで待機しなければならなくなるため、コンカレンシーが低下します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-898">This type of deadlock can be avoided by setting LOCK_ESCALATION to TABLE; although this setting will reduce concurrency by forcing large updates to a partition to wait for a table lock.</span></span>  
  
#### <a name="detecting-and-ending-deadlocks"></a><span data-ttu-id="1f03c-899">デッドロックの検出と終了</span><span class="sxs-lookup"><span data-stu-id="1f03c-899">Detecting and Ending Deadlocks</span></span>  

 <span data-ttu-id="1f03c-900">デッドロックは、複数のタスクが永続的に相互ブロックすることで発生します。つまり、一方のタスクがロックを試みているリソースに他方のタスクがロックを獲得していて、これが相互に行われるとデッドロックが発生します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-900">A deadlock occurs when two or more tasks permanently block each other by each task having a lock on a resource which the other tasks are trying to lock.</span></span> <span data-ttu-id="1f03c-901">次の図に、デッドロック状態の概要を示します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-901">The following graph presents a high level view of a deadlock state where:</span></span>  
  
-   <span data-ttu-id="1f03c-902">タスク T1 は、リソース R1 のロックを所有し (R1 から T1 への矢印で表しています)、リソース R2 のロックを要求しました (T1 から R2 への矢印で表しています)。</span><span class="sxs-lookup"><span data-stu-id="1f03c-902">Task T1 has a lock on resource R1 (indicated by the arrow from R1 to T1) and has requested a lock on resource R2 (indicated by the arrow from T1 to R2).</span></span>  
  
-   <span data-ttu-id="1f03c-903">タスク T2 は、リソース R2 のロックを所有し (R2 から T2 への矢印で表しています)、リソース R1 のロックを要求しました (T2 から R1 への矢印で表しています)。</span><span class="sxs-lookup"><span data-stu-id="1f03c-903">Task T2 has a lock on resource R2 (indicated by the arrow from R2 to T2) and has requested a lock on resource R1 (indicated by the arrow from T2 to R1).</span></span>  
  
-   <span data-ttu-id="1f03c-904">どちらのタスクもリソースが使用できるようになるまで続行できず、どちらのリソースもタスクが続行するまで解放できないため、デッドロック状態が発生します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-904">Because neither task can continue until a resource is available and neither resource can be released until a task continues, a deadlock state exists.</span></span>  
  
 <span data-ttu-id="1f03c-905">![デッドロック状態のタスクを示す図](media/task-deadlock-state.gif "デッドロック状態のタスクを示す図")</span><span class="sxs-lookup"><span data-stu-id="1f03c-905">![Diagram showing tasks in a deadlock state](media/task-deadlock-state.gif "Diagram showing tasks in a deadlock state")</span></span>  
  
 <span data-ttu-id="1f03c-906">[!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)]は、[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] 内のデッドロック サイクルを自動的に検出します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-906">The [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] automatically detects deadlock cycles within [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="1f03c-907">[!INCLUDE[ssDE](../includes/ssde-md.md)]がセッションの 1 つをデッドロックの対象として選択すると、現在のトランザクションはエラーで終了し、デッドロックが解除されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-907">The [!INCLUDE[ssDE](../includes/ssde-md.md)] chooses one of the sessions as a deadlock victim and the current transaction is terminated with an error to break the deadlock.</span></span>  
  
##### <a name="resources-that-can-deadlock"></a><span data-ttu-id="1f03c-908">デッドロックの原因となるリソース</span><span class="sxs-lookup"><span data-stu-id="1f03c-908">Resources That Can Deadlock</span></span>  

 <span data-ttu-id="1f03c-909">各ユーザー セッションに含まれている 1 つ以上のタスクが、そのセッションのためにさまざまなリソースを取得したり、リソースを取得するために待機状態にある場合があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-909">Each user session might have one or more tasks running on its behalf where each task might acquire or wait to acquire a variety of resources.</span></span> <span data-ttu-id="1f03c-910">次のような種類のリソースは、デッドロックの原因となるブロッキングを発生させる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-910">The following types of resources can cause blocking that could result in a deadlock.</span></span>  
  
-   <span data-ttu-id="1f03c-911">**ロック**.</span><span class="sxs-lookup"><span data-stu-id="1f03c-911">**Locks**.</span></span> <span data-ttu-id="1f03c-912">オブジェクト、ページ、行、メタデータ、およびアプリケーションなどのリソースに対してロック取得のために待機していると、デッドロックが発生する場合があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-912">Waiting to acquire locks on resources, such as objects, pages, rows, metadata, and applications can cause deadlock.</span></span> <span data-ttu-id="1f03c-913">たとえば、トランザクション T1 では、行 r1 の共有 (S) ロックを所有しており、r2 に排他 (X) ロックがかかるのを待機しているとします。</span><span class="sxs-lookup"><span data-stu-id="1f03c-913">For example, transaction T1 has a shared (S) lock on row r1 and is waiting to get an exclusive (X) lock on r2.</span></span> <span data-ttu-id="1f03c-914">トランザクション T2 では、r2 の共有 (S) ロックを所有しており、行 r1 に排他 (X) ロックがかかるのを待機しているとします。</span><span class="sxs-lookup"><span data-stu-id="1f03c-914">Transaction T2 has a shared (S) lock on r2 and is waiting to get an exclusive (X) lock on row r1.</span></span> <span data-ttu-id="1f03c-915">この結果、T1 と T2 では、互いにロックされているリソースが解放されるのを待機するロック サイクルが発生します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-915">This results in a lock cycle in which T1 and T2 wait for each other to release the locked resources.</span></span>  
  
-   <span data-ttu-id="1f03c-916">**ワーカー スレッド**。</span><span class="sxs-lookup"><span data-stu-id="1f03c-916">**Worker threads**.</span></span> <span data-ttu-id="1f03c-917">キューに登録されたタスクが利用可能なワーカー スレッドを待機していると、デッドロックが発生する場合があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-917">A queued task waiting for an available worker thread can cause deadlock.</span></span> <span data-ttu-id="1f03c-918">キューに登録されたタスクが、ワーカー スレッドをすべてブロックしているリソースを所有している場合、デッドロックが発生します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-918">If the queued task owns resources that are blocking all worker threads, a deadlock will result.</span></span> <span data-ttu-id="1f03c-919">たとえば、セッション S1 で、トランザクションが開始され、行 r1 に共有 (S) ロックがかけられ、スリープ状態になったとします。</span><span class="sxs-lookup"><span data-stu-id="1f03c-919">For example, session S1 starts a transaction and acquires a shared (S) lock on row r1 and then goes to sleep.</span></span> <span data-ttu-id="1f03c-920">使用可能なすべてのワーカー スレッドで実行中のアクティブなセッションは、行 r1 に排他 (X) ロックをかけようとします。</span><span class="sxs-lookup"><span data-stu-id="1f03c-920">Active sessions running on all available worker threads are trying to acquire exclusive (X) locks on row r1.</span></span> <span data-ttu-id="1f03c-921">セッション S1 ではワーカー スレッドを取得できないので、トランザクションをコミットして行 r1 のロックを解放することができません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-921">Because session S1 cannot acquire a worker thread, it cannot commit the transaction and release the lock on row r1.</span></span> <span data-ttu-id="1f03c-922">この結果、デッドロックが発生します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-922">This results in a deadlock.</span></span>  
  
-   <span data-ttu-id="1f03c-923">**メモリ**。</span><span class="sxs-lookup"><span data-stu-id="1f03c-923">**Memory**.</span></span> <span data-ttu-id="1f03c-924">同時要求で使用できるメモリ量以上のメモリ許可を待機している場合、デッドロックが発生することがあります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-924">When concurrent requests are waiting for memory grants that cannot be satisfied with the available memory, a deadlock can occur.</span></span> <span data-ttu-id="1f03c-925">たとえば、2 つの同時実行クエリ Q1 と Q2 は、それぞれ 10 MB と 20 MB のメモリを取得するユーザー定義関数として実行されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-925">For example, two concurrent queries, Q1 and Q2, execute as user-defined functions that acquire 10MB and 20MB of memory respectively.</span></span> <span data-ttu-id="1f03c-926">各クエリで 30 MB が必要でも、使用できるメモリの合計が 20 MB の場合、Q1 および Q2 では、互いにメモリが解放されるまで待機する必要があります。その結果、デッドロックが発生します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-926">If each query needs 30MB and the total available memory is 20MB, then Q1 and Q2 must wait for each other to release memory, and this results in a deadlock.</span></span>  
  
-   <span data-ttu-id="1f03c-927">**並列クエリ実行関連のリソース**。交換ポートに関連付けられたコーディネーター、プロデューサー、またはコンシューマーのスレッドが互いをブロックし、デッドロックを発生させることがあります。通常、この現象は、並列クエリに含まれていない別のプロセスを 1 つ以上含めようとした場合に発生します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-927">**Parallel query execution-related resources** Coordinator, producer, or consumer threads associated with an exchange port may block each other causing a deadlock usually when including at least one other process that is not a part of the parallel query.</span></span> <span data-ttu-id="1f03c-928">また、並列クエリの実行が開始されると、[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] は、現在のワークロードに基づいて並列処理の次数やワーカー スレッドの数を決定します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-928">Also, when a parallel query starts execution, [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] determines the degree of parallelism, or the number of worker threads, based upon the current workload.</span></span> <span data-ttu-id="1f03c-929">たとえば、サーバーで新しいクエリの実行が開始されたり、システムのワーカー スレッドが不足したりするなど、システムのワークロードが予期せず変更される場合は、デッドロックが発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-929">If the system workload unexpectedly changes, for example, where new queries start running on the server or the system runs out of worker threads, then a deadlock could occur.</span></span>  
  
-   <span data-ttu-id="1f03c-930">**複数のアクティブな結果セット (MARS) のリソース**。</span><span class="sxs-lookup"><span data-stu-id="1f03c-930">**Multiple Active Result Sets (MARS) resources**.</span></span> <span data-ttu-id="1f03c-931">これらのリソースは、MARS でアクティブな複数の要求のインターリーブを制御する際に使用します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-931">These resources are used to control interleaving of multiple active requests under MARS.</span></span> <span data-ttu-id="1f03c-932">詳細については、 [SQL Server の「複数のアクティブな結果セット (MARS)](https://msdn.microsoft.com/library/ms345109(v=SQL.90).aspx)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1f03c-932">For more information, see [Multiple Active Result Sets (MARS) in SQL Server](https://msdn.microsoft.com/library/ms345109(v=SQL.90).aspx).</span></span>  
  
    -   <span data-ttu-id="1f03c-933">**ユーザー リソース**。</span><span class="sxs-lookup"><span data-stu-id="1f03c-933">**User resource**.</span></span> <span data-ttu-id="1f03c-934">ユーザー アプリケーションで制御されている可能性のあるリソースをスレッドが待機している場合、そのリソースは、外部リソースまたはユーザー リソースと見なされ、ロックと同様に処理されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-934">When a thread is waiting for a resource that is potentially controlled by a user application, the resource is considered to be an external or user resource and is treated like a lock.</span></span>  
  
    -   <span data-ttu-id="1f03c-935">**セッション ミューテックス**。</span><span class="sxs-lookup"><span data-stu-id="1f03c-935">**Session mutex**.</span></span> <span data-ttu-id="1f03c-936">1 つのセッションで実行中のタスクはインターリーブされます。つまり、セッションでは、一度に 1 つのタスクしか実行できません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-936">The tasks running in one session are interleaved, meaning that only one task can run under the session at a given time.</span></span> <span data-ttu-id="1f03c-937">タスクを実行する前に、セッション ミューテックスに排他でアクセスする必要があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-937">Before the task can run, it must have exclusive access to the session mutex.</span></span>  
  
    -   <span data-ttu-id="1f03c-938">**トランザクション ミューテックス**。</span><span class="sxs-lookup"><span data-stu-id="1f03c-938">**Transaction mutex**.</span></span> <span data-ttu-id="1f03c-939">1 つのトランザクションで実行中のすべてのタスクはインターリーブされます。つまり、トランザクションでは、一度に 1 つのタスクしか実行できません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-939">All tasks running in one transaction are interleaved, meaning that only one task can run under the transaction at a given time.</span></span> <span data-ttu-id="1f03c-940">タスクを実行する前に、トランザクション ミューテックスに排他でアクセスする必要があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-940">Before the task can run, it must have exclusive access to the transaction mutex.</span></span>  
  
     <span data-ttu-id="1f03c-941">タスクを MARS で実行するには、セッション ミューテックスを取得する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-941">In order for a task to run under MARS, it must acquire the session mutex.</span></span> <span data-ttu-id="1f03c-942">タスクがトランザクションで実行されている場合は、トランザクション ミューテックスを取得する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-942">If the task is running under a transaction, it must then acquire the transaction mutex.</span></span> <span data-ttu-id="1f03c-943">これにより、そのセッションやトランザクションでは、一度に 1 つのタスクだけがアクティブになります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-943">This guarantees that only one task is active at one time in a given session and a given transaction.</span></span> <span data-ttu-id="1f03c-944">必要なミューテックスを取得後に、タスクを実行できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-944">Once the required mutexes have been acquired, the task can execute.</span></span> <span data-ttu-id="1f03c-945">タスクが終了するか、または要求の途中で中断されると、取得とは逆の順序で、最初にトランザクション ミューテックスが解放され、次にセッション ミューテックスが解放されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-945">When the task finishes, or yields in the middle of the request, it will first release transaction mutex followed by the session mutex in reverse order of acquisition.</span></span> <span data-ttu-id="1f03c-946">ただし、これらのリソースでデッドロックが発生する場合があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-946">However, deadlocks can occur with these resources.</span></span> <span data-ttu-id="1f03c-947">次に、ユーザーの要求 U1 と U2 という 2 つのタスクが同じセッション内で実行されているコード例を示します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-947">In the following code example, two tasks, user request U1 and user request U2, are running in the same session.</span></span>  
  
    ```  
    U1:    Rs1=Command1.Execute("insert sometable EXEC usp_someproc");  
    U2:    Rs2=Command2.Execute("select colA from sometable");  
    ```  
  
     <span data-ttu-id="1f03c-948">ユーザーの要求 U1 で実行されているストアド プロシージャで、セッション ミューテックスが取得されています。</span><span class="sxs-lookup"><span data-stu-id="1f03c-948">The stored procedure executing from user request U1 has acquired the session mutex.</span></span> <span data-ttu-id="1f03c-949">このストアド プロシージャの実行に時間がかかると、[!INCLUDE[ssDE](../includes/ssde-md.md)]により、ストアド プロシージャではユーザーからの入力を待機していると見なされます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-949">If the stored procedure takes a long time to execute, it is assumed by the [!INCLUDE[ssDE](../includes/ssde-md.md)] that the stored procedure is waiting for input from the user.</span></span> <span data-ttu-id="1f03c-950">ユーザーの要求 U2 ではセッション ミューテックスが解放されるのを待機しているのに対し、ユーザーは U2 の結果セットが返されるのを待機しています。さらに、U1 では、ユーザー リソースが解放されるのを待機しています。</span><span class="sxs-lookup"><span data-stu-id="1f03c-950">User request U2 is waiting for the session mutex while the user is waiting for the result set from U2, and U1 is waiting for a user resource.</span></span> <span data-ttu-id="1f03c-951">次の図に、このデッドロック状態を論理的に示します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-951">This is deadlock state logically illustrated as:</span></span>  
  
 <span data-ttu-id="1f03c-952">![ユーザー プロセスのデッドロックを示す論理図](media/udb9-logicflowexamplec.gif "ユーザー プロセスのデッドロックを示す論理図")</span><span class="sxs-lookup"><span data-stu-id="1f03c-952">![Logic diagram showing user process deadlock.](media/udb9-logicflowexamplec.gif "Logic diagram showing user process deadlock.")</span></span>  
  
##### <a name="deadlock-detection"></a><span data-ttu-id="1f03c-953">デッドロックの検出</span><span class="sxs-lookup"><span data-stu-id="1f03c-953">Deadlock Detection</span></span>  

 <span data-ttu-id="1f03c-954">上記のすべてのリソースには、[!INCLUDE[ssDE](../includes/ssde-md.md)]のデッドロック検出方式が適用されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-954">All of the resources listed in the section above participate in the [!INCLUDE[ssDE](../includes/ssde-md.md)] deadlock detection scheme.</span></span> <span data-ttu-id="1f03c-955">デッドロックの検出は、[!INCLUDE[ssDE](../includes/ssde-md.md)] インスタンスのすべてのタスクの検索を定期的に開始するロック モニター スレッドにより実行されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-955">Deadlock detection is performed by a lock monitor thread that periodically initiates a search through all of the tasks in an instance of the [!INCLUDE[ssDE](../includes/ssde-md.md)].</span></span> <span data-ttu-id="1f03c-956">検索プロセスは次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="1f03c-956">The following points describe the search process:</span></span>  
  
-   <span data-ttu-id="1f03c-957">既定の間隔は 5 秒です。</span><span class="sxs-lookup"><span data-stu-id="1f03c-957">The default interval is 5 seconds.</span></span>  
  
-   <span data-ttu-id="1f03c-958">ロック モニター スレッドでデッドロックが検出されると、デッドロック検出の間隔は、デッドロックの頻度に応じて、5 秒より短くなります。最短の間隔は 100 ミリ秒です。</span><span class="sxs-lookup"><span data-stu-id="1f03c-958">If the lock monitor thread finds deadlocks, the deadlock detection interval will drop from 5 seconds to as low as 100 milliseconds depending on the frequency of deadlocks.</span></span>  
  
-   <span data-ttu-id="1f03c-959">ロック モニター スレッドでデッドロックが検出されなくなると、[!INCLUDE[ssDE](../includes/ssde-md.md)]により、検索の間隔は 5 秒に引き上げられます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-959">If the lock monitor thread stops finding deadlocks, the [!INCLUDE[ssDE](../includes/ssde-md.md)] increases the intervals between searches to 5 seconds.</span></span>  
  
-   <span data-ttu-id="1f03c-960">デッドロックが検出されると、ロックが解除されるのを待機する必要のある次のスレッドがデッドロック サイクルに入っていることが想定されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-960">If a deadlock has just been detected, it is assumed that the next threads that must wait for a lock are entering the deadlock cycle.</span></span> <span data-ttu-id="1f03c-961">デッドロックが検出されると、最初の 2 つのロック待機では、次のデッドロックの検出間隔まで待機せず、すぐにデッドロックの検索が開始されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-961">The first couple of lock waits after a deadlock has been detected will immediately trigger a deadlock search rather than wait for the next deadlock detection interval.</span></span> <span data-ttu-id="1f03c-962">たとえば、検索の間隔が 5 秒に設定されている場合にデッドロックが検出されると、次のロック待機により、直ちにデッドロックの検出が開始されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-962">For example, if the current interval is 5 seconds, and a deadlock was just detected, the next lock wait will kick off the deadlock detector immediately.</span></span> <span data-ttu-id="1f03c-963">このロック待機がデッドロックの一部である場合は、このロック待機は、次のデッドロックの検索時ではなく、直ちに検出されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-963">If this lock wait is part of a deadlock, it will be detected right away rather than during next deadlock search.</span></span>  
  
 <span data-ttu-id="1f03c-964">通常、[!INCLUDE[ssDE](../includes/ssde-md.md)]では、定期的なデッドロックの検出のみが実行されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-964">The [!INCLUDE[ssDE](../includes/ssde-md.md)] typically performs periodic deadlock detection only.</span></span> <span data-ttu-id="1f03c-965">システムでデッドロックが発生することはまれであるため、デッドロック検出を定期的に実行することにより、システムのデッドロック検出のオーバーヘッドを削減できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-965">Because the number of deadlocks encountered in the system is usually small, periodic deadlock detection helps to reduce the overhead of deadlock detection in the system.</span></span>  
  
 <span data-ttu-id="1f03c-966">ロック モニターで、特定のスレッドに対するデッドロック検出が開始されると、スレッドが待機中のリソースが特定されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-966">When the lock monitor initiates deadlock search for a particular thread, it identifies the resource on which the thread is waiting.</span></span> <span data-ttu-id="1f03c-967">その後、ロック モニターでは、その特定のリソースを所有するスレッドが検出され、相互の従属性を検出するまで、スレッドのデッドロック検出が繰り返されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-967">The lock monitor then finds the owner(s) for that particular resource and recursively continues the deadlock search for those threads until it finds a cycle.</span></span> <span data-ttu-id="1f03c-968">このように検出された相互の従属性により、デッドロックが発生します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-968">A cycle identified in this manner forms a deadlock.</span></span>  
  
 <span data-ttu-id="1f03c-969">デッドロックが検出されると、[!INCLUDE[ssDE](../includes/ssde-md.md)]では、スレッドの 1 つをデッドロックの対象として選択することによりデッドロックを終了します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-969">After a deadlock is detected, the [!INCLUDE[ssDE](../includes/ssde-md.md)] ends a deadlock by choosing one of the threads as a deadlock victim.</span></span> <span data-ttu-id="1f03c-970">[!INCLUDE[ssDE](../includes/ssde-md.md)]では、スレッドに対して現在実行中のバッチを終了し、デッドロックの対象のトランザクションをロールバックして、アプリケーションに 1205 エラーを返します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-970">The [!INCLUDE[ssDE](../includes/ssde-md.md)] terminates the current batch being executed for the thread, rolls back the transaction of the deadlock victim, and returns a 1205 error to the application.</span></span> <span data-ttu-id="1f03c-971">デッドロックの対象のトランザクションをロールバックすると、そのトランザクションで保持されていたすべてのロックが解放されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-971">Rolling back the transaction for the deadlock victim releases all locks held by the transaction.</span></span> <span data-ttu-id="1f03c-972">ロックが解放されると、他のスレッドのトランザクションのブロックは解除され、処理を続行することができるようになります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-972">This allows the transactions of the other threads to become unblocked and continue.</span></span> <span data-ttu-id="1f03c-973">デッドロックの対象を示す 1205 エラーにより、デッドロックに関係するスレッドおよびリソースに関する情報がエラー ログに記録されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-973">The 1205 deadlock victim error records information about the threads and resources involved in a deadlock in the error log.</span></span>  
  
 <span data-ttu-id="1f03c-974">既定では、[!INCLUDE[ssDE](../includes/ssde-md.md)]により、ロールバックに最もコストのかからないトランザクションを実行しているセッションがデッドロックの対象として選択されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-974">By default, the [!INCLUDE[ssDE](../includes/ssde-md.md)] chooses as the deadlock victim the session running the transaction that is least expensive to roll back.</span></span> <span data-ttu-id="1f03c-975">また、ユーザーは、SET DEADLOCK_PRIORITY ステートメントを使用して、デッドロックが発生した場合のセッションの優先度を指定することもできます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-975">Alternatively, a user can specify the priority of sessions in a deadlock situation using the SET DEADLOCK_PRIORITY statement.</span></span> <span data-ttu-id="1f03c-976">DEADLOCK_PRIORITY には、LOW、NORMAL、または HIGH を設定するか、あるいは -10 ～ 10 の範囲の整数値を設定することができます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-976">DEADLOCK_PRIORITY can be set to LOW, NORMAL, or HIGH, or alternatively can be set to any integer value in the range (-10 to 10).</span></span> <span data-ttu-id="1f03c-977">DEADLOCK_PRIORITY の既定値は NORMAL です。</span><span class="sxs-lookup"><span data-stu-id="1f03c-977">The deadlock priority defaults to NORMAL.</span></span> <span data-ttu-id="1f03c-978">2 つのセッションのデッドロックの優先度が異なる場合、優先度の低いセッションがデッドロックの対象として選択されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-978">If two sessions have different deadlock priorities, the session with the lower priority is chosen as the deadlock victim.</span></span> <span data-ttu-id="1f03c-979">2 つのセッションのデッドロックの優先度が同じ場合、ロールバックに最もコストのかからないトランザクションを含むセッションがデッドロックの対象として選択されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-979">If both sessions have the same deadlock priority, the session with the transaction that is least expensive to roll back is chosen.</span></span> <span data-ttu-id="1f03c-980">デッドロック サイクルに関連するセッションのデッドロックの優先度とコストが同じ場合、対象はランダムに選択されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-980">If sessions involved in the deadlock cycle have the same deadlock priority and the same cost, a victim is chosen randomly.</span></span>  
  
 <span data-ttu-id="1f03c-981">CLR を使用して作業する場合、デッドロック モニターでは、マネージド プロシージャ内でアクセスされる同期リソース (モニター、リーダー ロックとライター ロック、およびスレッド結合) のデッドロックが自動的に検出されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-981">When working with CLR, the deadlock monitor automatically detects deadlock for synchronization resources (monitors, reader/writer lock and thread join) accessed inside managed procedures.</span></span> <span data-ttu-id="1f03c-982">ただし、デッドロックは、デッドロックの対象として選択されたプロシージャに例外をスローすることによって解決されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-982">However, the deadlock is resolved by throwing an exception in the procedure that was selected to be the deadlock victim.</span></span> <span data-ttu-id="1f03c-983">デッドロックの対象が現在所有しているリソースは、この例外により自動的に解放されないことに注意してください。つまり、リソースは明示的に解放する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-983">It is important to understand that the exception does not automatically release resources currently owned by the victim; the resources must be explicitly released.</span></span> <span data-ttu-id="1f03c-984">例外の動作と一貫性があるため、デッドロックの対象の特定に使用された例外は、キャッチおよび破棄できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-984">Consistent with exception behavior, the exception used to identify a deadlock victim can be caught and dismissed.</span></span>  
  
##### <a name="deadlock-information-tools"></a><span data-ttu-id="1f03c-985">デッドロック情報ツール</span><span class="sxs-lookup"><span data-stu-id="1f03c-985">Deadlock Information Tools</span></span>  

 <span data-ttu-id="1f03c-986">デッドロック情報を表示するために、[!INCLUDE[ssDE](../includes/ssde-md.md)]には 2 種類のトレース フラグ形式での監視ツールと [!INCLUDE[ssSqlProfiler](../includes/sssqlprofiler-md.md)] の Deadlock Graph イベントが用意されています。</span><span class="sxs-lookup"><span data-stu-id="1f03c-986">To view deadlock information, the [!INCLUDE[ssDE](../includes/ssde-md.md)] provides monitoring tools in the form of two trace flags, and the deadlock graph event in [!INCLUDE[ssSqlProfiler](../includes/sssqlprofiler-md.md)].</span></span>  
  
###### <a name="trace-flag-1204-and-trace-flag-1222"></a><span data-ttu-id="1f03c-987">トレース フラグ 1204 およびトレース フラグ 1222</span><span class="sxs-lookup"><span data-stu-id="1f03c-987">Trace Flag 1204 and Trace Flag 1222</span></span>  

 <span data-ttu-id="1f03c-988">デッドロックが発生すると、トレース フラグ 1204 およびトレース フラグ 1222 は [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] のエラー ログでキャプチャされる情報を返します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-988">When deadlocks occur, trace flag 1204 and trace flag 1222 return information that is captured in the [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] error log.</span></span> <span data-ttu-id="1f03c-989">トレース フラグ 1204 では、デッドロックに関係するノードごとに形式が設定されたデッドロック情報をレポートします。</span><span class="sxs-lookup"><span data-stu-id="1f03c-989">Trace flag 1204 reports deadlock information formatted by each node involved in the deadlock.</span></span> <span data-ttu-id="1f03c-990">トレース フラグ 1222 では、最初にプロセスごとに、次にリソースごとにデッドロック情報の形式を設定します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-990">Trace flag 1222 formats deadlock information, first by processes and then by resources.</span></span> <span data-ttu-id="1f03c-991">両方のトレース フラグを有効にして、同じデッドロック イベントを 2 種類の表示方法で取得することも可能です。</span><span class="sxs-lookup"><span data-stu-id="1f03c-991">It is possible to enable both trace flags to obtain two representations of the same deadlock event.</span></span>  
  
 <span data-ttu-id="1f03c-992">次の表は、トレース フラグ 1204 および 1222 のプロパティの定義の他に、類似点および相違点についても示しています。</span><span class="sxs-lookup"><span data-stu-id="1f03c-992">In addition to defining the properties of trace flag 1204 and 1222, the following table also shows the similarities and differences.</span></span>  
  
|<span data-ttu-id="1f03c-993">プロパティ</span><span class="sxs-lookup"><span data-stu-id="1f03c-993">Property</span></span>|<span data-ttu-id="1f03c-994">トレース フラグ 1204 およびトレース フラグ 1222</span><span class="sxs-lookup"><span data-stu-id="1f03c-994">Trace Flag 1204 and Trace Flag 1222</span></span>|<span data-ttu-id="1f03c-995">トレース フラグ 1204 のみ</span><span class="sxs-lookup"><span data-stu-id="1f03c-995">Trace Flag 1204 only</span></span>|<span data-ttu-id="1f03c-996">トレース フラグ 1222 のみ</span><span class="sxs-lookup"><span data-stu-id="1f03c-996">Trace Flag 1222 only</span></span>|  
|--------------|-----------------------------------------|--------------------------|--------------------------|  
|<span data-ttu-id="1f03c-997">出力形式</span><span class="sxs-lookup"><span data-stu-id="1f03c-997">Output format</span></span>|<span data-ttu-id="1f03c-998">出力は [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] のエラー ログにキャプチャされます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-998">Output is captured in the [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] error log.</span></span>|<span data-ttu-id="1f03c-999">デッドロックに関係するノードだけが表示されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-999">Focused on the nodes involved in the deadlock.</span></span> <span data-ttu-id="1f03c-1000">各ノードには専用のセクションがあり、最後のセクションではデッドロック対象が示されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1000">Each node has a dedicated section, and the final section describes the deadlock victim.</span></span>|<span data-ttu-id="1f03c-1001">XML スキーマ定義 (XSD) スキーマには準拠していない、XML に似た形式で情報を返します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1001">Returns information in an XML-like format that does not conform to an XML Schema Definition (XSD) schema.</span></span> <span data-ttu-id="1f03c-1002">この形式には、3 つの主要なセクションがあります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1002">The format has three major sections.</span></span> <span data-ttu-id="1f03c-1003">最初のセクションでは、デッドロック対象が宣言されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1003">The first section declares the deadlock victim.</span></span> <span data-ttu-id="1f03c-1004">2 番目のセクションでは、デッドロックに関係する各プロセスが示されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1004">The second section describes each process involved in the deadlock.</span></span> <span data-ttu-id="1f03c-1005">3 番目のセクションでは、トレース フラグ 1204 のノードと同義のリソースが示されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1005">The third section describes the resources that are synonymous with nodes in trace flag 1204.</span></span>|  
|<span data-ttu-id="1f03c-1006">識別属性</span><span class="sxs-lookup"><span data-stu-id="1f03c-1006">Identifying attributes</span></span>|<span data-ttu-id="1f03c-1007">**SPID: \<x> 次のように \<x> なります。**</span><span class="sxs-lookup"><span data-stu-id="1f03c-1007">**SPID:\<x> ECID:\<x>.**</span></span> <span data-ttu-id="1f03c-1008">並列処理を行う場合に、システム プロセス ID のスレッドを識別します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1008">Identifies the system process ID thread in cases of parallel processes.</span></span> <span data-ttu-id="1f03c-1009">エントリ `SPID:<x> ECID:0` ( \<x> は SPID 値に置き換えられます) は、メインスレッドを表します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1009">The entry `SPID:<x> ECID:0`, where \<x> is replaced by the SPID value, represents the main thread.</span></span> <span data-ttu-id="1f03c-1010">エントリ `SPID:<x> ECID:<y>` ( \<x> は spid 値に置き換えられ、 \<y> が0より大きい) は、同じ spid のサブスレッドを表します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1010">The entry `SPID:<x> ECID:<y>`, where \<x> is replaced by the SPID value and \<y> is greater than 0, represents the sub-threads for the same SPID.</span></span><br /><br /> <span data-ttu-id="1f03c-1011">**BatchID** (トレース フラグ 1222 の **sbid**)。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1011">**BatchID** (**sbid** for trace flag 1222).</span></span> <span data-ttu-id="1f03c-1012">コードの実行でロックを要求または保持しているバッチを識別します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1012">Identifies the batch from which code execution is requesting or holding a lock.</span></span> <span data-ttu-id="1f03c-1013">複数のアクティブな結果セット (MARS) が無効になっている場合、BatchID の値は 0 になります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1013">When Multiple Active Result Sets (MARS) is disabled, the BatchID value is 0.</span></span> <span data-ttu-id="1f03c-1014">MARS が有効になっている場合、アクティブなバッチの値は 1 から *n* になります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1014">When MARS is enabled, the value for active batches is 1 to *n*.</span></span> <span data-ttu-id="1f03c-1015">セッションにアクティブなバッチが存在しない場合、BatchID は 0 になります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1015">If there are no active batches in the session, BatchID is 0.</span></span><br /><br /> <span data-ttu-id="1f03c-1016">**モード**。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1016">**Mode**.</span></span> <span data-ttu-id="1f03c-1017">スレッドによって要求、許可、または待機される特定のリソースに対して、ロックの種類を指定します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1017">Specifies the type of lock for a particular resource that is requested, granted, or waited on by a thread.</span></span> <span data-ttu-id="1f03c-1018">モードには、IS (インテント共有)、S (共有)、U (更新)、IX (インテント排他)、SIX (インテント排他付き共有)、および X (排他) があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1018">Mode can be IS (Intent Shared), S (Shared), U (Update), IX (Intent Exclusive), SIX (Shared with Intent Exclusive), and X (Exclusive).</span></span><br /><br /> <span data-ttu-id="1f03c-1019">**Line #** (トレース フラグ 1222 の**行**)。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1019">**Line #** (**line** for trace flag 1222).</span></span> <span data-ttu-id="1f03c-1020">デッドロックが発生したときに実行されていた、現在のステートメントのバッチの行番号が表示されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1020">Lists the line number in the current batch of statements that was being executed when the deadlock occurred.</span></span><br /><br /> <span data-ttu-id="1f03c-1021">**Input Buf** (トレース フラグ 1222 の **inputbuf**)。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1021">**Input Buf** (**inputbuf** for trace flag 1222).</span></span> <span data-ttu-id="1f03c-1022">現在のバッチに含まれるステートメントをすべて表示します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1022">Lists all the statements in the current batch.</span></span>|<span data-ttu-id="1f03c-1023">**Node**。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1023">**Node**.</span></span> <span data-ttu-id="1f03c-1024">デッドロック チェーンに含まれるエントリ番号を表します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1024">Represents the entry number in the deadlock chain.</span></span><br /><br /> <span data-ttu-id="1f03c-1025">**Lists**。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1025">**Lists**.</span></span> <span data-ttu-id="1f03c-1026">次の一覧にロックの所有者が含まれる場合があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1026">The lock owner can be part of these lists:</span></span><br /><br /> <span data-ttu-id="1f03c-1027">**Grant List**。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1027">**Grant List**.</span></span> <span data-ttu-id="1f03c-1028">リソースの現在の所有者を列挙します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1028">Enumerates the current owners of the resource.</span></span><br /><br /> <span data-ttu-id="1f03c-1029">**Convert List**。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1029">**Convert List**.</span></span> <span data-ttu-id="1f03c-1030">ロックを高いレベルに変換しようとしている現在の所有者を列挙します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1030">Enumerates the current owners that are trying to convert their locks to a higher level.</span></span><br /><br /> <span data-ttu-id="1f03c-1031">**Wait List**。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1031">**Wait List**.</span></span> <span data-ttu-id="1f03c-1032">リソースに対する現在の新しいロック要求を列挙します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1032">Enumerates current new lock requests for the resource.</span></span><br /><br /> <span data-ttu-id="1f03c-1033">**Statement Type**。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1033">**Statement Type**.</span></span> <span data-ttu-id="1f03c-1034">権限を持つスレッドにおける DML ステートメントの種類 (SELECT、INSERT、UPDATE、または DELETE) を示します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1034">Describes the type of DML statement (SELECT, INSERT, UPDATE, or DELETE) on which the threads have permissions.</span></span><br /><br /> <span data-ttu-id="1f03c-1035">**Victim Resource Owner**。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1035">**Victim Resource Owner**.</span></span> <span data-ttu-id="1f03c-1036">[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] がデッドロック サイクルを解除する対象として選択する、参加スレッドを指定します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1036">Specifies the participating thread that [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] chooses as the victim to break the deadlock cycle.</span></span> <span data-ttu-id="1f03c-1037">選択したスレッドと既存のすべてのサブスレッドを終了します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1037">The chosen thread and all existing sub-threads are terminated.</span></span><br /><br /> <span data-ttu-id="1f03c-1038">**Next Branch**。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1038">**Next Branch**.</span></span> <span data-ttu-id="1f03c-1039">デッドロック サイクルに関係する、同じ SPID からの 2 つ以上のサブスレッドを表します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1039">Represents the two or more sub-threads from the same SPID that are involved in the deadlock cycle.</span></span>|<span data-ttu-id="1f03c-1040">**deadlock victim**。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1040">**deadlock victim**.</span></span> <span data-ttu-id="1f03c-1041">デッドロックの対象として選択されたタスクの物理メモリ アドレス (「[sys.dm_os_tasks &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-os-tasks-transact-sql)」を参照) を表します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1041">Represents the physical memory address of the task (see [sys.dm_os_tasks &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-os-tasks-transact-sql)) that was selected as a deadlock victim.</span></span> <span data-ttu-id="1f03c-1042">デッドロックが未解決の場合は、0 になることがあります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1042">It may be 0 (zero) in the case of an unresolved deadlock.</span></span> <span data-ttu-id="1f03c-1043">ロールバックを実行中のタスクは、デッドロックの対象として選択できません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1043">A task that is rolling back cannot be chosen as a deadlock victim.</span></span><br /><br /> <span data-ttu-id="1f03c-1044">**executionstack**。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1044">**executionstack**.</span></span> <span data-ttu-id="1f03c-1045">デッドロックの発生時に実行されている [!INCLUDE[tsql](../includes/tsql-md.md)] コードを表します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1045">Represents [!INCLUDE[tsql](../includes/tsql-md.md)] code that is being executed at the time the deadlock occurs.</span></span><br /><br /> <span data-ttu-id="1f03c-1046">**priority**。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1046">**priority**.</span></span> <span data-ttu-id="1f03c-1047">デッドロックの優先度を表します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1047">Represents deadlock priority.</span></span> <span data-ttu-id="1f03c-1048">[!INCLUDE[ssDE](../includes/ssde-md.md)]では、コンカレンシーを向上させるために、短期間でデッドロックの優先度が変更されることがあります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1048">In certain cases, the [!INCLUDE[ssDE](../includes/ssde-md.md)] may opt to alter the deadlock priority for a short duration to achieve better concurrency.</span></span><br /><br /> <span data-ttu-id="1f03c-1049">**logused**。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1049">**logused**.</span></span> <span data-ttu-id="1f03c-1050">タスクで使用されているログ領域です。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1050">Log space used by the task.</span></span><br /><br /> <span data-ttu-id="1f03c-1051">**owner id**。要求を制御するトランザクションの ID です。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1051">**owner id**. The ID of the transaction that has control of the request.</span></span><br /><br /> <span data-ttu-id="1f03c-1052">**status**。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1052">**status**.</span></span> <span data-ttu-id="1f03c-1053">タスクの状態です。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1053">State of the task.</span></span> <span data-ttu-id="1f03c-1054">次のいずれかの値です。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1054">It is one of the following values:</span></span><br /><br /> <span data-ttu-id="1f03c-1055">>> **pending**。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1055">>> **pending**.</span></span> <span data-ttu-id="1f03c-1056">ワーカー スレッドを待機しています。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1056">Waiting for a worker thread.</span></span><br /><br /> <span data-ttu-id="1f03c-1057">>> **runnable**。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1057">>> **runnable**.</span></span> <span data-ttu-id="1f03c-1058">実行できる状態ですが、クォンタムを待機しています。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1058">Ready to run but waiting for a quantum.</span></span><br /><br /> <span data-ttu-id="1f03c-1059">>> **running**。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1059">>> **running**.</span></span> <span data-ttu-id="1f03c-1060">スケジューラで現在実行中です。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1060">Currently running on the scheduler.</span></span><br /><br /> <span data-ttu-id="1f03c-1061">>> **suspended**。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1061">>> **suspended**.</span></span> <span data-ttu-id="1f03c-1062">実行は中断されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1062">Execution is suspended.</span></span><br /><br /> <span data-ttu-id="1f03c-1063">>> **done**。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1063">>> **done**.</span></span> <span data-ttu-id="1f03c-1064">タスクが完了しました。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1064">Task has completed.</span></span><br /><br /> <span data-ttu-id="1f03c-1065">>> **spinloop**。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1065">>> **spinloop**.</span></span> <span data-ttu-id="1f03c-1066">スピンロックが解放されるのを待機しています。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1066">Waiting for a spinlock to become free.</span></span><br /><br /> <span data-ttu-id="1f03c-1067">**waitresource**。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1067">**waitresource**.</span></span> <span data-ttu-id="1f03c-1068">タスクで必要なリソースです。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1068">The resource needed by the task.</span></span><br /><br /> <span data-ttu-id="1f03c-1069">**waittime**。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1069">**waittime**.</span></span> <span data-ttu-id="1f03c-1070">リソースを待機する時間 (ミリ秒単位) です。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1070">Time in milliseconds waiting for the resource.</span></span><br /><br /> <span data-ttu-id="1f03c-1071">**schedulerid**。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1071">**schedulerid**.</span></span> <span data-ttu-id="1f03c-1072">このタスクに関連付けられたスケジューラです。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1072">Scheduler associated with this task.</span></span> <span data-ttu-id="1f03c-1073">「[sys.dm_os_schedulers &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-os-schedulers-transact-sql)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1073">See [sys.dm_os_schedulers &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-os-schedulers-transact-sql).</span></span><br /><br /> <span data-ttu-id="1f03c-1074">**hostname**。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1074">**hostname**.</span></span> <span data-ttu-id="1f03c-1075">ワークステーションの名前です。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1075">The name of the workstation.</span></span><br /><br /> <span data-ttu-id="1f03c-1076">**isolationlevel**。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1076">**isolationlevel**.</span></span> <span data-ttu-id="1f03c-1077">現在のトランザクション分離レベルです。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1077">The current transaction isolation level.</span></span><br /><br /> <span data-ttu-id="1f03c-1078">**Xactid**。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1078">**Xactid**.</span></span> <span data-ttu-id="1f03c-1079">要求を制御するトランザクションの ID です。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1079">The ID of the transaction that has control of the request.</span></span><br /><br /> <span data-ttu-id="1f03c-1080">**currentdb**。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1080">**currentdb**.</span></span> <span data-ttu-id="1f03c-1081">データベースの ID です。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1081">The ID of the database.</span></span><br /><br /> <span data-ttu-id="1f03c-1082">**lastbatchstarted**。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1082">**lastbatchstarted**.</span></span> <span data-ttu-id="1f03c-1083">クライアント プロセスで最後にバッチ実行が開始した時刻です。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1083">The last time a client process started batch execution.</span></span><br /><br /> <span data-ttu-id="1f03c-1084">**lastbatchcompleted**。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1084">**lastbatchcompleted**.</span></span> <span data-ttu-id="1f03c-1085">クライアント プロセスで最後にバッチ実行が完了した時刻です。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1085">The last time a client process completed batch execution.</span></span><br /><br /> <span data-ttu-id="1f03c-1086">**clientoption1 and clientoption2**。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1086">**clientoption1 and clientoption2**.</span></span> <span data-ttu-id="1f03c-1087">このクライアント接続にオプションを設定します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1087">Set options on this client connection.</span></span> <span data-ttu-id="1f03c-1088">これは、通常 SET NOCOUNT や SET XACTABORT などの SET ステートメントで制御されているオプションに関する情報を含むビットマスクです。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1088">This is a bitmask that includes information about options usually controlled by SET statements such as SET NOCOUNT and SET XACTABORT.</span></span><br /><br /> <span data-ttu-id="1f03c-1089">**associatedObjectId**。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1089">**associatedObjectId**.</span></span> <span data-ttu-id="1f03c-1090">HoBT (ヒープまたは B-Tree) の ID を表します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1090">Represents the HoBT (heap or b-tree) ID.</span></span>|  
|<span data-ttu-id="1f03c-1091">リソース属性</span><span class="sxs-lookup"><span data-stu-id="1f03c-1091">Resource attributes</span></span>|<span data-ttu-id="1f03c-1092">**RID**。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1092">**RID**.</span></span> <span data-ttu-id="1f03c-1093">ロックが保持または要求されているテーブル内の単一行を識別します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1093">Identifies the single row within a table on which a lock is held or requested.</span></span> <span data-ttu-id="1f03c-1094">RID は、RID: *db_id:file_id:page_no:row_no* として表されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1094">RID is represented as RID: *db_id:file_id:page_no:row_no*.</span></span> <span data-ttu-id="1f03c-1095">たとえば、「 `RID: 6:1:20789:0` 」のように入力します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1095">For example, `RID: 6:1:20789:0`.</span></span><br /><br /> <span data-ttu-id="1f03c-1096">**OBJECT**。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1096">**OBJECT**.</span></span> <span data-ttu-id="1f03c-1097">ロックが保持または要求されているテーブルを識別します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1097">Identifies the table on which a lock is held or requested.</span></span> <span data-ttu-id="1f03c-1098">OBJECT は、OBJECT: *db_id:object_id* として表されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1098">OBJECT is represented as OBJECT: *db_id:object_id*.</span></span> <span data-ttu-id="1f03c-1099">たとえば、「 `TAB: 6:2009058193` 」のように入力します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1099">For example, `TAB: 6:2009058193`.</span></span><br /><br /> <span data-ttu-id="1f03c-1100">**KEY**。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1100">**KEY**.</span></span> <span data-ttu-id="1f03c-1101">ロックが保持または要求されているインデックス内のキー範囲を識別します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1101">Identifies the key range within an index on which a lock is held or requested.</span></span> <span data-ttu-id="1f03c-1102">KEY は、KEY: *db_id:hobt_id* (*インデックス キー ハッシュ値*) として表されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1102">KEY is represented as KEY: *db_id:hobt_id* (*index key hash value*).</span></span> <span data-ttu-id="1f03c-1103">たとえば、「 `KEY: 6:72057594057457664 (350007a4d329)` 」のように入力します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1103">For example, `KEY: 6:72057594057457664 (350007a4d329)`.</span></span><br /><br /> <span data-ttu-id="1f03c-1104">**PAG**。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1104">**PAG**.</span></span> <span data-ttu-id="1f03c-1105">ロックが保持または要求されているページ リソースを識別します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1105">Identifies the page resource on which a lock is held or requested.</span></span> <span data-ttu-id="1f03c-1106">PAG は、PAG: *db_id:file_id:page_no* として表されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1106">PAG is represented as PAG: *db_id:file_id:page_no*.</span></span> <span data-ttu-id="1f03c-1107">たとえば、「 `PAG: 6:1:20789` 」のように入力します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1107">For example, `PAG: 6:1:20789`.</span></span><br /><br /> <span data-ttu-id="1f03c-1108">**EXT**。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1108">**EXT**.</span></span> <span data-ttu-id="1f03c-1109">エクステント構造を識別します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1109">Identifies the extent structure.</span></span> <span data-ttu-id="1f03c-1110">EXT は、EXT: *db_id:file_id:extent_no* として表されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1110">EXT is represented as EXT: *db_id:file_id:extent_no*.</span></span> <span data-ttu-id="1f03c-1111">たとえば、「 `EXT: 6:1:9` 」のように入力します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1111">For example, `EXT: 6:1:9`.</span></span><br /><br /> <span data-ttu-id="1f03c-1112">**DB**。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1112">**DB**.</span></span> <span data-ttu-id="1f03c-1113">データベース ロックを識別します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1113">Identifies the database lock.</span></span> <span data-ttu-id="1f03c-1114">**DB は次のいずれかで表されます。**</span><span class="sxs-lookup"><span data-stu-id="1f03c-1114">**DB is represented in one of the following ways:**</span></span><br /><br /> <span data-ttu-id="1f03c-1115">DB: *db_id*</span><span class="sxs-lookup"><span data-stu-id="1f03c-1115">DB: *db_id*</span></span><br /><br /> <span data-ttu-id="1f03c-1116">DB: *db_id*[BULK-OP-DB]。データベースのバックアップに使用されたデータベース ロックを識別します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1116">DB: *db_id*[BULK-OP-DB], which identifies the database lock taken by the backup database.</span></span><br /><br /> <span data-ttu-id="1f03c-1117">DB: *db_id*[BULK-OP-LOG]。特定のデータベースのバックアップ ログに使用されたロックを識別します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1117">DB: *db_id*[BULK-OP-LOG], which identifies the lock taken by the backup log for that particular database.</span></span><br /><br /> <span data-ttu-id="1f03c-1118">**APP**。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1118">**APP**.</span></span> <span data-ttu-id="1f03c-1119">アプリケーション リソースに使用されたロックを識別します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1119">Identifies the lock taken by an application resource.</span></span> <span data-ttu-id="1f03c-1120">APP は、APP: *lock_resource* として表されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1120">APP is represented as APP: *lock_resource*.</span></span> <span data-ttu-id="1f03c-1121">たとえば、「 `APP: Formf370f478` 」のように入力します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1121">For example, `APP: Formf370f478`.</span></span><br /><br /> <span data-ttu-id="1f03c-1122">**METADATA**。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1122">**METADATA**.</span></span> <span data-ttu-id="1f03c-1123">デッドロックに関係するメタデータ リソースを表します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1123">Represents metadata resources involved in a deadlock.</span></span> <span data-ttu-id="1f03c-1124">METADATA には多数のサブリソースがあるため、返される値はデッドロックされたサブリソースに依存します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1124">Because METADATA has many subresources, the value returned depends upon the subresource that has deadlocked.</span></span> <span data-ttu-id="1f03c-1125">たとえば、メタデータです。USER_TYPE はを返し `user_type_id =` \<*integer_value*> ます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1125">For example, METADATA.USER_TYPE returns `user_type_id =` \<*integer_value*>.</span></span> <span data-ttu-id="1f03c-1126">METADATA のリソースおよびサブリソースについて詳しくは、「[sys.dm_tran_locks &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-locks-transact-sql)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1126">For more information about METADATA resources and subresources, see [sys.dm_tran_locks &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-locks-transact-sql).</span></span><br /><br /> <span data-ttu-id="1f03c-1127">**HOBT**。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1127">**HOBT**.</span></span> <span data-ttu-id="1f03c-1128">デッドロックに関係するヒープまたは B-Tree を表します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1128">Represents a heap or b-tree involved in a deadlock.</span></span>|<span data-ttu-id="1f03c-1129">このトレース フラグに限定されるリソース属性はありません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1129">None exclusive to this trace flag.</span></span>|<span data-ttu-id="1f03c-1130">このトレース フラグに限定されるリソース属性はありません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1130">None exclusive to this trace flag.</span></span>|  
  
###### <a name="trace-flag-1204-example"></a><span data-ttu-id="1f03c-1131">トレース フラグ 1204 の例</span><span class="sxs-lookup"><span data-stu-id="1f03c-1131">Trace Flag 1204 Example</span></span>  

 <span data-ttu-id="1f03c-1132">次の例は、トレース フラグ 1204 がオンになっている場合の出力を示しています。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1132">The following example shows the output when trace flag 1204 is turned on.</span></span> <span data-ttu-id="1f03c-1133">この場合、ノード 1 のテーブルはインデックスのないヒープ、ノード 2 のテーブルは非クラスター化インデックスのあるヒープになります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1133">In this case, the table in Node 1 is a heap with no indexes, and the table in Node 2 is a heap with a nonclustered index.</span></span> <span data-ttu-id="1f03c-1134">ノード 2 のインデックス キーは、デッドロックの発生時に更新されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1134">The index key in Node 2 is being updated when the deadlock occurs.</span></span>  
  
```  
Deadlock encountered .... Printing deadlock information  
Wait-for graph  
  
Node:1  
  
RID: 6:1:20789:0               CleanCnt:3 Mode:X Flags: 0x2  
 Grant List 0:  
   Owner:0x0315D6A0 Mode: X          
     Flg:0x0 Ref:0 Life:02000000 SPID:55 ECID:0 XactLockInfo: 0x04D9E27C  
   SPID: 55 ECID: 0 Statement Type: UPDATE Line #: 6  
   Input Buf: Language Event:   
BEGIN TRANSACTION  
   EXEC usp_p2  
 Requested By:   
   ResType:LockOwner Stype:'OR'Xdes:0x03A3DAD0   
     Mode: U SPID:54 BatchID:0 ECID:0 TaskProxy:(0x04976374) Value:0x315d200 Cost:(0/868)  
  
Node:2  
  
KEY: 6:72057594057457664 (350007a4d329) CleanCnt:2 Mode:X Flags: 0x0  
 Grant List 0:  
   Owner:0x0315D140 Mode: X          
     Flg:0x0 Ref:0 Life:02000000 SPID:54 ECID:0 XactLockInfo: 0x03A3DAF4  
   SPID: 54 ECID: 0 Statement Type: UPDATE Line #: 6  
   Input Buf: Language Event:   
     BEGIN TRANSACTION  
       EXEC usp_p1  
 Requested By:   
   ResType:LockOwner Stype:'OR'Xdes:0x04D9E258   
     Mode: U SPID:55 BatchID:0 ECID:0 TaskProxy:(0x0475E374) Value:0x315d4a0 Cost:(0/380)  
  
Victim Resource Owner:  
 ResType:LockOwner Stype:'OR'Xdes:0x04D9E258   
     Mode: U SPID:55 BatchID:0 ECID:0 TaskProxy:(0x0475E374) Value:0x315d4a0 Cost:(0/380)  
```  
  
###### <a name="trace-flag-1222-example"></a><span data-ttu-id="1f03c-1135">トレース フラグ 1222 の例</span><span class="sxs-lookup"><span data-stu-id="1f03c-1135">Trace Flag 1222 Example</span></span>  

 <span data-ttu-id="1f03c-1136">次の例は、トレース フラグ 1222 がオンになっている場合の出力を示しています。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1136">The following example shows the output when trace flag 1222 is turned on.</span></span> <span data-ttu-id="1f03c-1137">この場合、一方のテーブルがインデックスのないヒープになり、他方のテーブルが非クラスター化インデックスのあるヒープになります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1137">In this case, one table is a heap with no indexes, and the other table is a heap with a nonclustered index.</span></span> <span data-ttu-id="1f03c-1138">2 番目のテーブルでは、デッドロックの発生時にインデックス キーが更新されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1138">In the second table, the index key is being updated when the deadlock occurs.</span></span>  
  
```  
deadlock-list  
 deadlock victim=process689978  
  process-list  
   process id=process6891f8 taskpriority=0 logused=868   
   waitresource=RID: 6:1:20789:0 waittime=1359 ownerId=310444   
   transactionname=user_transaction   
   lasttranstarted=2005-09-05T11:22:42.733 XDES=0x3a3dad0   
   lockMode=U schedulerid=1 kpid=1952 status=suspended spid=54   
   sbid=0 ecid=0 priority=0 transcount=2   
   lastbatchstarted=2005-09-05T11:22:42.733   
   lastbatchcompleted=2005-09-05T11:22:42.733   
   clientapp=Microsoft SQL Server Management Studio - Query   
   hostname=TEST_SERVER hostpid=2216 loginname=DOMAIN\user   
   isolationlevel=read committed (2) xactid=310444 currentdb=6   
   lockTimeout=4294967295 clientoption1=671090784 clientoption2=390200  
    executionStack  
     frame procname=AdventureWorks2012.dbo.usp_p1 line=6 stmtstart=202   
     sqlhandle=0x0300060013e6446b027cbb00c69600000100000000000000  
     UPDATE T2 SET COL1 = 3 WHERE COL1 = 1;       
     frame procname=adhoc line=3 stmtstart=44   
     sqlhandle=0x01000600856aa70f503b8104000000000000000000000000  
     EXEC usp_p1       
    inputbuf  
      BEGIN TRANSACTION  
       EXEC usp_p1  
   process id=process689978 taskpriority=0 logused=380   
   waitresource=KEY: 6:72057594057457664 (350007a4d329)     
   waittime=5015 ownerId=310462 transactionname=user_transaction   
   lasttranstarted=2005-09-05T11:22:44.077 XDES=0x4d9e258 lockMode=U   
   schedulerid=1 kpid=3024 status=suspended spid=55 sbid=0 ecid=0   
   priority=0 transcount=2 lastbatchstarted=2005-09-05T11:22:44.077   
   lastbatchcompleted=2005-09-05T11:22:44.077   
   clientapp=Microsoft SQL Server Management Studio - Query   
   hostname=TEST_SERVER hostpid=2216 loginname=DOMAIN\user   
   isolationlevel=read committed (2) xactid=310462 currentdb=6   
   lockTimeout=4294967295 clientoption1=671090784 clientoption2=390200  
    executionStack  
     frame procname=AdventureWorks2012.dbo.usp_p2 line=6 stmtstart=200   
     sqlhandle=0x030006004c0a396c027cbb00c69600000100000000000000  
     UPDATE T1 SET COL1 = 4 WHERE COL1 = 1;       
     frame procname=adhoc line=3 stmtstart=44   
     sqlhandle=0x01000600d688e709b85f8904000000000000000000000000  
     EXEC usp_p2       
    inputbuf  
      BEGIN TRANSACTION  
        EXEC usp_p2      
  resource-list  
   ridlock fileid=1 pageid=20789 dbid=6 objectname=AdventureWorks2012.dbo.T2   
   id=lock3136940 mode=X associatedObjectId=72057594057392128  
    owner-list  
     owner id=process689978 mode=X  
    waiter-list  
     waiter id=process6891f8 mode=U requestType=wait  
   keylock hobtid=72057594057457664 dbid=6 objectname=AdventureWorks2012.dbo.T1   
   indexname=nci_T1_COL1 id=lock3136fc0 mode=X   
   associatedObjectId=72057594057457664  
    owner-list  
     owner id=process6891f8 mode=X  
    waiter-list  
     waiter id=process689978 mode=U requestType=wait  
```  
  
###### <a name="profiler-deadlock-graph-event"></a><span data-ttu-id="1f03c-1139">Profiler の Deadlock Graph イベント</span><span class="sxs-lookup"><span data-stu-id="1f03c-1139">Profiler Deadlock Graph Event</span></span>  

 <span data-ttu-id="1f03c-1140">デッドロックに関係するタスクおよびリソースをグラフィカルに表す [!INCLUDE[ssSqlProfiler](../includes/sssqlprofiler-md.md)] のイベントです。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1140">This is an event in [!INCLUDE[ssSqlProfiler](../includes/sssqlprofiler-md.md)] that presents a graphical depiction of the tasks and resources involved in a deadlock.</span></span> <span data-ttu-id="1f03c-1141">次の例は、Deadlock Graph イベントがオンになっている場合の [!INCLUDE[ssSqlProfiler](../includes/sssqlprofiler-md.md)] からの出力を示しています。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1141">The following example shows the output from [!INCLUDE[ssSqlProfiler](../includes/sssqlprofiler-md.md)] when the deadlock graph event is turned on.</span></span>  
  
 <span data-ttu-id="1f03c-1142">![ユーザー プロセスのデッドロックを示す論理フロー図](media/udb9-profilerdeadlockgraphc.gif "ユーザー プロセスのデッドロックを示す論理フロー図")</span><span class="sxs-lookup"><span data-stu-id="1f03c-1142">![Logic flow diagram showing user process deadlock.](media/udb9-profilerdeadlockgraphc.gif "Logic flow diagram showing user process deadlock.")</span></span>  
  
 <span data-ttu-id="1f03c-1143">デッドロックグラフの実行の詳細については [!INCLUDE[ssSqlProfiler](../includes/sssqlprofiler-md.md)] 、「 [SQL Server プロファイラー&#41;&#40;デッドロックグラフの保存](../relational-databases/performance/save-deadlock-graphs-sql-server-profiler.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1143">For more information about running the [!INCLUDE[ssSqlProfiler](../includes/sssqlprofiler-md.md)] deadlock graph, see [Save Deadlock Graphs &#40;SQL Server Profiler&#41;](../relational-databases/performance/save-deadlock-graphs-sql-server-profiler.md).</span></span>  
  
#### <a name="handling-deadlocks"></a><span data-ttu-id="1f03c-1144">デッドロックの処理</span><span class="sxs-lookup"><span data-stu-id="1f03c-1144">Handling Deadlocks</span></span>  

 <span data-ttu-id="1f03c-1145">[!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)]のインスタンスにより、デッドロックの対象となっているトランザクションが判断されると、現在のバッチが終了され、そのトランザクションがロールバックされます。また、このインスタンスからエラー メッセージ 1205 がアプリケーションに返されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1145">When an instance of the [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] chooses a transaction as a deadlock victim, it terminates the current batch, rolls back the transaction, and returns error message 1205 to the application.</span></span>  
  
 `Your transaction (process ID #52) was deadlocked on {lock | communication buffer | thread} resources with another process and has been chosen as the deadlock victim. Rerun your transaction.`  
  
 <span data-ttu-id="1f03c-1146">[!INCLUDE[tsql](../includes/tsql-md.md)] クエリを送信するアプリケーションはどれも、デッドロックの対象と判断される可能性があるため、アプリケーションには、エラー メッセージ 1205 をトラップできるエラー ハンドラーを実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1146">Because any application submitting [!INCLUDE[tsql](../includes/tsql-md.md)] queries can be chosen as the deadlock victim, applications should have an error handler that can trap error message 1205.</span></span> <span data-ttu-id="1f03c-1147">このエラーがアプリケーションでトラップされない場合、アプリケーションでは自身のトランザクションがロールバックされたことが認識されず、エラーが発生することがあります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1147">If an application does not trap the error, the application can proceed unaware that its transaction has been rolled back and errors can occur.</span></span>  
  
 <span data-ttu-id="1f03c-1148">エラー メッセージ 1205 をトラップするエラー ハンドラーを実装すると、アプリケーションでデッドロックの状況に対応し、デッドロックと関連のあるクエリの自動再送信などの救済措置を講じることができます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1148">Implementing an error handler that traps error message 1205 allows an application to handle the deadlock situation and take remedial action (for example, automatically resubmitting the query that was involved in the deadlock).</span></span> <span data-ttu-id="1f03c-1149">クエリを自動的に再送信すると、ユーザーにデッドロックが発生したことを通知する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1149">By resubmitting the query automatically, the user does not need to know that a deadlock occurred.</span></span>  
  
 <span data-ttu-id="1f03c-1150">アプリケーションは、クエリを再送信する前に少しの間停止する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1150">The application should pause briefly before resubmitting its query.</span></span> <span data-ttu-id="1f03c-1151">この一時停止により、デッドロックにかかわっている他のトランザクションでは、処理を完了し、デッドロックのサイクルの一因となっているロックを解放することができます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1151">This gives the other transaction involved in the deadlock a chance to complete and release its locks that formed part of the deadlock cycle.</span></span> <span data-ttu-id="1f03c-1152">このようにすることで、再送信されたクエリからロックが要求されたときに、デッドロックが再発する可能性を最小限に抑えられます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1152">This minimizes the likelihood of the deadlock reoccurring when the resubmitted query requests its locks.</span></span>  
  
#### <a name="minimizing-deadlocks"></a><span data-ttu-id="1f03c-1153">デッドロックの最小化</span><span class="sxs-lookup"><span data-stu-id="1f03c-1153">Minimizing Deadlocks</span></span>  

 <span data-ttu-id="1f03c-1154">デッドロックを完全に回避することはできませんが、コーディング上の一定の規則に従うことにより、デッドロックが発生する可能性を最小限に抑えることができます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1154">Although deadlocks cannot be completely avoided, following certain coding conventions can minimize the chance of generating a deadlock.</span></span> <span data-ttu-id="1f03c-1155">デッドロックの発生数を抑えると、以下の理由から、トランザクションのスループットが向上し、システムのオーバーヘッドが減少します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1155">Minimizing deadlocks can increase transaction throughput and reduce system overhead because fewer transactions are:</span></span>  
  
-   <span data-ttu-id="1f03c-1156">ロールバック (トランザクションが実行したすべての処理の取り消し) の対象となるトランザクションの数が減少します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1156">Rolled back, undoing all the work performed by the transaction.</span></span>  
  
-   <span data-ttu-id="1f03c-1157">デッドロック後にロールバックされたトランザクションをアプリケーションが再実行する場合、対象となるトランザクションの数が減少します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1157">Resubmitted by applications because they were rolled back when deadlocked.</span></span>  
  
 <span data-ttu-id="1f03c-1158">デッドロックを最小限に抑えるには、次の手順を実行します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1158">To help minimize deadlocks:</span></span>  
  
-   <span data-ttu-id="1f03c-1159">同じ順序でオブジェクトにアクセスします。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1159">Access objects in the same order.</span></span>  
  
-   <span data-ttu-id="1f03c-1160">トランザクション内でのユーザーとのやり取りを避けます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1160">Avoid user interaction in transactions.</span></span>  
  
-   <span data-ttu-id="1f03c-1161">トランザクションを短くして 1 つのバッチ内に収めます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1161">Keep transactions short and in one batch.</span></span>  
  
-   <span data-ttu-id="1f03c-1162">低い分離レベルを使用します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1162">Use a lower isolation level.</span></span>  
  
-   <span data-ttu-id="1f03c-1163">行のバージョン管理に基づく分離レベルを使用します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1163">Use a row versioning-based isolation level.</span></span>  
  
    -   <span data-ttu-id="1f03c-1164">READ_COMMITTED_SNAPSHOT データベース オプションを ON に設定して READ COMMITTED トランザクションを有効にして、行のバージョン管理を使用できるようにします。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1164">Set READ_COMMITTED_SNAPSHOT database option ON to enable read-committed transactions to use row versioning.</span></span>  
  
    -   <span data-ttu-id="1f03c-1165">スナップショット分離を使用します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1165">Use snapshot isolation.</span></span>  
  
-   <span data-ttu-id="1f03c-1166">バインドされた接続を使用します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1166">Use bound connections.</span></span>  
  
##### <a name="access-objects-in-the-same-order"></a><span data-ttu-id="1f03c-1167">同じ順序でのオブジェクトへのアクセス</span><span class="sxs-lookup"><span data-stu-id="1f03c-1167">Access Objects in the Same Order</span></span>  

 <span data-ttu-id="1f03c-1168">すべての同時実行トランザクションが同じ順序でオブジェクトにアクセスすると、デッドロックの発生する可能性は低くなります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1168">If all concurrent transactions access objects in the same order, deadlocks are less likely to occur.</span></span> <span data-ttu-id="1f03c-1169">たとえば、2 つの同時実行トランザクションが **Supplier** テーブルでロックを取得してから、**Part** テーブルでロックを取得する場合、一方のトランザクションは、もう一方のトランザクションが完了するまで **Supplier** テーブルでブロックされます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1169">For example, if two concurrent transactions obtain a lock on the **Supplier** table and then on the **Part** table, one transaction is blocked on the **Supplier** table until the other transaction is completed.</span></span> <span data-ttu-id="1f03c-1170">1 番目のトランザクションがコミットまたはロールバックされた後に 2 番目のトランザクションが続行されるので、デッドロックは発生しません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1170">After the first transaction commits or rolls back, the second continues, and a deadlock does not occur.</span></span> <span data-ttu-id="1f03c-1171">すべてのデータ変更にストアド プロシージャを使用すると、オブジェクトへのアクセス順序を統一できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1171">Using stored procedures for all data modifications can standardize the order of accessing objects.</span></span>  
  
 <span data-ttu-id="1f03c-1172">![デッドロック回避の図](media/dedlck2.gif "デッドロック回避の図")</span><span class="sxs-lookup"><span data-stu-id="1f03c-1172">![Diagram showing deadlock avoidance](media/dedlck2.gif "Diagram showing deadlock avoidance")</span></span>  
  
##### <a name="avoid-user-interaction-in-transactions"></a><span data-ttu-id="1f03c-1173">トランザクション内でのユーザーとのやり取りの回避</span><span class="sxs-lookup"><span data-stu-id="1f03c-1173">Avoid User Interaction in Transactions</span></span>  

 <span data-ttu-id="1f03c-1174">ユーザーとのやり取りを含むトランザクションを避けます。ユーザーの介入なしにバッチを実行すれば、ユーザーが手動でクエリに応答する場合、つまりアプリケーションによるパラメーター入力要求に手動で応答する場合などよりはるかに高速に処理できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1174">Avoid writing transactions that include user interaction, because the speed of batches running without user intervention is much faster than the speed at which a user must manually respond to queries, such as replying to a prompt for a parameter requested by an application.</span></span> <span data-ttu-id="1f03c-1175">たとえば、トランザクションがユーザーの入力を待機しているときに、ユーザーが昼食に出ていたり、週末で家に帰っていると、トランザクションの完了は大幅に延期されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1175">For example, if a transaction is waiting for user input and the user goes to lunch or even home for the weekend, the user delays the transaction from completing.</span></span> <span data-ttu-id="1f03c-1176">トランザクションが保持するロックを解除するにはトランザクションのコミットまたはロールバックが必要なので、このような状況ではシステムのスループットが低下してしまいます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1176">This degrades system throughput because any locks held by the transaction are released only when the transaction is committed or rolled back.</span></span> <span data-ttu-id="1f03c-1177">デッドロックが発生しないとしても、トランザクションが完了するまで、同じリソースにアクセスしている他のトランザクションはブロックされます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1177">Even if a deadlock situation does not arise, other transactions accessing the same resources are blocked while waiting for the transaction to complete.</span></span>  
  
##### <a name="keep-transactions-short-and-in-one-batch"></a><span data-ttu-id="1f03c-1178">1 つのバッチ内でのトランザクションの短縮</span><span class="sxs-lookup"><span data-stu-id="1f03c-1178">Keep Transactions Short and in One Batch</span></span>  

 <span data-ttu-id="1f03c-1179">デッドロックは主に、同じデータベースで長時間動作するトランザクションがいくつか同時に実行されている場合に発生します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1179">A deadlock typically occurs when several long-running transactions execute concurrently in the same database.</span></span> <span data-ttu-id="1f03c-1180">トランザクションが長くなれば、排他ロックまたは更新ロックが長時間になり、他の処理をブロックしてしまうので、デッドロックが発生する可能性が高くなります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1180">The longer the transaction, the longer the exclusive or update locks are held, blocking other activity and leading to possible deadlock situations.</span></span>  
  
 <span data-ttu-id="1f03c-1181">トランザクションを 1 つのバッチ内に収めると、トランザクション実行時のネットワーク経由のやり取りを最小限に抑えられ、トランザクションの完了やロックの解除が遅延する可能性を低くすることができます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1181">Keeping transactions in one batch minimizes network roundtrips during a transaction, reducing possible delays in completing the transaction and releasing locks.</span></span>  
  
##### <a name="use-a-lower-isolation-level"></a><span data-ttu-id="1f03c-1182">低い分離レベルの使用</span><span class="sxs-lookup"><span data-stu-id="1f03c-1182">Use a Lower Isolation Level</span></span>  

 <span data-ttu-id="1f03c-1183">低い分離レベルでトランザクションが実行可能かどうかを調べます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1183">Determine whether a transaction can run at a lower isolation level.</span></span> <span data-ttu-id="1f03c-1184">READ COMMITTED を実装すると、トランザクションは、別のトランザクションが以前に読み取った (変更されていない) データを読み取ることができるので、最初のトランザクションが完了するまで待機する必要がありません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1184">Implementing read committed allows a transaction to read data previously read (not modified) by another transaction without waiting for the first transaction to complete.</span></span> <span data-ttu-id="1f03c-1185">READ COMMITTED などの低い分離レベルを使用すると、SERIALIZABLE などの高い分離レベルの場合よりも共有ロックの保持時間が短くなります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1185">Using a lower isolation level, such as read committed, holds shared locks for a shorter duration than a higher isolation level, such as serializable.</span></span> <span data-ttu-id="1f03c-1186">これにより、ロックの競合が減少します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1186">This reduces locking contention.</span></span>  
  
##### <a name="use-a-row-versioning-based-isolation-level"></a><span data-ttu-id="1f03c-1187">行のバージョン管理に基づく分離レベルの使用</span><span class="sxs-lookup"><span data-stu-id="1f03c-1187">Use a Row Versioning-based Isolation Level</span></span>  

 <span data-ttu-id="1f03c-1188">READ_COMMITTED_SNAPSHOT データベース オプションが ON に設定されている場合、READ COMMITTED 分離レベルで実行されているトランザクションでは、読み取り操作中に、共有ロックではなく行のバージョン管理を使用します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1188">When the READ_COMMITTED_SNAPSHOT database option is set ON, a transaction running under read committed isolation level uses row versioning rather than shared locks during read operations.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="1f03c-1189">一部のアプリケーションは、READ COMMITTED 分離レベルのロックおよびブロックの動作に依存します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1189">Some applications rely upon locking and blocking behavior of read committed isolation.</span></span> <span data-ttu-id="1f03c-1190">このようなアプリケーションについては、このオプションを使用する前に多少の変更が必要になります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1190">For these applications, some change is required before this option can be enabled.</span></span>  
  
 <span data-ttu-id="1f03c-1191">スナップショット分離レベルでも行のバージョン管理を使用します。行のバージョン管理では、読み取り操作中に共有ロックを使用しません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1191">Snapshot isolation also uses row versioning, which does not use shared locks during read operations.</span></span> <span data-ttu-id="1f03c-1192">スナップショット分離レベルでトランザクションを実行する前に、ALLOW_SNAPSHOT_ISOLATION データベース オプションを ON に設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1192">Before a transaction can run under snapshot isolation, the ALLOW_SNAPSHOT_ISOLATION database option must be set ON.</span></span>  
  
 <span data-ttu-id="1f03c-1193">これらの分離レベルを実装すると、読み取り操作と書き込み操作の間に発生する可能性があるデッドロックを最小限に抑えることができます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1193">Implement these isolation levels to minimize deadlocks that can occur between read and write operations.</span></span>  
  
##### <a name="use-bound-connections"></a><span data-ttu-id="1f03c-1194">バインドされた接続の使用</span><span class="sxs-lookup"><span data-stu-id="1f03c-1194">Use Bound Connections</span></span>  

 <span data-ttu-id="1f03c-1195">バインドされた接続を使用すると、同じアプリケーションによって開かれた複数の接続が相互に協調動作できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1195">Using bound connections, two or more connections opened by the same application can cooperate with each other.</span></span> <span data-ttu-id="1f03c-1196">最初の接続が取得したロックと同じように次の接続が取得したロックも保持されます。また、その逆の場合も同様に保持されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1196">Any locks acquired by the secondary connections are held as if they were acquired by the primary connection, and vice versa.</span></span> <span data-ttu-id="1f03c-1197">したがって、相互にブロックすることはありません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1197">Therefore they do not block each other.</span></span>  
  
### <a name="lock-partitioning"></a><span data-ttu-id="1f03c-1198">ロックのパーティション分割</span><span class="sxs-lookup"><span data-stu-id="1f03c-1198">Lock Partitioning</span></span>  

 <span data-ttu-id="1f03c-1199">大規模なコンピューター システムでは、頻繁に参照されるオブジェクトのロックがパフォーマンスのボトルネックになることがあります。これは、ロックの獲得と解放により、内部ロック リソースで競合が発生するためです。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1199">For large computer systems, locks on frequently referenced objects can become a performance bottleneck as acquiring and releasing locks place contention on internal locking resources.</span></span> <span data-ttu-id="1f03c-1200">ロックのパーティション分割を行うと、単一のロック リソースが複数のロック リソースに分割されるので、ロックのパフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1200">Lock partitioning enhances locking performance by splitting a single lock resource into multiple lock resources.</span></span> <span data-ttu-id="1f03c-1201">この機能は、16 基以上の CPU を搭載しているシステムでのみ使用でき、自動的に有効になります。この機能を無効にすることはできません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1201">This feature is only available for systems with 16 or more CPUs, and is automatically enabled and cannot be disabled.</span></span> <span data-ttu-id="1f03c-1202">パーティション分割できるのはオブジェクト ロックのみです。サブタイプがあるオブジェクト ロックはパーティション分割できません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1202">Only object locks can be partitioned.Object locks that have a subtype are not partitioned.</span></span> <span data-ttu-id="1f03c-1203">詳しくは、「[sys.dm_tran_locks &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-locks-transact-sql)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1203">For more information, see [sys.dm_tran_locks &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-locks-transact-sql).</span></span>  
  
#### <a name="understanding-lock-partitioning"></a><span data-ttu-id="1f03c-1204">ロックのパーティション分割について</span><span class="sxs-lookup"><span data-stu-id="1f03c-1204">Understanding Lock Partitioning</span></span>  

 <span data-ttu-id="1f03c-1205">ロック タスクでは、複数の共有リソースへのアクセスが行われます。これらのうち、次の 2 つがロックのパーティション分割によって最適化されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1205">Locking tasks access several shared resources, two of which are optimized by lock partitioning:</span></span>  
  
-   <span data-ttu-id="1f03c-1206">**スピンロック**。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1206">**Spinlock**.</span></span> <span data-ttu-id="1f03c-1207">行やテーブルなどのロック リソースへのアクセスを制御します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1207">This controls access to a lock resource, such as a row or a table.</span></span>  
  
     <span data-ttu-id="1f03c-1208">ロックのパーティション分割を行わない場合は、1 つのスピンロックにより単一のロック リソースのすべてのロック要求が管理されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1208">Without lock partitioning, one spinlock manages all lock requests for a single lock resource.</span></span> <span data-ttu-id="1f03c-1209">大量の処理が行われるシステムでは、スピンロックが使用できるようになるまでロック要求が待機するので、競合が発生する場合があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1209">On systems that experience a large volume of activity, contention can occur as lock requests wait for the spinlock to become available.</span></span> <span data-ttu-id="1f03c-1210">この状況では、ロックの獲得がボトルネックになり、パフォーマンスが低下することがあります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1210">Under this situation, acquiring locks can become a bottleneck and can negatively impact performance.</span></span>  
  
     <span data-ttu-id="1f03c-1211">単一のロック リソースの競合を減らすには、ロックのパーティション分割によって単一のロック リソースを複数のロック リソースに分割し、複数のスピンロックに負荷を分散します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1211">To reduce contention on a single lock resource, lock partitioning splits a single lock resource into multiple lock resources to distribute the load across multiple spinlocks.</span></span>  
  
-   <span data-ttu-id="1f03c-1212">**メモリ**。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1212">**Memory**.</span></span> <span data-ttu-id="1f03c-1213">ロック リソースの構造を格納するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1213">This is used to store the lock resource structures.</span></span>  
  
     <span data-ttu-id="1f03c-1214">スピンロックが獲得されると、ロック構造がメモリに格納されます。その後、ロック構造へのアクセスが行われ、場合によっては変更されることがあります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1214">Once the spinlock is acquired, lock structures are stored in memory and then accessed and possibly modified.</span></span> <span data-ttu-id="1f03c-1215">ロックへのアクセスを複数のリソースに分散すると、CPU 間でメモリ ブロックを転送する必要がなくなり、パフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1215">Distributing lock access across multiple resources helps to eliminate the need to transfer memory blocks between CPUs, which will help to improve performance.</span></span>  
  
#### <a name="implementing-and-monitoring-lock-partitioning"></a><span data-ttu-id="1f03c-1216">ロックのパーティション分割の実装と監視</span><span class="sxs-lookup"><span data-stu-id="1f03c-1216">Implementing and Monitoring Lock Partitioning</span></span>  

 <span data-ttu-id="1f03c-1217">ロックのパーティション分割は、16 基以上の CPU を搭載しているシステムでは既定で有効になっています。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1217">Lock partitioning is turned on by default for systems with 16 or more CPUs.</span></span> <span data-ttu-id="1f03c-1218">ロックのパーティション分割が有効になっていると、情報メッセージが [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] エラー ログに記録されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1218">When lock partitioning is enabled, an informational message is recorded in the [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] error log.</span></span>  
  
 <span data-ttu-id="1f03c-1219">パーティション分割されたリソースのロックを獲得するときの規則を次に示します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1219">When acquiring locks on a partitioned resource:</span></span>  
  
-   <span data-ttu-id="1f03c-1220">単一のパーティションに対して獲得されるロック モードは、NL、SCH-S、IS、IU、および IX のみです。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1220">Only NL, SCH-S, IS, IU, and IX lock modes are acquired on a single partition.</span></span>  
  
-   <span data-ttu-id="1f03c-1221">共有 (S) ロック、排他 (X) ロック、および NL、SCH-S、IS、IU、IX 以外のモードの他のロックは、パーティション ID が 0 のパーティションから、パーティション ID 順に獲得される必要があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1221">Shared (S), exclusive (X), and other locks in modes other than NL, SCH-S, IS, IU, and IX must be acquired on all partitions starting with partition ID 0 and following in partition ID order.</span></span> <span data-ttu-id="1f03c-1222">パーティション分割されたリソースでは、パーティションごとに別のロックが獲得されます。そのため、これらのパーティション分割されたリソースのロックでは、パーティション分割されていないリソースの同じモードのロックよりも多くのメモリが使用されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1222">These locks on a partitioned resource will use more memory than locks in the same mode on a non-partitioned resource since each partition is effectively a separate lock.</span></span> <span data-ttu-id="1f03c-1223">メモリの増加量は、パーティションの数によって決まります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1223">The memory increase is determined by the number of partitions.</span></span> <span data-ttu-id="1f03c-1224">Windows パフォーマンス モニターの [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] ロック カウンターにより、パーティション分割されたロックとパーティション分割されていないロックによって使用されたメモリに関する情報が表示されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1224">The [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] lock counters in the Windows Performance Monitor will display information about memory used by partitioned and non-partitioned locks.</span></span>  
  
 <span data-ttu-id="1f03c-1225">トランザクションは、開始したときにパーティションに割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1225">A transaction is assigned to a partition when the transaction starts.</span></span> <span data-ttu-id="1f03c-1226">トランザクションでは、パーティション分割できるすべてのロック要求により、そのトランザクションに割り当てられたパーティションが使用されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1226">For the transaction, all lock requests that can be partitioned use the partition assigned to that transaction.</span></span> <span data-ttu-id="1f03c-1227">この方法により、複数のトランザクションから同じオブジェクトのロック リソースへのアクセスが異なるパーティションに分散されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1227">By this method, access to lock resources of the same object by different transactions is distributed across different partitions.</span></span>  
  
 <span data-ttu-id="1f03c-1228">sys.dm_tran_locks 動的管理ビューの resource_lock_partition 列により、ロックがパーティション分割されたリソースのロック パーティション ID が提供されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1228">The resource_lock_partition column in the sys.dm_tran_locks Dynamic Management View provides the lock partition ID for a lock partitioned resource.</span></span> <span data-ttu-id="1f03c-1229">詳しくは、「[sys.dm_tran_locks &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-locks-transact-sql)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1229">For more information, see [sys.dm_tran_locks &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-locks-transact-sql).</span></span>  
  
 <span data-ttu-id="1f03c-1230">[!INCLUDE[ssSqlProfiler](../includes/sssqlprofiler-md.md)] の Locks イベントでは、BigintData1 列により、ロックがパーティション分割されたリソースのロック パーティション ID が提供されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1230">Under the Locks event in [!INCLUDE[ssSqlProfiler](../includes/sssqlprofiler-md.md)], the BigintData1 column provides the lock partition ID for a lock partitioned resource.</span></span>  
  
#### <a name="working-with-lock-partitioning"></a><span data-ttu-id="1f03c-1231">ロックのパーティション分割を使用した作業</span><span class="sxs-lookup"><span data-stu-id="1f03c-1231">Working with Lock Partitioning</span></span>  

 <span data-ttu-id="1f03c-1232">次に、ロックのパーティション分割の例を示します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1232">The following code examples illustrate lock partitioning.</span></span> <span data-ttu-id="1f03c-1233">この例では、16 基の CPU を搭載しているコンピューター システムでのロックのパーティション分割の動作を示すために、2 つのトランザクションを 2 つの異なるセッションで実行します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1233">In the examples, two transactions are executed in two different sessions in order to show lock partitioning behavior on a computer system with 16 CPUs.</span></span>  
  
 <span data-ttu-id="1f03c-1234">これらの [!INCLUDE[tsql](../includes/tsql-md.md)] ステートメントにより、その後の例で使用するテスト オブジェクトが作成されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1234">These [!INCLUDE[tsql](../includes/tsql-md.md)] statements create test objects that are used in the examples that follow.</span></span>  
  
```sql  
-- Create a test table.  
CREATE TABLE TestTable  
    (col1        int);  
GO  
  
-- Create a clustered index on the table.  
CREATE CLUSTERED INDEX ci_TestTable   
    ON TestTable (col1);  
GO  
  
-- Populate the table.  
INSERT INTO TestTable VALUES (1);  
GO  
```  
  
##### <a name="example-a"></a><span data-ttu-id="1f03c-1235">例 A</span><span class="sxs-lookup"><span data-stu-id="1f03c-1235">Example A</span></span>  

 <span data-ttu-id="1f03c-1236">セッション 1:</span><span class="sxs-lookup"><span data-stu-id="1f03c-1236">Session 1:</span></span>  
  
 <span data-ttu-id="1f03c-1237">あるトランザクションで `SELECT` ステートメントが実行されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1237">A `SELECT` statement is executed under a transaction.</span></span> <span data-ttu-id="1f03c-1238">`HOLDLOCK` ロック ヒントにより、このステートメントではテーブルのインテント共有 (IS) ロックが獲得および保持されます (ここでは、説明のため、行ロックとページ ロックは無視します)。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1238">Because of the `HOLDLOCK` lock hint, this statement will acquire and retain an Intent shared (IS) lock on the table (for this illustration, row and page locks are ignored).</span></span> <span data-ttu-id="1f03c-1239">IS ロックは、トランザクションに割り当てられたパーティションに対してのみ獲得されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1239">The IS lock will be acquired only on the partition assigned to the transaction.</span></span> <span data-ttu-id="1f03c-1240">この例では、パーティション ID 7 に対して IS ロックが獲得されるものとします。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1240">For this example, it is assumed that the IS lock is acquired on partition ID 7.</span></span>  
  
```sql  
-- Start a transaction.  
BEGIN TRANSACTION  
    -- This SELECT statement will acquire an IS lock on the table.  
    SELECT col1  
        FROM TestTable  
        WITH (HOLDLOCK);  
```  
  
 <span data-ttu-id="1f03c-1241">セッション 2:</span><span class="sxs-lookup"><span data-stu-id="1f03c-1241">Session 2:</span></span>  
  
 <span data-ttu-id="1f03c-1242">トランザクションが開始され、このトランザクションで実行されている `SELECT` ステートメントにより、テーブルの共有 (S) ロックが獲得および保持されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1242">A transaction is started, and the `SELECT` statement running under this transaction will acquire and retain a shared (S) lock on the table.</span></span> <span data-ttu-id="1f03c-1243">S ロックはすべてのパーティションに対して獲得されるため、複数のテーブル ロック (各パーティションに 1 つのロック) が存在することになります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1243">The S lock will be acquired on all partitions which results in multiple table locks, one for each partition.</span></span> <span data-ttu-id="1f03c-1244">たとえば、16 基の CPU を搭載しているシステムで、ロック パーティション ID 0 ～ 15 に 16 個の S ロックが発行されるとします。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1244">For example, on a 16-cpu system, 16 S locks will be issued across lock partition IDs 0-15.</span></span> <span data-ttu-id="1f03c-1245">S ロックは、セッション 1 のトランザクションによりパーティション ID 7 に対して保持されている IS ロックと互換性があるので、トランザクション間のブロッキングは発生しません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1245">Because the S lock is compatible with the IS lock being held on partition ID 7 by the transaction in session 1, there is no blocking between transactions.</span></span>  
  
```sql  
BEGIN TRANSACTION  
    SELECT col1  
        FROM TestTable  
        WITH (TABLOCK, HOLDLOCK);  
```  
  
 <span data-ttu-id="1f03c-1246">セッション 1:</span><span class="sxs-lookup"><span data-stu-id="1f03c-1246">Session 1:</span></span>  
  
 <span data-ttu-id="1f03c-1247">セッション 1 において依然としてアクティブなトランザクションで次の `SELECT` ステートメントが実行されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1247">The following `SELECT` statement is executed under the transaction that is still active under session 1.</span></span> <span data-ttu-id="1f03c-1248">排他 (X) テーブル ロック ヒントにより、このトランザクションではテーブルの X ロックの獲得が試行されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1248">Because of the exclusive (X) table lock hint, the transaction will attempt to acquire an X lock on the table.</span></span> <span data-ttu-id="1f03c-1249">ただし、セッション 2 のトランザクションで保持されている S ロックにより、パーティション ID 0 で X ロックがブロックされます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1249">However, the S lock that is being held by the transaction in session 2 will block the X lock at partition ID 0.</span></span>  
  
```sql  
SELECT col1  
    FROM TestTable  
    WITH (TABLOCKX);  
```  
  
##### <a name="example-b"></a><span data-ttu-id="1f03c-1250">例 B</span><span class="sxs-lookup"><span data-stu-id="1f03c-1250">Example B</span></span>  

 <span data-ttu-id="1f03c-1251">セッション 1:</span><span class="sxs-lookup"><span data-stu-id="1f03c-1251">Session 1:</span></span>  
  
 <span data-ttu-id="1f03c-1252">あるトランザクションで `SELECT` ステートメントが実行されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1252">A `SELECT` statement is executed under a transaction.</span></span> <span data-ttu-id="1f03c-1253">`HOLDLOCK` ロック ヒントにより、このステートメントではテーブルのインテント共有 (IS) ロックが獲得および保持されます (ここでは、説明のため、行ロックとページ ロックは無視します)。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1253">Because of the `HOLDLOCK` lock hint, this statement will acquire and retain an Intent shared (IS) lock on the table (for this illustration, row and page locks are ignored).</span></span> <span data-ttu-id="1f03c-1254">IS ロックは、トランザクションに割り当てられたパーティションに対してのみ獲得されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1254">The IS lock will be acquired only on the partition assigned to the transaction.</span></span> <span data-ttu-id="1f03c-1255">この例では、パーティション ID 6 に対して IS ロックが獲得されるものとします。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1255">For this example, it is assumed that the IS lock is acquired on partition ID 6.</span></span>  
  
```sql  
-- Start a transaction.  
BEGIN TRANSACTION  
    -- This SELECT statement will acquire an IS lock on the table.  
    SELECT col1  
        FROM TestTable  
        WITH (HOLDLOCK);  
```  
  
 <span data-ttu-id="1f03c-1256">セッション 2:</span><span class="sxs-lookup"><span data-stu-id="1f03c-1256">Session 2:</span></span>  
  
 <span data-ttu-id="1f03c-1257">あるトランザクションで `SELECT` ステートメントが実行されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1257">A `SELECT` statement is executed under a transaction.</span></span> <span data-ttu-id="1f03c-1258">`TABLOCKX` ロック ヒントにより、このトランザクションではテーブルに対して排他 (X) ロックの獲得が試行されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1258">Because of the `TABLOCKX` lock hint, the transaction tries to acquire an exclusive (X) lock on the table.</span></span> <span data-ttu-id="1f03c-1259">X ロックはパーティション ID が 0 のパーティションから、パーティション ID 順に獲得される必要があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1259">Remember that the X lock must be acquired on all partitions starting with partition ID 0.</span></span> <span data-ttu-id="1f03c-1260">X ロックはパーティション ID 0 ～ 5 のパーティションに対して獲得されますが、パーティション ID 6 に対して獲得された IS ロックによりブロックされます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1260">The X lock will be acquired on all partitions IDs 0-5 but will be blocked by the IS lock that is acquired on partition ID 6.</span></span>  
  
 <span data-ttu-id="1f03c-1261">X ロックが獲得されていないパーティション ID 7 ～ 15 に対しては、他のトランザクションがロックの獲得を続行できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1261">On partition IDs 7-15 that the X lock has not yet reached, other transactions can continue to acquire locks.</span></span>  
  
```sql  
BEGIN TRANSACTION  
    SELECT col1  
        FROM TestTable  
        WITH (TABLOCKX, HOLDLOCK);  
```  
  
 <span data-ttu-id="1f03c-1262">[このガイドの [](#Top) ![トップに戻る] リンクで使用される矢印アイコン](media/uparrow16x16.gif "[トップに戻る] リンクで使用される矢印アイコン")</span><span class="sxs-lookup"><span data-stu-id="1f03c-1262">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
##  <a name="row-versioning-based-isolation-levels-in-the-database-engine"></a><a name="Row_versioning"></a><span data-ttu-id="1f03c-1263">データベースエンジン内の行のバージョン管理に基づく分離レベル</span><span class="sxs-lookup"><span data-stu-id="1f03c-1263">Row Versioning-based Isolation Levels in the Database Engine</span></span>  

 <span data-ttu-id="1f03c-1264">SQL Server 2005 以降のデータベース エンジンでは、既存の READ COMMITTED トランザクション分離レベルで、行のバージョン管理によるステートメント レベルのスナップショットを使用できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1264">Starting with SQL Server 2005, the Database Engine offers an implementation of an existing transaction isolation level, read committed, that provides a statement level snapshot using row versioning.</span></span> <span data-ttu-id="1f03c-1265">SQL Server データベース エンジンでは、同じく行のバージョン管理によりトランザクション レベルのスナップショットを提供する SNAPSHOT トランザクション分離レベルも使用できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1265">SQL Server Database Engine also offers a transaction isolation level, snapshot, that provides a transaction level snapshot also using row versioning.</span></span>  
  
 <span data-ttu-id="1f03c-1266">行のバージョン管理とは、行が変更または削除されると書き込み時コピーのメカニズムを起動する、[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] の一般的なフレームワークです。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1266">Row versioning is a general framework in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] that invokes a copy-on-write mechanism when a row is modified or deleted.</span></span> <span data-ttu-id="1f03c-1267">このフレームワークでは、トランザクション内の一貫性に関する以前の状態を必要とするようなトランザクションの実行中に、行の古いバージョンをそのトランザクションで使用できることが求められます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1267">This requires that while the transaction is running, the old version of the row must be available for transactions that require an earlier transactionally consistent state.</span></span> <span data-ttu-id="1f03c-1268">行のバージョン管理は、次の目的で使用されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1268">Row versioning is used to do the following:</span></span>  
  
-   <span data-ttu-id="1f03c-1269">トリガーで**挿入**されたテーブルまたは**削除**されたテーブルを作成する。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1269">Build the **inserted** and **deleted** tables in triggers.</span></span> <span data-ttu-id="1f03c-1270">トリガーによって変更された行はすべて、バージョン化されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1270">Any rows modified by the trigger are versioned.</span></span> <span data-ttu-id="1f03c-1271">これには、トリガーによりデータが変更された行だけでなく、トリガーを起動したステートメントにより変更された行も含まれます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1271">This includes the rows modified by the statement that launched the trigger, as well as any data modifications made by the trigger.</span></span>  
  
-   <span data-ttu-id="1f03c-1272">複数のアクティブな結果セット (MARS) をサポートする。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1272">Support Multiple Active Result Sets (MARS).</span></span> <span data-ttu-id="1f03c-1273">アクティブな結果セットが存在するときに、MARS セッションでデータ変更ステートメント (INSERT、UPDATE、DELETE など) が実行された場合、その変更ステートメントの影響を受けた行はバージョン化されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1273">If a MARS session issues a data modification statement (such as INSERT, UPDATE, or DELETE) at a time there is an active result set, the rows affected by the modification statement are versioned.</span></span>  
  
-   <span data-ttu-id="1f03c-1274">ONLINE オプションを指定するインデックス操作をサポートする。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1274">Support index operations that specify the ONLINE option.</span></span>  
  
-   <span data-ttu-id="1f03c-1275">次の行バージョン ベースのトランザクション分離レベルをサポートする。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1275">Support row versioning-based transaction isolation levels:</span></span>  
  
    -   <span data-ttu-id="1f03c-1276">行のバージョン管理を使用してステートメントレベルの読み取りの一貫性を保証する新しい READ COMMITTED 分離レベルの実装。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1276">A new implementation of read committed isolation level that uses row versioning to provide statement-level read consistency.</span></span>  
  
    -   <span data-ttu-id="1f03c-1277">新しい分離レベルであるスナップショット。このレベルにより、トランザクションレベルの読み取り一貫性を実現します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1277">A new isolation level, snapshot, to provide transaction-level read consistency.</span></span>  
  
 <span data-ttu-id="1f03c-1278">`tempdb` データベースには、バージョン ストア用の十分なディスク領域が必要です。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1278">The `tempdb` database must have enough space for the version store.</span></span> <span data-ttu-id="1f03c-1279">`tempdb` がいっぱいになると、更新操作では、操作を完了するためにバージョンの生成を停止して処理を続行しますが、読み取り操作は失敗することがあります。これは、必要な特定の行のバージョンが存在しないためです。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1279">When `tempdb` is full, update operations will stop generating versions and continue to succeed, but read operations might fail because a particular row version that is needed no longer exists.</span></span> <span data-ttu-id="1f03c-1280">特定の行のバージョンが存在しないことにより、トリガー、MARS、オンラインのインデックス構築などの操作が影響を受けます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1280">This affects operations like triggers, MARS, and online indexing.</span></span>  
  
 <span data-ttu-id="1f03c-1281">READ COMMITTED トランザクションとスナップショット トランザクションで行のバージョン管理を使用するには、次の 2 つの手順を実行します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1281">Using row versioning for read-committed and snapshot transactions is a two-step process:</span></span>  
  
1.  <span data-ttu-id="1f03c-1282">READ_COMMITTED_SNAPSHOT データベース オプションと ALLOW_SNAPSHOT_ISOLATION データベース オプションのいずれかまたは両方を ON に設定します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1282">Set either or both the READ_COMMITTED_SNAPSHOT and ALLOW_SNAPSHOT_ISOLATION database options ON.</span></span>  
  
2.  <span data-ttu-id="1f03c-1283">次の説明に従って、アプリケーションで適切なトランザクション分離レベルを設定します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1283">Set the appropriate transaction isolation level in an application:</span></span>  
  
    -   <span data-ttu-id="1f03c-1284">READ_COMMITTED_SNAPSHOT データベース オプションを ON に設定すると、READ COMMITTED 分離レベルを設定するトランザクションで行のバージョン管理が使用されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1284">When the READ_COMMITTED_SNAPSHOT database option is ON, transactions setting the read committed isolation level use row versioning.</span></span>  
  
    -   <span data-ttu-id="1f03c-1285">ALLOW_SNAPSHOT_ISOLATION データベース オプションを ON に設定すると、トランザクションでスナップショット分離レベルを設定できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1285">When the ALLOW_SNAPSHOT_ISOLATION database option is ON, transactions can set the snapshot isolation level.</span></span>  
  
 <span data-ttu-id="1f03c-1286">READ_COMMITTED_SNAPSHOT データベース オプションまたは ALLOW_SNAPSHOT_ISOLATION データベース オプションのいずれかを ON に設定すると、[!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)]により、行のバージョン管理を使用してデータを操作する各トランザクションにトランザクション シーケンス番号 (XSN) が割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1286">When either READ_COMMITTED_SNAPSHOT or ALLOW_SNAPSHOT_ISOLATION database option is set ON, the [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] assigns a transaction sequence number (XSN) to each transaction that manipulates data using row versioning.</span></span> <span data-ttu-id="1f03c-1287">トランザクションは、BEGIN TRANSACTION ステートメントが実行されたときに開始されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1287">Transactions start at the time a BEGIN TRANSACTION statement is executed.</span></span> <span data-ttu-id="1f03c-1288">ただし、トランザクション シーケンス番号が始まるのは、BEGIN TRANSACTION ステートメントの後に実行される最初の読み取り操作または書き込み操作からです。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1288">However, the transaction sequence number starts with the first read or write operation after the BEGIN TRANSACTION statement.</span></span> <span data-ttu-id="1f03c-1289">トランザクション シーケンス番号は、トランザクションに割り当てられるたびに 1 ずつ増加します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1289">The transaction sequence number is incremented by one each time it is assigned.</span></span>  
  
 <span data-ttu-id="1f03c-1290">READ_COMMITTED_SNAPSHOT データベース オプションまたは ALLOW_SNAPSHOT_ISOLATION データベース オプションのいずれかを ON に設定すると、データベースで実行されるすべてのデータ変更の論理コピー (バージョン) が保持されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1290">When either the READ_COMMITTED_SNAPSHOT or ALLOW_SNAPSHOT_ISOLATION database options are ON, logical copies (versions) are maintained for all data modifications performed in the database.</span></span> <span data-ttu-id="1f03c-1291">特定のトランザクションで行が変更されるたびに、[!INCLUDE[ssDE](../includes/ssde-md.md)]のインスタンスにより、行の以前にコミットされたイメージのバージョンが `tempdb` に格納されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1291">Every time a row is modified by a specific transaction, the instance of the [!INCLUDE[ssDE](../includes/ssde-md.md)] stores a version of the previously committed image of the row in `tempdb`.</span></span> <span data-ttu-id="1f03c-1292">各バージョンには、その変更を行ったトランザクションのトランザクション シーケンス番号が付きます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1292">Each version is marked with the transaction sequence number of the transaction that made the change.</span></span> <span data-ttu-id="1f03c-1293">変更された行のバージョンは、リンク リストを使用して連結されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1293">The versions of modified rows are chained using a link list.</span></span> <span data-ttu-id="1f03c-1294">最新の行の値は、常に現在のデータベースに格納され、`tempdb` に格納されているバージョン管理された行に連結されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1294">The newest row value is always stored in the current database and chained to the versioned rows stored in `tempdb`.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="1f03c-1295">ラージ オブジェクト (LOB) の変更については、変更された部分のみが `tempdb` のバージョン ストアにコピーされます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1295">For modification of large objects (LOBs), only the changed fragment is copied to the version store in `tempdb`.</span></span>  
  
 <span data-ttu-id="1f03c-1296">バージョンストアに格納されているバージョンは、行のバージョン管理に基づく分離レベルで実行されるトランザクションで必要な限り保持されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1296">Row versions are held long enough to satisfy the requirements of transactions running under row versioning-based isolation levels.</span></span> <span data-ttu-id="1f03c-1297">[!INCLUDE[ssDE](../includes/ssde-md.md)]により、必要なトランザクション シーケンス番号の中で最も小さい番号が追跡され、それよりもトランザクション シーケンス番号が小さい行のバージョンは定期的にすべて削除されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1297">The [!INCLUDE[ssDE](../includes/ssde-md.md)] tracks the earliest useful transaction sequence number and periodically deletes all row versions stamped with transaction sequence numbers that are lower than the earliest useful sequence number.</span></span>  
  
 <span data-ttu-id="1f03c-1298">両方のデータベース オプションを OFF に設定すると、トリガーまたは MARS セッションで変更された行、あるいは ONLINE インデックス操作で読み取られた行のみがバージョン管理されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1298">When both database options are set to OFF, only rows modified by triggers or MARS sessions, or read by ONLINE index operations, are versioned.</span></span> <span data-ttu-id="1f03c-1299">これらの行のバージョンは、必要ではなくなった時点で解放されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1299">Those row versions are released when no longer needed.</span></span> <span data-ttu-id="1f03c-1300">また、定期的に実行されるバックグラウンドのスレッドにより、古い行のバージョンが削除されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1300">A background thread periodically executes to remove stale row versions.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="1f03c-1301">トランザクションの実行時間が短い場合、変更された行のバージョンは、`tempdb` データベースのディスク ファイルに書き込まれずにバッファー プールにキャッシュされる場合があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1301">For short-running transactions, a version of a modified row may get cached in the buffer pool without getting written into the disk files of the `tempdb` database.</span></span> <span data-ttu-id="1f03c-1302">バージョン管理された行が必要とされる時間が短い場合、その行のバージョンは単純にバッファー プールから削除されるので、I/O のオーバーヘッドが発生しない場合もあります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1302">If the need for the versioned row is short-lived, it will simply get dropped from the buffer pool and may not necessarily incur I/O overhead.</span></span>  
  
### <a name="behavior-when-reading-data"></a><span data-ttu-id="1f03c-1303">データ読み取り時の動作</span><span class="sxs-lookup"><span data-stu-id="1f03c-1303">Behavior When Reading Data</span></span>  

 <span data-ttu-id="1f03c-1304">行のバージョン管理に基づく分離レベルで実行されているトランザクションによりデータが読み取られるとき、読み取り操作では、読み取るデータに対して共有 (S) ロックが獲得されないので、データを変更しているトランザクションはブロックされません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1304">When transactions running under row versioning-based isolation read data, the read operations do not acquire shared (S) locks on the data being read, and therefore do not block transactions that are modifying data.</span></span> <span data-ttu-id="1f03c-1305">また、リソースのロックによるオーバーヘッドは、獲得されるロックの数が少ないほど小さくなります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1305">Also, the overhead of locking resources is minimized as the number of locks acquired is reduced.</span></span> <span data-ttu-id="1f03c-1306">行のバージョン管理を使用する READ COMMITTED 分離とスナップショット分離は、バージョン管理されたデータの読み取りの一貫性をステートメントレベルまたはトランザクションレベルで保証するようにデザインされています。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1306">Read committed isolation using row versioning and snapshot isolation are designed to provide statement-level or transaction-level read consistencies of versioned data.</span></span>  
  
 <span data-ttu-id="1f03c-1307">行のバージョン管理に基づく分離レベルで実行されているトランザクションを含むすべてのクエリは、コンパイルおよび実行中に Sch-S (スキーマ安定度) ロックを獲得します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1307">All queries, including transactions running under row versioning-based isolation levels, acquire Sch-S (schema stability) locks during compilation and execution.</span></span> <span data-ttu-id="1f03c-1308">このため、同時実行トランザクションがテーブルの Sch-M (スキーマ修正) ロックを保持している場合、クエリはブロックされます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1308">Because of this, queries are blocked when a concurrent transaction holds a Sch-M (schema modification) lock on the table.</span></span> <span data-ttu-id="1f03c-1309">たとえば、データ定義言語 (DDL) 操作では、テーブルのスキーマ情報を変更する前にスキーマ修正 (Sch-M) ロックを取得します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1309">For example, a data definition language (DDL) operation acquires a Sch-M lock before it modifies the schema information of the table.</span></span> <span data-ttu-id="1f03c-1310">行のバージョン管理に基づく分離レベルで実行されているトランザクションを含むクエリ トランザクションは、Sch-S ロックを獲得しようとするとブロックされます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1310">Query transactions, including those running under a row versioning-based isolation level, are blocked when attempting to acquire a Sch-S lock.</span></span> <span data-ttu-id="1f03c-1311">一方、スキーマ安定度 (Sch-S) ロックを保持するクエリによって、スキーマ修正 (Sch-M) ロックを取得しようとする同時実行トランザクションはブロックされます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1311">Conversely, a query holding a Sch-S lock blocks a concurrent transaction that attempts to acquire a Sch-M lock.</span></span>  
  
 <span data-ttu-id="1f03c-1312">スナップショット分離レベルを使用するトランザクションが開始されると、[!INCLUDE[ssDE](../includes/ssde-md.md)]のインスタンスにより、現在アクティブなトランザクションがすべて記録されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1312">When a transaction using the snapshot isolation level starts, the instance of the [!INCLUDE[ssDE](../includes/ssde-md.md)] records all of the currently active transactions.</span></span> <span data-ttu-id="1f03c-1313">スナップショット トランザクションでバージョン チェーンを持つ行が読み取られると、[!INCLUDE[ssDE](../includes/ssde-md.md)]によりチェーンが追跡され、次のトランザクション シーケンス番号を持つ行が取得されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1313">When the snapshot transaction reads a row that has a version chain, the [!INCLUDE[ssDE](../includes/ssde-md.md)] follows the chain and retrieves the row where the transaction sequence number is:</span></span>  
  
-   <span data-ttu-id="1f03c-1314">行を読み取っているスナップショット トランザクションのシーケンス番号に最も近く、それよりも小さいトランザクション シーケンス番号。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1314">Closest to but lower than the sequence number of the snapshot transaction reading the row.</span></span>  
  
-   <span data-ttu-id="1f03c-1315">スナップショット トランザクションが開始されたときのアクティブなトランザクションの一覧にないトランザクション シーケンス番号。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1315">Not in the list of the transactions active when the snapshot transaction started.</span></span>  
  
 <span data-ttu-id="1f03c-1316">スナップショット トランザクションで実行される読み取り操作では、スナップショット トランザクションが開始されたときにコミットされた各行の最後のバージョンが取得されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1316">Read operations performed by a snapshot transaction retrieve the last version of each row that had been committed at the time the snapshot transaction started.</span></span> <span data-ttu-id="1f03c-1317">これにより、トランザクション内で一貫性を持つ、トランザクションが開始されたときのデータのスナップショットが提供されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1317">This provides a transactionally consistent snapshot of the data as it existed at the start of the transaction.</span></span>  
  
 <span data-ttu-id="1f03c-1318">行のバージョン管理を使用する READ COMMITTED トランザクションも、ほぼ同じように動作します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1318">Read-committed transactions using row versioning operate in much the same way.</span></span> <span data-ttu-id="1f03c-1319">ただし、READ COMMITTED トランザクションでは、行のバージョンを選択するときにトランザクション自体のトランザクション シーケンス番号が使用されないという点が異なります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1319">The difference is that the read-committed transaction does not use its own transaction sequence number when choosing row versions.</span></span> <span data-ttu-id="1f03c-1320">ステートメントが開始されるたびに、READ COMMITTED トランザクションでは、この[!INCLUDE[ssDE](../includes/ssde-md.md)]のインスタンスに対して生成された最新のトランザクション シーケンス番号が読み取られます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1320">Each time a statement is started, the read-committed transaction reads the latest transaction sequence number issued for that instance of the [!INCLUDE[ssDE](../includes/ssde-md.md)].</span></span> <span data-ttu-id="1f03c-1321">これは、そのステートメントに適した行のバージョンを選択するために使用されるトランザクション シーケンス番号です。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1321">This is the transaction sequence number used to select the correct row versions for that statement.</span></span> <span data-ttu-id="1f03c-1322">このトランザクション シーケンス番号により、READ COMMITTED トランザクションでは、各ステートメントが開始されたときのデータのスナップショットを参照できるようになります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1322">This allows read-committed transactions to see a snapshot of the data as it exists at the start of each statement.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="1f03c-1323">行のバージョン管理を使用する READ COMMITTED トランザクションが、トランザクション全体で一貫性のあるデータのビューをステートメント レベルで提供しても、この種類のトランザクションにより生成またはアクセスされる行バージョンは、トランザクションが完了するまで保持されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1323">Even though read-committed transactions using row versioning provides a transactionally consistent view of the data at a statement level, row versions generated or accessed by this type of transaction are maintained until the transaction completes.</span></span>  
  
### <a name="behavior-when-modifying-data"></a><span data-ttu-id="1f03c-1324">データ変更時の動作</span><span class="sxs-lookup"><span data-stu-id="1f03c-1324">Behavior When Modifying Data</span></span>  

 <span data-ttu-id="1f03c-1325">行のバージョン管理を使用する READ COMMITTED トランザクションでは、更新する行を選択するときにブロッキング スキャンが使用されます。ブロッキング スキャンでは、データ値を読み取るときにデータ行の更新 (U) ロックが獲得されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1325">In a read-committed transaction using row versioning, the selection of rows to update is done using a blocking scan where an update (U) lock is taken on the data row as data values are read.</span></span> <span data-ttu-id="1f03c-1326">この動作は、行のバージョン管理を使用しない READ COMMITTED トランザクションでも発生します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1326">This is the same as a read-committed transaction that does not use row versioning.</span></span> <span data-ttu-id="1f03c-1327">データ行が更新基準を満たしていない場合は、その行の更新ロックが解放され、次の行がロックおよびスキャンされます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1327">If the data row does not meet the update criteria, the update lock is released on that row and the next row is locked and scanned.</span></span>  
  
 <span data-ttu-id="1f03c-1328">スナップショット分離レベルで実行されているトランザクションでは、制約を設定するためだけに変更を実行する前に、データのロックを獲得することによって、データ変更にオプティミスティック同時実行制御が使用されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1328">Transactions running under snapshot isolation take an optimistic approach to data modification by acquiring locks on data before performing the modification only to enforce constraints.</span></span> <span data-ttu-id="1f03c-1329">それ以外の場合、データの変更が確定するまで、そのデータのロックは獲得されません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1329">Otherwise, locks are not acquired on data until the data is to be modified.</span></span> <span data-ttu-id="1f03c-1330">データ行が更新基準を満たしている場合、スナップショット トランザクションにより、そのスナップショット トランザクションの開始後にコミットされた同時実行トランザクションでそのデータ行が変更されていないかどうかが確認されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1330">When a data row meets the update criteria, the snapshot transaction verifies that the data row has not been modified by a concurrent transaction that committed after the snapshot transaction began.</span></span> <span data-ttu-id="1f03c-1331">データ行がスナップショット トランザクションの外部で変更された場合は、更新の競合が発生し、そのスナップショット トランザクションは終了されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1331">If the data row has been modified outside of the snapshot transaction, an update conflict occurs and the snapshot transaction is terminated.</span></span> <span data-ttu-id="1f03c-1332">更新の競合は[!INCLUDE[ssDE](../includes/ssde-md.md)]によって処理されるので、更新の競合が検出されないようにする方法はありません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1332">The update conflict is handled by the [!INCLUDE[ssDE](../includes/ssde-md.md)] and there is no way to disable the update conflict detection.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="1f03c-1333">スナップショット分離レベルで実行されている更新操作は、スナップショット トランザクションにより次のアイテムへのアクセスが行われたときに、内部的に READ COMMITTED 分離レベルで実行されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1333">Update operations running under snapshot isolation internally execute under read committed isolation when the snapshot transaction accesses any of the following:</span></span>  
>   
>  <span data-ttu-id="1f03c-1334">FOREIGN KEY 制約が適用されたテーブル。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1334">A table with a FOREIGN KEY constraint.</span></span>  
>   
>  <span data-ttu-id="1f03c-1335">別のテーブルの FOREIGN KEY 制約で参照されるテーブル。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1335">A table that is referenced in the FOREIGN KEY constraint of another table.</span></span>  
>   
>  <span data-ttu-id="1f03c-1336">複数のテーブルを参照するインデックス付きビュー。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1336">An indexed view referencing more than one table.</span></span>  
>   
>  <span data-ttu-id="1f03c-1337">ただしこのような状況でも、更新操作では、データが別のトランザクションにより変更されていないかどうかが引き続き確認されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1337">However, even under these conditions the update operation will continue to verify that the data has not been modified by another transaction.</span></span> <span data-ttu-id="1f03c-1338">データが別のトランザクションで変更されている場合は、更新の競合が発生し、スナップショット トランザクションは終了します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1338">If data has been modified by another transaction, the snapshot transaction encounters an update conflict and is terminated.</span></span>  
  
### <a name="behavior-in-summary"></a><span data-ttu-id="1f03c-1339">動作のまとめ</span><span class="sxs-lookup"><span data-stu-id="1f03c-1339">Behavior in Summary</span></span>  

 <span data-ttu-id="1f03c-1340">次の表に、行のバージョン管理を使用するスナップショット分離レベルと READ COMMITTED 分離レベルの違いを要約します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1340">The following table summarizes the differences between snapshot isolation and read committed isolation using row versioning.</span></span>  
  
|<span data-ttu-id="1f03c-1341">プロパティ</span><span class="sxs-lookup"><span data-stu-id="1f03c-1341">Property</span></span>|<span data-ttu-id="1f03c-1342">行のバージョン管理を使用する READ COMMITTED 分離レベル</span><span class="sxs-lookup"><span data-stu-id="1f03c-1342">Read-committed isolation level using row versioning</span></span>|<span data-ttu-id="1f03c-1343">スナップショット分離レベル</span><span class="sxs-lookup"><span data-stu-id="1f03c-1343">Snapshot isolation level</span></span>|  
|--------------|----------------------------------------------------------|------------------------------|  
|<span data-ttu-id="1f03c-1344">必要なサポートを有効にするために ON に設定されている必要があるデータベース オプション。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1344">The database option that must be set to ON to enable the required support.</span></span>|<span data-ttu-id="1f03c-1345">READ_COMMITTED_SNAPSHOT</span><span class="sxs-lookup"><span data-stu-id="1f03c-1345">READ_COMMITTED_SNAPSHOT</span></span>|<span data-ttu-id="1f03c-1346">ALLOW_SNAPSHOT_ISOLATION</span><span class="sxs-lookup"><span data-stu-id="1f03c-1346">ALLOW_SNAPSHOT_ISOLATION</span></span>|  
|<span data-ttu-id="1f03c-1347">セッションが特定の種類の行のバージョン管理を要求する方法。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1347">How a session requests the specific type of row versioning.</span></span>|<span data-ttu-id="1f03c-1348">既定の READ COMMITTED 分離レベルを使用するか、または SET TRANSACTION ISOLATION LEVEL ステートメントを実行して READ COMMITTED 分離レベルを指定します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1348">Use the default read-committed isolation level, or run the SET TRANSACTION ISOLATION LEVEL statement to specify the READ COMMITTED isolation level.</span></span> <span data-ttu-id="1f03c-1349">この操作は、トランザクションの開始後に実行できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1349">This can be done after the transaction starts.</span></span>|<span data-ttu-id="1f03c-1350">トランザクションの開始前に、SET TRANSACTION ISOLATION LEVEL を実行してスナップショット分離レベルを指定するように要求します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1350">Requires the execution of SET TRANSACTION ISOLATION LEVEL to specify the SNAPSHOT isolation level before the start of the transaction.</span></span>|  
|<span data-ttu-id="1f03c-1351">ステートメントにより読み取られるデータのバージョン。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1351">The version of data read by statements.</span></span>|<span data-ttu-id="1f03c-1352">各ステートメントの開始前にコミットされたすべてのデータ。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1352">All data that was committed before the start of each statement.</span></span>|<span data-ttu-id="1f03c-1353">各トランザクションの開始前にコミットされたすべてのデータ。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1353">All data that was committed before the start of each transaction.</span></span>|  
|<span data-ttu-id="1f03c-1354">更新の処理方法。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1354">How updates are handled.</span></span>|<span data-ttu-id="1f03c-1355">行のバージョンを実際のデータに戻して更新する行を選択し、選択したデータ行に対して更新ロックをかけます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1355">Reverts from row versions to actual data to select rows to update and uses update locks on the data rows selected.</span></span> <span data-ttu-id="1f03c-1356">また、変更する実際のデータ行の排他ロックを獲得します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1356">Acquires exclusive locks on actual data rows to be modified.</span></span> <span data-ttu-id="1f03c-1357">更新の競合検出は行われません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1357">No update conflict detection.</span></span>|<span data-ttu-id="1f03c-1358">行バージョンを使用して更新する行を選択します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1358">Uses row versions to select rows to update.</span></span> <span data-ttu-id="1f03c-1359">変更する行の実際のデータに対する排他ロックの獲得を試行します。このデータが別のトランザクションにより変更されている場合は、更新の競合が発生し、スナップショット トランザクションは終了します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1359">Tries to acquire an exclusive lock on the actual data row to be modified, and if the data has been modified by another transaction, an update conflict occurs and the snapshot transaction is terminated.</span></span>|  
|<span data-ttu-id="1f03c-1360">更新の競合検出。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1360">Update conflict detection.</span></span>|<span data-ttu-id="1f03c-1361">[なし] :</span><span class="sxs-lookup"><span data-stu-id="1f03c-1361">None.</span></span>|<span data-ttu-id="1f03c-1362">組み込みによるサポート。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1362">Integrated support.</span></span> <span data-ttu-id="1f03c-1363">この機能は無効にできません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1363">Cannot be disabled.</span></span>|  
  
### <a name="row-versioning-resource-usage"></a><span data-ttu-id="1f03c-1364">行のバージョン管理用リソースの使用状況</span><span class="sxs-lookup"><span data-stu-id="1f03c-1364">Row Versioning Resource Usage</span></span>  

 <span data-ttu-id="1f03c-1365">行のバージョン管理フレームワークでは、[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] で使用可能な次の機能がサポートされます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1365">The row versioning framework supports the following features available in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]:</span></span>  
  
-   <span data-ttu-id="1f03c-1366">トリガー</span><span class="sxs-lookup"><span data-stu-id="1f03c-1366">Triggers</span></span>  
  
-   <span data-ttu-id="1f03c-1367">複数のアクティブな結果セット (MARS)</span><span class="sxs-lookup"><span data-stu-id="1f03c-1367">Multiple Active Results Sets (MARS)</span></span>  
  
-   <span data-ttu-id="1f03c-1368">オンラインのインデックス構築</span><span class="sxs-lookup"><span data-stu-id="1f03c-1368">Online indexing</span></span>  
  
 <span data-ttu-id="1f03c-1369">また、行のバージョン管理フレームワークでは、次に示すように、行のバージョン管理に基づいたトランザクション分離レベルもサポートされます。このレベルは既定では無効になっています。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1369">The row versioning framework also supports the following row versioning-based transaction isolation levels, which by default are not enabled:</span></span>  
  
-   <span data-ttu-id="1f03c-1370">READ_COMMITTED_SNAPSHOT データベース オプションが ON になっている場合、READ_COMMITTED トランザクションで行のバージョン管理を行うことにより、ステートメント レベルでの読み取り操作を一貫性を保った状態で実行できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1370">When the READ_COMMITTED_SNAPSHOT database option is ON, READ_COMMITTED transactions provide statement-level read consistency using row versioning.</span></span>  
  
-   <span data-ttu-id="1f03c-1371">ALLOW_SNAPSHOT_ISOLATION データベース オプションが ON になっている場合、SNAPSHOT トランザクションで行のバージョン管理を行うことにより、トランザクション レベルでの読み取り操作を一貫性を保った状態で実行できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1371">When the ALLOW_SNAPSHOT_ISOLATION database option is ON, SNAPSHOT transactions provide transaction-level read consistency using row versioning.</span></span>  
  
 <span data-ttu-id="1f03c-1372">行のバージョン管理に基づく分離レベルを使用すると、読み取り操作での共有ロックが排除され、トランザクションから取得するロック数が減少します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1372">Row versioning-based isolation levels reduce the number of locks acquired by transaction by eliminating the use of shared locks on read operations.</span></span> <span data-ttu-id="1f03c-1373">その結果、ロックの管理に使用するリソースを節約できるので、システムのパフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1373">This increases system performance by reducing the resources used to manage locks.</span></span> <span data-ttu-id="1f03c-1374">また、他のトランザクションから取得したロックによりトランザクションがブロックされる回数が減少することも、パフォーマンスが向上する要因です。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1374">Performance is also increased by reducing the number of times a transaction is blocked by locks acquired by other transactions.</span></span>  
  
 <span data-ttu-id="1f03c-1375">行のバージョン管理に基づいて分離レベルを使用すると、データの変更に必要なリソースが増加します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1375">Row versioning-based isolation levels increase the resources needed by data modifications.</span></span> <span data-ttu-id="1f03c-1376">これらのオプションを有効にすると、データベースに対するすべてのデータ変更がバージョン管理されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1376">Enabling these options causes all data modifications for the database to be versioned.</span></span> <span data-ttu-id="1f03c-1377">行のバージョン管理に基づく分離を使用したアクティブなトランザクションが存在しない場合でも、変更前のデータのコピーは tempdb に格納されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1377">A copy of the data before modification is stored in tempdb even when there are no active transactions using row versioning-based isolation.</span></span> <span data-ttu-id="1f03c-1378">変更後のデータには、tempdb に格納されたバージョン管理されるデータへのポインターが含まれます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1378">The data after modification includes a pointer to the versioned data stored in tempdb.</span></span> <span data-ttu-id="1f03c-1379">ラージ オブジェクトの場合は、変更されたオブジェクトだけが tempdb にコピーされます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1379">For large objects, only part of the object that changed is copied to tempdb.</span></span>  
  
#### <a name="space-used-in-tempdb"></a><span data-ttu-id="1f03c-1380">tempdb で使用される領域</span><span class="sxs-lookup"><span data-stu-id="1f03c-1380">Space Used in tempdb</span></span>  

 <span data-ttu-id="1f03c-1381">[!INCLUDE[ssDE](../includes/ssde-md.md)]の各インスタンスの tempdb には、インスタンス内の各データベースで生成される行バージョンを保持できるだけの十分な領域が必要です。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1381">For each instance of the [!INCLUDE[ssDE](../includes/ssde-md.md)], tempdb must have enough space to hold the row versions generated for every database in the instance.</span></span> <span data-ttu-id="1f03c-1382">データベース管理者は、バージョン ストアをサポートできるだけの十分な領域を tempdb 内に確保する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1382">The database administrator must ensure that tempdb has ample space to support the version store.</span></span> <span data-ttu-id="1f03c-1383">tempdb には次に示す 2 つのバージョン ストアがあります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1383">There are two version stores in tempdb:</span></span>  
  
-   <span data-ttu-id="1f03c-1384">オンライン インデックス構築用のバージョン ストアは、すべてのデータベースのオンラインのインデックス構築操作に使用されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1384">The online index build version store is used for online index builds in all databases.</span></span>  
  
-   <span data-ttu-id="1f03c-1385">共通バージョン ストアは、すべてのデータベース内のその他すべてのデータ変更操作に使用されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1385">The common version store is used for all other data modification operations in all databases.</span></span>  
  
 <span data-ttu-id="1f03c-1386">アクティブなトランザクションで行バージョンにアクセスする必要がある限り、その行バージョンを格納しておく必要があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1386">Row versions must be stored for as long as an active transaction needs to access it.</span></span> <span data-ttu-id="1f03c-1387">1 分ごとに、バックグラウンドのスレッドによって、不要になった行バージョンが削除され、tempdb 内のバージョン領域が解放されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1387">Once every minute, a background thread removes row versions that are no longer needed and frees up the version space in tempdb.</span></span> <span data-ttu-id="1f03c-1388">次の条件のいずれかに該当する場合、実行時間の長いトランザクションにより、バージョン ストアの領域の解放が妨げられます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1388">A long-running transaction prevents space in the version store from being released if it meets any of the following conditions:</span></span>  
  
-   <span data-ttu-id="1f03c-1389">トランザクションで、行のバージョン管理に基づく分離が使用されています。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1389">It uses row versioning-based isolation.</span></span>  
  
-   <span data-ttu-id="1f03c-1390">トランザクションで、トリガー、MARS、またはオンラインのインデックス構築のいずれかの操作が使用されています。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1390">It uses triggers, MARS, or online index build operations.</span></span>  
  
-   <span data-ttu-id="1f03c-1391">トランザクションで、行バージョンが生成されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1391">It generates row versions.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="1f03c-1392">トランザクションの内部でトリガーが呼び出されるときに、トリガーによって作成される行バージョンは、トリガーの完了後に不要になる行バージョンであっても、トランザクションの終了時まで保持されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1392">When a trigger is invoked inside a transaction, the row versions created by the trigger are maintained until the end of the transaction, even though the row versions are no longer needed after the trigger completes.</span></span> <span data-ttu-id="1f03c-1393">これは、行のバージョン管理を使用する READ COMMITTED トランザクションにも適用されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1393">This also applies to read-committed transactions that use row versioning.</span></span> <span data-ttu-id="1f03c-1394">この種類のトランザクションを使用すると、トランザクション内の各ステートメントに対してだけ、トランザクション全体で一貫性のあるデータベース ビューが必要です。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1394">With this type of transaction, a transactionally consistent view of the database is needed only for each statement in the transaction.</span></span> <span data-ttu-id="1f03c-1395">つまり、トランザクションでステートメントに対して作成される行バージョンは、ステートメントが完了した後には不要になります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1395">This means that the row versions created for a statement in the transaction are no longer needed after the statement completes.</span></span> <span data-ttu-id="1f03c-1396">ただし、トランザクションで各ステートメントによって作成される行バージョンは、トランザクションが完了するまで保持されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1396">However, row versions created by each statement in the transaction are maintained until the transaction completes.</span></span>  
  
 <span data-ttu-id="1f03c-1397">tempdb の領域が不足すると、[!INCLUDE[ssDE](../includes/ssde-md.md)]によって強制的にバージョン ストアが圧縮されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1397">When tempdb runs out of space, the [!INCLUDE[ssDE](../includes/ssde-md.md)] forces the version stores to shrink.</span></span> <span data-ttu-id="1f03c-1398">圧縮処理では、行バージョンをまだ生成していないトランザクションのうち、実行時間が最も長いトランザクションが圧縮対象になります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1398">During the shrink process, the longest running transactions that have not yet generated row versions are marked as victims.</span></span> <span data-ttu-id="1f03c-1399">圧縮対象のトランザクションごとに、メッセージ 3967 がエラー ログに記録されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1399">A message 3967 is generated in the error log for each victim transaction.</span></span> <span data-ttu-id="1f03c-1400">あるトランザクションが圧縮の対象として設定されると、そのトランザクションではバージョン ストア内の行バージョンを読み取れなくなります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1400">If a transaction is marked as a victim, it can no longer read the row versions in the version store.</span></span> <span data-ttu-id="1f03c-1401">そのトランザクションから行バージョンを読み取ろうとすると、メッセージ 3966 が生成され、そのトランザクションはロールバックされます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1401">When it attempts to read row versions, message 3966 is generated and the transaction is rolled back.</span></span> <span data-ttu-id="1f03c-1402">圧縮処理が成功すると、tempdb に使用可能な領域が生成されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1402">If the shrinking process succeeds, space becomes available in tempdb.</span></span> <span data-ttu-id="1f03c-1403">失敗した場合は、tempdb の領域が不足し、次のいずれかの現象が発生します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1403">Otherwise, tempdb runs out of space and the following occurs:</span></span>  
  
-   <span data-ttu-id="1f03c-1404">書き込み操作が続行および実行されますが、バージョンが生成されません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1404">Write operations continue to execute but do not generate versions.</span></span> <span data-ttu-id="1f03c-1405">情報提供用メッセージ (3959) がエラー ログに記録されますが、データを書き込むトランザクションは影響を受けません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1405">An information message (3959) appears in the error log, but the transaction that writes data is not affected.</span></span>  
  
-   <span data-ttu-id="1f03c-1406">tempdb 全体がロールバックされたために生成されなかった行バージョンにアクセスを試みるトランザクションが、エラー 3958 で終了します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1406">Transactions that attempt to access row versions that were not generated because of a tempdb full rollback terminate with an error 3958.</span></span>  
  
#### <a name="space-used-in-data-rows"></a><span data-ttu-id="1f03c-1407">データ行で使用される領域</span><span class="sxs-lookup"><span data-stu-id="1f03c-1407">Space Used in Data Rows</span></span>  

 <span data-ttu-id="1f03c-1408">各データベース行では、行の終わりの最大 14 バイトを行のバージョン管理情報用に使用する場合があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1408">Each database row may use up to 14 bytes at the end of the row for row versioning information.</span></span> <span data-ttu-id="1f03c-1409">行のバージョン管理情報には、そのバージョンでコミットしたトランザクションのトランザクション シーケンス番号と、バージョン管理される行へのポインターが含まれています。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1409">The row versioning information contains the transaction sequence number of the transaction that committed the version and the pointer to the versioned row.</span></span> <span data-ttu-id="1f03c-1410">次に示す条件のいずれかに該当する場合、行が最初に変更されたとき、または新しい行が追加されたときに、この 14 バイトが追加されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1410">These 14 bytes are added the first time the row is modified, or when a new row is inserted, under any of these conditions:</span></span>  
  
-   <span data-ttu-id="1f03c-1411">READ_COMMITTED_SNAPSHOT オプションまたは ALLOW_SNAPSHOT_ISOLATION オプションが ON になっています。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1411">READ_COMMITTED_SNAPSHOT or ALLOW_SNAPSHOT_ISOLATION options are ON.</span></span>  
  
-   <span data-ttu-id="1f03c-1412">テーブルにトリガーが含まれています。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1412">The table has a trigger.</span></span>  
  
-   <span data-ttu-id="1f03c-1413">複数のアクティブな結果セット (MARS) が使用されています。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1413">Multiple Active Results Sets (MARS) is being used.</span></span>  
  
-   <span data-ttu-id="1f03c-1414">オンラインのインデックス構築操作が、現在そのテーブルで実行されています。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1414">Online index build operations are currently running on the table.</span></span>  
  
 <span data-ttu-id="1f03c-1415">次のすべての条件に該当する状況で最初に行が変更されたときに、そのデータベース行からこの 14 バイトが削除されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1415">These 14 bytes are removed from the database row the first time the row is modified under all of these conditions:</span></span>  
  
-   <span data-ttu-id="1f03c-1416">READ_COMMITTED_SNAPSHOT オプションと ALLOW_SNAPSHOT_ISOLATION オプションが OFF になっています。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1416">READ_COMMITTED_SNAPSHOT and ALLOW_SNAPSHOT_ISOLATION options are OFF.</span></span>  
  
-   <span data-ttu-id="1f03c-1417">テーブルに既にトリガーが存在しません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1417">The trigger no longer exists on the table.</span></span>  
  
-   <span data-ttu-id="1f03c-1418">MARS が使用されていません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1418">MARS is not being used.</span></span>  
  
-   <span data-ttu-id="1f03c-1419">オンラインのインデックス構築操作が現在実行されていません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1419">Online index build operations are not currently running.</span></span>  
  
 <span data-ttu-id="1f03c-1420">行のバージョン管理機能を使用する場合は、データベースに追加のディスク領域を割り当て、各データベース行で 14 バイトを使用できるようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1420">If you use any of the row versioning features, you might need to allocate additional disk space for the database to accommodate the 14 bytes per database row.</span></span> <span data-ttu-id="1f03c-1421">行のバージョン管理用情報が追加された際に、現在のページ上に十分な空き領域がない場合、インデックス ページの分割や、新しいデータ ページの割り当てが発生します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1421">Adding the row versioning information can cause index page splits or the allocation of a new data page if there is not enough space available on the current page.</span></span> <span data-ttu-id="1f03c-1422">たとえば、行の平均の長さが 100 バイトの場合は、14 バイト追加されると既存のテーブルが最大 14% 大きくなります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1422">For example, if the average row length is 100 bytes, the additional 14 bytes cause an existing table to grow up to 14 percent.</span></span>  
  
 <span data-ttu-id="1f03c-1423">[FILL FACTOR](../relational-databases/indexes/specify-fill-factor-for-an-index.md) を小さくすると、インデックス ページの断片化を防止または低減するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1423">Decreasing the [fill factor](../relational-databases/indexes/specify-fill-factor-for-an-index.md) might help to prevent or decrease fragmentation of index pages.</span></span> <span data-ttu-id="1f03c-1424">テーブルまたはビューのデータとインデックスの断片化に関する情報を表示するには、 [DBCC SHOWCONTIG](/sql/t-sql/database-console-commands/dbcc-showcontig-transact-sql)を使用します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1424">To view fragmentation information for the data and indexes of a table or view, you can use [DBCC SHOWCONTIG](/sql/t-sql/database-console-commands/dbcc-showcontig-transact-sql).</span></span>  
  
#### <a name="space-used-in-large-objects"></a><span data-ttu-id="1f03c-1425">ラージ オブジェクトで使用される領域</span><span class="sxs-lookup"><span data-stu-id="1f03c-1425">Space Used in Large Objects</span></span>  

 <span data-ttu-id="1f03c-1426">[!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)]では、最大 2 GB の大きなサイズの文字列を保持できる 6 つのデータ型 (`nvarchar(max)`、`varchar(max)`、`varbinary(max)`、`ntext`、`text`、`image`) がサポートされます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1426">The [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] supports six data types that can hold large strings up to 2 gigabytes (GB) in length: `nvarchar(max)`, `varchar(max)`, `varbinary(max)`, `ntext`, `text`, and `image`.</span></span> <span data-ttu-id="1f03c-1427">これらのデータ型で格納されたサイズの大きな文字列は、データ行にリンクされている一連のデータ フラグメントに格納されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1427">Large strings stored using these data types are stored in a series of data fragments that are linked to the data row.</span></span> <span data-ttu-id="1f03c-1428">行のバージョン管理情報は、これらの大きな文字列の格納に使用される各フラグメントに格納されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1428">Row versioning information is stored in each fragment used to store these large strings.</span></span> <span data-ttu-id="1f03c-1429">データ フラグメントは、テーブル内のラージ オブジェクト専用のページのコレクションです。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1429">Data fragments are a collection of pages dedicated to large objects in a table.</span></span>  
  
 <span data-ttu-id="1f03c-1430">新しい大きな値がデータベースに追加されたときに、データ フラグメントには、1 つのフラグメントにつき最大 8,040 バイトのデータが割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1430">As new large values are added to a database, they are allocated using a maximum of 8040 bytes of data per fragment.</span></span> <span data-ttu-id="1f03c-1431">以前のバージョンの[!INCLUDE[ssDE](../includes/ssde-md.md)]では、1 つのフラグメントにつき最大 8,080 バイトの `ntext` データ、`text` データ、または `image` データが格納されていました。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1431">Earlier versions of the [!INCLUDE[ssDE](../includes/ssde-md.md)] stored up to 8080 bytes of `ntext`, `text`, or `image` data per fragment.</span></span>  
  
 <span data-ttu-id="1f03c-1432">`ntext` 型、`text` 型、および `image` 型の既存のラージ オブジェクト (LOB) データは、データベースが以前のバージョンの [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] から [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] にアップグレードされても、行のバージョン管理情報用の領域を確保するために更新されることはありません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1432">Existing `ntext`, `text`, and `image` large object (LOB) data is not updated to make space for the row versioning information when a database is upgraded to [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] from an earlier version of [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="1f03c-1433">ただし、これらの LOB データが最初に変更されたときに、バージョン管理情報の領域を使用できるように動的にアップグレードされます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1433">However, the first time the LOB data is modified, it is dynamically upgraded to enable storage of versioning information.</span></span> <span data-ttu-id="1f03c-1434">行のバージョンが生成されない場合でも、このアップグレードは行われます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1434">This will happen even if row versions are not generated.</span></span> <span data-ttu-id="1f03c-1435">LOB データがアップグレードされた後、1 フラグメントに格納されている最大バイト数が 8,080 バイトから 8,040 バイトに減少します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1435">After the LOB data is upgraded, the maximum number of bytes stored per fragment is reduced from 8080 bytes to 8040 bytes.</span></span> <span data-ttu-id="1f03c-1436">このアップグレード処理は、LOB 値を削除し、再度同じ値を挿入する処理に相当します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1436">The upgrade process is equivalent to deleting the LOB value and reinserting the same value.</span></span> <span data-ttu-id="1f03c-1437">LOB データは、1 バイトしか変更されない場合にもアップグレードされます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1437">The LOB data is upgraded even if only one byte is modified.</span></span> <span data-ttu-id="1f03c-1438">このアップグレードは、`ntext` 型、`text` 型、または `image` 型の各列で 1 回だけ実行される操作ですが、LOB データのサイズによっては、大量のページが割り当てられたり、大量の I/O 処理が実行されたりする場合があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1438">This is a one-time operation for each `ntext`, `text`, or `image` column, but each operation may generate a large amount of page allocations and I/O activity depending upon the size of the LOB data.</span></span> <span data-ttu-id="1f03c-1439">また、変更が完全にログに記録される場合、ログ処理が膨大になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1439">It may also generate a large amount of logging activity if the modification is fully logged.</span></span> <span data-ttu-id="1f03c-1440">WRITETEXT 操作および UPDATETEXT 操作を使用すると、データベースが完全復旧モードに設定されている場合、ログ記録を最小限に抑えることができます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1440">WRITETEXT and UPDATETEXT operations are minimally logged if database recovery mode is not set to FULL.</span></span>  
  
 <span data-ttu-id="1f03c-1441">`nvarchar(max)`、`varchar(max)`、および `varbinary(max)` の各データ型は、以前のバージョンの [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] では使用できません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1441">The `nvarchar(max)`, `varchar(max)`, and `varbinary(max)` data types are not available in earlier versions of [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="1f03c-1442">したがって、これらのデータ型についてはアップグレードの問題は発生しません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1442">Therefore, they have no upgrade issues.</span></span>  
  
 <span data-ttu-id="1f03c-1443">この要件を満たすには、十分なディスク領域を割り当てる必要があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1443">Enough disk space should be allocated to accommodate this requirement.</span></span>  
  
#### <a name="monitoring-row-versioning-and-the-version-store"></a><span data-ttu-id="1f03c-1444">行のバージョン管理とバージョン ストアの監視</span><span class="sxs-lookup"><span data-stu-id="1f03c-1444">Monitoring Row Versioning and the Version Store</span></span>  

 <span data-ttu-id="1f03c-1445">[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] では、パフォーマンスや問題について、行のバージョン管理、バージョン ストア、およびスナップショット分離のプロセスを監視するために、動的管理ビュー (DMV) と Windows システム モニターのパフォーマンス カウンターというツールが用意されています。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1445">For monitoring row versioning, version store, and snapshot isolation processes for performance and problems, [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] provides tools in the form of Dynamic Management Views (DMVs) and performance counters in Windows System Monitor.</span></span>  
  
##### <a name="dmvs"></a><span data-ttu-id="1f03c-1446">DMV</span><span class="sxs-lookup"><span data-stu-id="1f03c-1446">DMVs</span></span>  

 <span data-ttu-id="1f03c-1447">次に示す DMV からは、行のバージョン管理を使用しているトランザクションについての情報だけではなく、tempdb の現在のシステム状態とバージョン ストアについての情報が提供されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1447">The following DMVs provide information about the current system state of tempdb and the version store, as well as transactions using row versioning.</span></span>  
  
 <span data-ttu-id="1f03c-1448">sys.dm_db_file_space_usage。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1448">sys.dm_db_file_space_usage.</span></span> <span data-ttu-id="1f03c-1449">データベース内の各ファイルに関する使用領域の情報を返します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1449">Returns space usage information for each file in the database.</span></span> <span data-ttu-id="1f03c-1450">詳しくは、「[sys.dm_db_file_space_usage &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-file-space-usage-transact-sql)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1450">For more information, see [sys.dm_db_file_space_usage &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-file-space-usage-transact-sql).</span></span>  
  
 <span data-ttu-id="1f03c-1451">sys.dm_db_session_space_usage。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1451">sys.dm_db_session_space_usage.</span></span> <span data-ttu-id="1f03c-1452">データベースのセッション別に、ページの割り当てと割り当て解除の状態を返します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1452">Returns page allocation and deallocation activity by session for the database.</span></span> <span data-ttu-id="1f03c-1453">詳しくは、「[sys.dm_db_session_space_usage &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-session-space-usage-transact-sql)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1453">For more information, see [sys.dm_db_session_space_usage &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-session-space-usage-transact-sql).</span></span>  
  
 <span data-ttu-id="1f03c-1454">sys.dm_db_task_space_usage。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1454">sys.dm_db_task_space_usage.</span></span> <span data-ttu-id="1f03c-1455">データベースに対するタスクごとに、ページの割り当てと割り当て解除の処理に関する情報を返します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1455">Returns page allocation and deallocation activity by task for the database.</span></span> <span data-ttu-id="1f03c-1456">詳しくは、「[sys.dm_db_task_space_usage &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-task-space-usage-transact-sql)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1456">For more information, see [sys.dm_db_task_space_usage &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-task-space-usage-transact-sql).</span></span>  
  
 <span data-ttu-id="1f03c-1457">sys.dm_tran_top_version_generators。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1457">sys.dm_tran_top_version_generators.</span></span> <span data-ttu-id="1f03c-1458">バージョン ストア内で最も高いバージョンを生成しているオブジェクトの仮想テーブルを返します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1458">Returns a virtual table for the objects producing the most versions in the version store.</span></span> <span data-ttu-id="1f03c-1459">集計済みのレコード長について、長いものから順に 256 位までを database_id と rowset_id でグループ化しています。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1459">It groups the top 256 aggregated record lengths by database_id and rowset_id.</span></span> <span data-ttu-id="1f03c-1460">この関数を使用して、バージョン ストアを最も多く使用しているレコードを見つけます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1460">Use this function to find the largest consumers of the version store.</span></span> <span data-ttu-id="1f03c-1461">詳しくは、「[sys.dm_tran_top_version_generators &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-top-version-generators-transact-sql)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1461">For more information, see [sys.dm_tran_top_version_generators &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-top-version-generators-transact-sql).</span></span>  
  
 <span data-ttu-id="1f03c-1462">sys.dm_tran_version_store。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1462">sys.dm_tran_version_store.</span></span> <span data-ttu-id="1f03c-1463">共通バージョン ストア内のすべてのバージョン レコードを表す仮想テーブルを返します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1463">Returns a virtual table that displays all version records in the common version store.</span></span> <span data-ttu-id="1f03c-1464">詳しくは、「[sys.dm_tran_version_store &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-version-store-transact-sql)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1464">For more information, see [sys.dm_tran_version_store &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-version-store-transact-sql).</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="1f03c-1465">sys.dm_tran_top_version_generators と sys.dm_tran_version_store では、非常に大きくなる可能性があるバージョン ストア全体に対してクエリが実行されるので、これらの関数を実行すると非常に多くのリソースが使用される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1465">sys.dm_tran_top_version_generators and sys.dm_tran_version_store are potentially very expensive functions to run, since both query the entire version store, which could be very large.</span></span>  
  
 <span data-ttu-id="1f03c-1466">sys.dm_tran_active_snapshot_database_transactions。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1466">sys.dm_tran_active_snapshot_database_transactions.</span></span> <span data-ttu-id="1f03c-1467">データベース内のすべてのアクティブなトランザクションを表す仮想テーブルを返します。行のバージョン管理を使用する [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] インスタンス内のすべてのデータベースが対象です。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1467">Returns a virtual table for all active transactions in all databases within the [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] instance that use row versioning.</span></span> <span data-ttu-id="1f03c-1468">システム トランザクションは、この DMV には表示されません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1468">System transactions do not appear in this DMV.</span></span> <span data-ttu-id="1f03c-1469">詳しくは、「[sys.dm_tran_active_snapshot_database_transactions &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-active-snapshot-database-transactions-transact-sql)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1469">For more information, see [sys.dm_tran_active_snapshot_database_transactions &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-active-snapshot-database-transactions-transact-sql).</span></span>  
  
 <span data-ttu-id="1f03c-1470">sys.dm_tran_transactions_snapshot。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1470">sys.dm_tran_transactions_snapshot.</span></span> <span data-ttu-id="1f03c-1471">トランザクションごとに作成されたスナップショットを表す仮想テーブルを返します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1471">Returns a virtual table that displays snapshots taken by each transaction.</span></span> <span data-ttu-id="1f03c-1472">このスナップショットには、行のバージョン管理を使用するアクティブなトランザクションのシーケンス番号が含まれています。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1472">The snapshot contains the sequence number of the active transactions that use row versioning.</span></span> <span data-ttu-id="1f03c-1473">詳しくは、「[sys.dm_tran_transactions_snapshot &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-transactions-snapshot-transact-sql)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1473">For more information, see [sys.dm_tran_transactions_snapshot &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-transactions-snapshot-transact-sql).</span></span>  
  
 <span data-ttu-id="1f03c-1474">sys.dm_tran_current_transaction。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1474">sys.dm_tran_current_transaction.</span></span> <span data-ttu-id="1f03c-1475">現在のセッションにおけるトランザクションの行のバージョン管理に関係した状態情報を表す 1 行を返します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1475">Returns a single row that displays row versioning-related state information of the transaction in the current session.</span></span> <span data-ttu-id="1f03c-1476">詳しくは、「[sys.dm_tran_current_transaction &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-current-transaction-transact-sql)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1476">For more information, see [sys.dm_tran_current_transaction &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-current-transaction-transact-sql).</span></span>  
  
 <span data-ttu-id="1f03c-1477">sys.dm_tran_current_snapshot。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1477">sys.dm_tran_current_snapshot.</span></span> <span data-ttu-id="1f03c-1478">現在のスナップショット分離トランザクションの開始時点でアクティブなすべてのトランザクションを表す仮想テーブルを返します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1478">Returns a virtual table that displays all active transactions at the time the current snapshot isolation transaction starts.</span></span> <span data-ttu-id="1f03c-1479">現在のトランザクションでスナップショット分離が使用されている場合、この関数は行を返しません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1479">If the current transaction is using snapshot isolation, this function returns no rows.</span></span> <span data-ttu-id="1f03c-1480">sys.dm_tran_current_snapshot は、sys.dm_tran_transactions_snapshot と類似していますが、現在のスナップショットのアクティブなトランザクションだけを返す点が異なります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1480">sys.dm_tran_current_snapshot is similar to sys.dm_tran_transactions_snapshot, except that it returns only the active transactions for the current snapshot.</span></span> <span data-ttu-id="1f03c-1481">詳しくは、「[sys.dm_tran_current_snapshot &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-current-snapshot-transact-sql)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1481">For more information, see [sys.dm_tran_current_snapshot &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-current-snapshot-transact-sql).</span></span>  
  
##### <a name="performance-counters"></a><span data-ttu-id="1f03c-1482">パフォーマンス カウンター</span><span class="sxs-lookup"><span data-stu-id="1f03c-1482">Performance Counters</span></span>  

 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] <span data-ttu-id="1f03c-1483">のパフォーマンス カウンターからは、[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] プロセスによって影響を受けるシステム パフォーマンスについての情報が提供されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1483">performance counters provide information about the system performance impacted by [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] processes.</span></span> <span data-ttu-id="1f03c-1484">次に示すパフォーマンス カウンターでは、行のバージョン管理を使用しているトランザクションだけではなく、tempdb とそのバージョン ストアを監視します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1484">The following performance counters monitor tempdb and the version store, as well as transactions using row versioning.</span></span> <span data-ttu-id="1f03c-1485">パフォーマンス カウンターは SQLServer:Transactions パフォーマンス オブジェクトに含まれています。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1485">The performance counters are contained in the SQLServer:Transactions performance object.</span></span>  
  
 <span data-ttu-id="1f03c-1486">**Free Space in tempdb (KB)** 。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1486">**Free Space in tempdb (KB)**.</span></span> <span data-ttu-id="1f03c-1487">tempdb データベース内の空き領域 (KB) を監視します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1487">Monitors the amount, in kilobytes (KB), of free space in the tempdb database.</span></span> <span data-ttu-id="1f03c-1488">tempdb には、スナップショット分離をサポートするバージョン ストアを処理できるだけの十分な空き領域が必要です。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1488">There must be enough free space in tempdb to handle the version store that supports snapshot isolation.</span></span>  
  
 <span data-ttu-id="1f03c-1489">次の式を使用すると、バージョン ストアのサイズを概算することができます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1489">The following formula provides a rough estimate of the size of the version store.</span></span> <span data-ttu-id="1f03c-1490">実行時間の長いトランザクションの場合、生成率とクリーンアップ率を監視してバージョン ストアの最大サイズを推定すると有益な場合があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1490">For long-running transactions, it may be useful to monitor the generation and cleanup rate to estimate the maximum size of the version store.</span></span>  
  
 <span data-ttu-id="1f03c-1491">[共通バージョン ストアのサイズ] = 2 \* [毎分生成されるバージョン ストア データ] \* [トランザクションの最長実行時間 (分)]</span><span class="sxs-lookup"><span data-stu-id="1f03c-1491">[size of common version store] = 2 \* [version store data generated per minute] \* [longest running time (minutes) of the transaction]</span></span>  
  
 <span data-ttu-id="1f03c-1492">実行時間が極端に長いトランザクションには、オンラインのインデックス構築操作を含めないでください。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1492">The longest running time of transactions should not include online index builds.</span></span> <span data-ttu-id="1f03c-1493">そのような場合のオンラインのインデックス構築操作は、非常に大きなテーブルでは時間がかかる場合があるので、別のバージョン ストアを使用します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1493">Because these operations may take a long time on very large tables, online index builds use a separate version store.</span></span> <span data-ttu-id="1f03c-1494">オンライン インデックス構築用のバージョン ストアの大まかなサイズは、オンラインのインデックス構築がアクティブになっている間にテーブル内で変更されたデータ (すべてのインデックスを含む) の量と同じです。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1494">The approximate size of the online index build version store equals the amount of data modified in the table, including all indexes, while the online index build is active.</span></span>  
  
 <span data-ttu-id="1f03c-1495">**Version Store Size (KB)** 。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1495">**Version Store Size (KB)**.</span></span> <span data-ttu-id="1f03c-1496">すべてのバージョン ストアのサイズを KB 単位で監視します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1496">Monitors the size in KB of all version stores.</span></span> <span data-ttu-id="1f03c-1497">この情報は、tempdb データベースに必要なバージョン ストア用の領域のサイズを判定する際に役立ちます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1497">This information helps determine the amount of space needed in the tempdb database for the version store.</span></span> <span data-ttu-id="1f03c-1498">このカウンターを長期間監視すると、tempdb に必要な領域を追加する際に役立つ推定値が得られます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1498">Monitoring this counter over a period of time provides a useful estimate of additional space needed for tempdb.</span></span>  
  
 <span data-ttu-id="1f03c-1499">`Version Generation rate (KB/s)`.</span><span class="sxs-lookup"><span data-stu-id="1f03c-1499">`Version Generation rate (KB/s)`.</span></span> <span data-ttu-id="1f03c-1500">すべてのバージョン ストアについてバージョンの生成率 (KB/秒) を監視します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1500">Monitors the version generation rate in KB per second in all version stores.</span></span>  
  
 <span data-ttu-id="1f03c-1501">`Version Cleanup rate (KB/s)`.</span><span class="sxs-lookup"><span data-stu-id="1f03c-1501">`Version Cleanup rate (KB/s)`.</span></span> <span data-ttu-id="1f03c-1502">すべてのバージョン ストアについてバージョンのクリーンアップ率 (KB/秒) を監視します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1502">Monitors the version cleanup rate in KB per second in all version stores.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="1f03c-1503">Version Generation rate (KB/s) と Version Cleanup rate (KB/s) から得た情報を、tempdb に必要な領域の予測に利用できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1503">Information from Version Generation rate (KB/s) and Version Cleanup rate (KB/s) can be used to predict tempdb space requirements.</span></span>  
  
 <span data-ttu-id="1f03c-1504">**Version Store unit count**。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1504">**Version Store unit count**.</span></span> <span data-ttu-id="1f03c-1505">バージョン ストア ユニットの数を監視します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1505">Monitors the count of version store units.</span></span>  
  
 <span data-ttu-id="1f03c-1506">**Version Store unit creation**。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1506">**Version Store unit creation**.</span></span> <span data-ttu-id="1f03c-1507">インスタンスの開始以降に行バージョンを格納するために作成されたバージョン ストア ユニットの総数を監視します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1507">Monitors the total number of version store units created to store row versions since the instance was started.</span></span>  
  
 <span data-ttu-id="1f03c-1508">**Version Store unit truncation**。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1508">**Version Store unit truncation**.</span></span> <span data-ttu-id="1f03c-1509">インスタンスの開始以降に切り捨てられたバージョン ストア ユニットの総数を監視します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1509">Monitors the total number of version store units truncated since the instance was started.</span></span> <span data-ttu-id="1f03c-1510">バージョン ストア ユニットは、バージョン ストア内に格納されているバージョン行が [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] によりアクティブなトランザクションの実行に不要と判断された場合に切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1510">A version store unit is truncated when [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] determines that none of the version rows stored in the version store unit are needed to run active transactions.</span></span>  
  
 <span data-ttu-id="1f03c-1511">**Update conflict ratio**。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1511">**Update conflict ratio**.</span></span> <span data-ttu-id="1f03c-1512">更新スナップショット トランザクションの総数に対し、更新に関して競合が発生している更新スナップショット トランザクションの割合を監視します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1512">Monitors the ratio of update snapshot transaction that have update conflicts to the total number of update snapshot transactions.</span></span>  
  
 <span data-ttu-id="1f03c-1513">**Longest Transaction Running Time**。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1513">**Longest Transaction Running Time**.</span></span> <span data-ttu-id="1f03c-1514">行のバージョン管理を使用しているトランザクションの最長実行時間 (秒) を監視します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1514">Monitors the longest running time in seconds of any transaction using row versioning.</span></span> <span data-ttu-id="1f03c-1515">このパフォーマンス カウンターを使用して、トランザクションの実行時間が不適切でないかどうかを判断できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1515">This can be used to determine if any transaction is running for an unreasonable amount of time.</span></span>  
  
 <span data-ttu-id="1f03c-1516">**Transactions**。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1516">**Transactions**.</span></span> <span data-ttu-id="1f03c-1517">アクティブなトランザクションの総数を監視します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1517">Monitors the total number of active transactions.</span></span> <span data-ttu-id="1f03c-1518">システム トランザクションは含まれません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1518">This does not include system transactions.</span></span>  
  
 <span data-ttu-id="1f03c-1519">`Snapshot Transactions`.</span><span class="sxs-lookup"><span data-stu-id="1f03c-1519">`Snapshot Transactions`.</span></span> <span data-ttu-id="1f03c-1520">アクティブなスナップショット トランザクションの総数を監視します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1520">Monitors the total number of active snapshot transactions.</span></span>  
  
 <span data-ttu-id="1f03c-1521">`Update Snapshot Transactions`.</span><span class="sxs-lookup"><span data-stu-id="1f03c-1521">`Update Snapshot Transactions`.</span></span> <span data-ttu-id="1f03c-1522">更新操作を実行するアクティブなスナップショット トランザクションの総数を監視します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1522">Monitors the total number of active snapshot transactions that perform update operations.</span></span>  
  
 <span data-ttu-id="1f03c-1523">`NonSnapshot Version Transactions`.</span><span class="sxs-lookup"><span data-stu-id="1f03c-1523">`NonSnapshot Version Transactions`.</span></span> <span data-ttu-id="1f03c-1524">バージョン レコードを生成する、スナップショット以外のアクティブなトランザクションの総数を監視します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1524">Monitors the total number of active non-snapshot transactions that generate version records.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="1f03c-1525">Update Snapshot Transactions と NonSnapshot Version Transactions の合計は、バージョンの生成に関係するトランザクションの総数を表します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1525">The sum of Update Snapshot Transactions and NonSnapshot Version Transactions represents the total number of transactions that participate in version generation.</span></span> <span data-ttu-id="1f03c-1526">Snapshot Transactions と Update Snapshot Transactions の差分は、読み取り専用のトランザクション数を表します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1526">The difference of Snapshot Transactions and Update Snapshot Transactions reports the number of read-only snapshot transactions.</span></span>  
  
### <a name="row-versioning-based-isolation-level-example"></a><span data-ttu-id="1f03c-1527">行のバージョン管理に基づく分離レベルの例</span><span class="sxs-lookup"><span data-stu-id="1f03c-1527">Row Versioning-based Isolation Level Example</span></span>  

 <span data-ttu-id="1f03c-1528">以下の例は、スナップショット分離トランザクションと、行のバージョン管理を使用する Read Committed トランザクションとの動作の違いを示しています。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1528">The following examples show the differences in behavior between snapshot isolation transactions and read-committed transactions that use row versioning.</span></span>  
  
#### <a name="a-working-with-snapshot-isolation"></a><span data-ttu-id="1f03c-1529">A.</span><span class="sxs-lookup"><span data-stu-id="1f03c-1529">A.</span></span> <span data-ttu-id="1f03c-1530">スナップショット分離を使用した作業</span><span class="sxs-lookup"><span data-stu-id="1f03c-1530">Working with snapshot isolation</span></span>  

 <span data-ttu-id="1f03c-1531">この例では、スナップショット分離レベルで実行中のトランザクションが、別のトランザクションにより変更されるデータを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1531">In this example, a transaction running under snapshot isolation reads data that is then modified by another transaction.</span></span> <span data-ttu-id="1f03c-1532">スナップショット トランザクションでは、別のトランザクションで実行される更新操作をブロックしないで、バージョン管理される行から引き続きデータを読み取り、データの変更が無視されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1532">The snapshot transaction does not block the update operation executed by the other transaction, and it continues to read data from the versioned row, ignoring the data modification.</span></span> <span data-ttu-id="1f03c-1533">ただし、スナップショット トランザクションが、別のトランザクションによって既に変更されているデータの変更を試みた場合は、そのスナップショット トランザクションがエラーを生成し、終了します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1533">However, when the snapshot transaction attempts to modify the data that has already been modified by the other transaction, the snapshot transaction generates an error and is terminated.</span></span>  
  
 <span data-ttu-id="1f03c-1534">セッション 1:</span><span class="sxs-lookup"><span data-stu-id="1f03c-1534">On session 1:</span></span>  
  
```sql  
USE AdventureWorks2012;  -- Or the 2008 or 2008R2 version of the AdventureWorks database.  
GO  
  
-- Enable snapshot isolation on the database.  
ALTER DATABASE AdventureWorks2012  
    SET ALLOW_SNAPSHOT_ISOLATION ON;  
GO  
  
-- Start a snapshot transaction  
SET TRANSACTION ISOLATION LEVEL SNAPSHOT;  
GO  
  
BEGIN TRANSACTION;  
    -- This SELECT statement will return  
    -- 48 vacation hours for the employee.  
    SELECT BusinessEntityID, VacationHours  
        FROM HumanResources.Employee  
        WHERE BusinessEntityID = 4;  
```  
  
 <span data-ttu-id="1f03c-1535">セッション 2 :</span><span class="sxs-lookup"><span data-stu-id="1f03c-1535">On session 2:</span></span>  
  
```sql  
USE AdventureWorks2012;  
GO  
  
-- Start a transaction.  
BEGIN TRANSACTION;  
    -- Subtract a vacation day from employee 4.  
    -- Update is not blocked by session 1 since  
    -- under snapshot isolation shared locks are  
    -- not requested.  
    UPDATE HumanResources.Employee  
        SET VacationHours = VacationHours - 8  
        WHERE BusinessEntityID = 4;  
  
    -- Verify that the employee now has 40 vacation hours.  
    SELECT VacationHours  
        FROM HumanResources.Employee  
        WHERE BusinessEntityID = 4;  
```  
  
 <span data-ttu-id="1f03c-1536">セッション 1:</span><span class="sxs-lookup"><span data-stu-id="1f03c-1536">On session 1:</span></span>  
  
```sql  
    -- Reissue the SELECT statement - this shows  
    -- the employee having 48 vacation hours.  The  
    -- snapshot transaction is still reading data from  
    -- the versioned row.  
    SELECT BusinessEntityID, VacationHours  
        FROM HumanResources.Employee  
        WHERE BusinessEntityID = 4;  
```  
  
 <span data-ttu-id="1f03c-1537">セッション 2 :</span><span class="sxs-lookup"><span data-stu-id="1f03c-1537">On session 2:</span></span>  
  
```sql  
-- Commit the transaction; this commits the data  
-- modification.  
COMMIT TRANSACTION;  
GO  
```  
  
 <span data-ttu-id="1f03c-1538">セッション 1:</span><span class="sxs-lookup"><span data-stu-id="1f03c-1538">On session 1:</span></span>  
  
```sql  
    -- Reissue the SELECT statement - this still   
    -- shows the employee having 48 vacation hours  
    -- even after the other transaction has committed  
    -- the data modification.  
    SELECT BusinessEntityID, VacationHours  
        FROM HumanResources.Employee  
        WHERE BusinessEntityID = 4;  
  
    -- Because the data has been modified outside of the  
    -- snapshot transaction, any further data changes to   
    -- that data by the snapshot transaction will cause   
    -- the snapshot transaction to fail. This statement   
    -- will generate a 3960 error and the transaction will   
    -- terminate.  
    UPDATE HumanResources.Employee  
        SET SickLeaveHours = SickLeaveHours - 8  
        WHERE BusinessEntityID = 4;  
  
-- Undo the changes to the database from session 1.   
-- This will not undo the change from session 2.  
ROLLBACK TRANSACTION  
GO  
```  
  
#### <a name="b-working-with-read-committed-using-row-versioning"></a><span data-ttu-id="1f03c-1539">B.</span><span class="sxs-lookup"><span data-stu-id="1f03c-1539">B.</span></span> <span data-ttu-id="1f03c-1540">行のバージョン管理を使用する Read Committed</span><span class="sxs-lookup"><span data-stu-id="1f03c-1540">Working with read-committed using row versioning</span></span>  

 <span data-ttu-id="1f03c-1541">この例では、行のバージョン管理を使用する Read Committed トランザクションを、別のトランザクションと同時に実行しています。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1541">In this example, a read-committed transaction using row versioning runs concurrently with another transaction.</span></span> <span data-ttu-id="1f03c-1542">Read Committed トランザクションは、スナップショット トランザクションとは異なる動作をします。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1542">The read-committed transaction behaves differently than a snapshot transaction.</span></span> <span data-ttu-id="1f03c-1543">スナップショット トランザクションと同様に Read Committed トランザクションも、別のトランザクションがデータを変更した後でも、バージョン管理される行を読み取ります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1543">Like a snapshot transaction, the read-committed transaction will read versioned rows even after the other transaction has modified data.</span></span> <span data-ttu-id="1f03c-1544">ただし、スナップショット トランザクションとは異なり、Read Committed トランザクションは以下のように動作します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1544">However, unlike a snapshot transaction, the read-committed transaction will:</span></span>  
  
-   <span data-ttu-id="1f03c-1545">別のトランザクションがデータの変更をコミットした後は、変更されたデータを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1545">Read the modified data after the other transaction commits the data changes.</span></span>  
  
-   <span data-ttu-id="1f03c-1546">別のトランザクションが変更したデータを変更できます。スナップショット トランザクションでは、このような変更は実行できませんでした。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1546">Be able to update the data modified by the other transaction where the snapshot transaction could not.</span></span>  
  
 <span data-ttu-id="1f03c-1547">セッション 1:</span><span class="sxs-lookup"><span data-stu-id="1f03c-1547">On session 1:</span></span>  
  
```sql  
USE AdventureWorks2012;  -- Or any earlier version of the AdventureWorks database.  
GO  
  
-- Enable READ_COMMITTED_SNAPSHOT on the database.  
-- For this statement to succeed, this session  
-- must be the only connection to the AdventureWorks2012  
-- database.  
ALTER DATABASE AdventureWorks2012  
    SET READ_COMMITTED_SNAPSHOT ON;  
GO  
  
-- Start a read-committed transaction  
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;  
GO  
  
BEGIN TRANSACTION;  
    -- This SELECT statement will return  
    -- 48 vacation hours for the employee.  
    SELECT BusinessEntityID, VacationHours  
        FROM HumanResources.Employee  
        WHERE BusinessEntityID = 4;  
  
```  
  
 <span data-ttu-id="1f03c-1548">セッション 2 :</span><span class="sxs-lookup"><span data-stu-id="1f03c-1548">On session 2:</span></span>  
  
```sql  
USE AdventureWorks2012;  
GO  
  
-- Start a transaction.  
BEGIN TRANSACTION;  
    -- Subtract a vacation day from employee 4.  
    -- Update is not blocked by session 1 since  
    -- under read-committed using row versioning shared locks are  
    -- not requested.  
    UPDATE HumanResources.Employee  
        SET VacationHours = VacationHours - 8  
        WHERE BusinessEntityID = 4;  
  
    -- Verify that the employee now has 40 vacation hours.  
    SELECT VacationHours  
        FROM HumanResources.Employee  
        WHERE BusinessEntityID = 4;  
  
```  
  
 <span data-ttu-id="1f03c-1549">セッション 1:</span><span class="sxs-lookup"><span data-stu-id="1f03c-1549">On session 1:</span></span>  
  
```sql  
    -- Reissue the SELECT statement - this still shows  
    -- the employee having 48 vacation hours.  The  
    -- read-committed transaction is still reading data   
    -- from the versioned row and the other transaction   
    -- has not committed the data changes yet.  
    SELECT BusinessEntityID, VacationHours  
        FROM HumanResources.Employee  
        WHERE BusinessEntityID = 4;  
  
```  
  
 <span data-ttu-id="1f03c-1550">セッション 2 :</span><span class="sxs-lookup"><span data-stu-id="1f03c-1550">On session 2:</span></span>  
  
```sql  
-- Commit the transaction.  
COMMIT TRANSACTION;  
GO  
  
```  
  
 <span data-ttu-id="1f03c-1551">セッション 1:</span><span class="sxs-lookup"><span data-stu-id="1f03c-1551">On session 1:</span></span>  
  
```sql  
    -- Reissue the SELECT statement which now shows the   
    -- employee having 40 vacation hours.  Being   
    -- read-committed, this transaction is reading the   
    -- committed data. This is different from snapshot  
    -- isolation which reads from the versioned row.  
    SELECT BusinessEntityID, VacationHours  
        FROM HumanResources.Employee  
        WHERE BusinessEntityID = 4;  
  
    -- This statement, which caused the snapshot transaction   
    -- to fail, will succeed with read-committed using row versioning.  
    UPDATE HumanResources.Employee  
        SET SickLeaveHours = SickLeaveHours - 8  
        WHERE BusinessEntityID = 4;  
  
-- Undo the changes to the database from session 1.   
-- This will not undo the change from session 2.  
ROLLBACK TRANSACTION;  
GO  
```  
  
### <a name="enabling-row-versioning-based-isolation-levels"></a><span data-ttu-id="1f03c-1552">行のバージョン管理に基づく分離レベルの有効化</span><span class="sxs-lookup"><span data-stu-id="1f03c-1552">Enabling Row Versioning-Based Isolation Levels</span></span>  

 <span data-ttu-id="1f03c-1553">データベース管理者は、ALTER DATABASE ステートメントの READ_COMMITTED_SNAPSHOT データベース オプションと ALLOW_SNAPSHOT_ISOLATION データベース オプションを使用して、行のバージョン管理用のデータベース レベルの設定を制御します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1553">Database administrators control the database-level settings for row versioning by using the READ_COMMITTED_SNAPSHOT and ALLOW_SNAPSHOT_ISOLATION database options in the ALTER DATABASE statement.</span></span>  
  
 <span data-ttu-id="1f03c-1554">READ_COMMITTED_SNAPSHOT データベース オプションを ON に設定すると、このオプションのサポートに使用するメカニズムが直ちにアクティブになります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1554">When the READ_COMMITTED_SNAPSHOT database option is set ON, the mechanisms used to support the option are activated immediately.</span></span> <span data-ttu-id="1f03c-1555">READ_COMMITTED_SNAPSHOT オプションを設定する場合は、データベースで ALTER DATABASE コマンドを実行する接続のみが許可されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1555">When setting the READ_COMMITTED_SNAPSHOT option, only the connection executing the ALTER DATABASE command is allowed in the database.</span></span> <span data-ttu-id="1f03c-1556">ALTER DATABASE が完了するまで、そのデータベースには他に開かれた接続が存在しないようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1556">There must be no other open connection in the database until ALTER DATABASE is complete.</span></span> <span data-ttu-id="1f03c-1557">データベースをシングル ユーザー モードにする必要はありません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1557">The database does not have to be in single-user mode.</span></span>  
  
 <span data-ttu-id="1f03c-1558">次の [!INCLUDE[tsql](../includes/tsql-md.md)] ステートメントで、READ_COMMITTED_SNAPSHOT を有効にします。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1558">The following [!INCLUDE[tsql](../includes/tsql-md.md)] statement enables READ_COMMITTED_SNAPSHOT:</span></span>  
  
```sql  
ALTER DATABASE AdventureWorks2012  
    SET READ_COMMITTED_SNAPSHOT ON;  
```  
  
 <span data-ttu-id="1f03c-1559">ALLOW_SNAPSHOT_ISOLATION データベース オプションが ON であれば、[!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)]のインスタンスは、データベース内のデータを変更したアクティブなトランザクションがすべて完了するまで、変更されたデータの行に対応するバージョンを生成しません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1559">When the ALLOW_SNAPSHOT_ISOLATION database option is set ON, the instance of the [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] does not generate row versions for modified data until all active transactions that have modified data in the database complete.</span></span> <span data-ttu-id="1f03c-1560">アクティブな変更トランザクションが存在すると、[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] によってオプションの状態が PENDING_ON に設定されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1560">If there are active modification transactions, [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] sets the state of the option to PENDING_ON.</span></span> <span data-ttu-id="1f03c-1561">すべての変更トランザクションが完了してから、このオプションの状態が ON に変更されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1561">After all of the modification transactions complete, the state of the option is changed to ON.</span></span> <span data-ttu-id="1f03c-1562">ユーザーは、オプションが完全に ON になるまで、そのデータベースでのスナップショット トランザクションを開始できません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1562">Users cannot start a snapshot transaction in that database until the option is fully ON.</span></span> <span data-ttu-id="1f03c-1563">データベース管理者が ALLOW_SNAPSHOT_ISOLATION オプションを OFF に設定すると、データベースは PENDING_OFF の状態を経てから OFF に設定されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1563">The database passes through a PENDING_OFF state when the database administrator sets the ALLOW_SNAPSHOT_ISOLATION option to OFF.</span></span>  
  
 <span data-ttu-id="1f03c-1564">次の [!INCLUDE[tsql](../includes/tsql-md.md)] ステートメントで、ALLOW_SNAPSHOT_ISOLATION を有効にします。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1564">The following [!INCLUDE[tsql](../includes/tsql-md.md)] statement will enable ALLOW_SNAPSHOT_ISOLATION:</span></span>  
  
```sql  
ALTER DATABASE AdventureWorks2012  
    SET ALLOW_SNAPSHOT_ISOLATION ON;  
```  
  
 <span data-ttu-id="1f03c-1565">次の表では、ALLOW_SNAPSHOT_ISOLATION オプションの状態を一覧し、それぞれについて説明します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1565">The following table lists and describes the states of the ALLOW_SNAPSHOT_ISOLATION option.</span></span> <span data-ttu-id="1f03c-1566">ALLOW_SNAPSHOT_ISOLATION オプションを指定して ALTER DATABASE を使用すると、現在データベースのデータにアクセスしているユーザーはブロックされません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1566">Using ALTER DATABASE with the ALLOW_SNAPSHOT_ISOLATION option does not block users who are currently accessing the database data.</span></span>  
  
|<span data-ttu-id="1f03c-1567">現在のデータベースのスナップショット分離フレームワークの状態</span><span class="sxs-lookup"><span data-stu-id="1f03c-1567">State of snapshot isolation framework for current database</span></span>|<span data-ttu-id="1f03c-1568">説明</span><span class="sxs-lookup"><span data-stu-id="1f03c-1568">Description</span></span>|  
|----------------------------------------------------------------|-----------------|  
|<span data-ttu-id="1f03c-1569">OFF</span><span class="sxs-lookup"><span data-stu-id="1f03c-1569">OFF</span></span>|<span data-ttu-id="1f03c-1570">スナップショット分離トランザクションのサポートはアクティブになりません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1570">The support for snapshot isolation transactions is not activated.</span></span> <span data-ttu-id="1f03c-1571">スナップショット分離トランザクションは許可されません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1571">No snapshot isolation transactions are allowed.</span></span>|  
|<span data-ttu-id="1f03c-1572">PENDING_ON</span><span class="sxs-lookup"><span data-stu-id="1f03c-1572">PENDING_ON</span></span>|<span data-ttu-id="1f03c-1573">スナップショット分離トランザクションのサポートが遷移中の状態 (OFF から ON) です。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1573">The support for snapshot isolation transactions is in transition state (from OFF to ON).</span></span> <span data-ttu-id="1f03c-1574">開いているトランザクションが完了する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1574">Open transactions must complete.</span></span><br /><br /> <span data-ttu-id="1f03c-1575">スナップショット分離トランザクションは許可されません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1575">No snapshot isolation transactions are allowed.</span></span>|  
|<span data-ttu-id="1f03c-1576">ON</span><span class="sxs-lookup"><span data-stu-id="1f03c-1576">ON</span></span>|<span data-ttu-id="1f03c-1577">スナップショット分離トランザクションのサポートがアクティブになります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1577">The support for snapshot isolation transactions is activated.</span></span><br /><br /> <span data-ttu-id="1f03c-1578">スナップショット トランザクションが許可されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1578">Snapshot transactions are allowed.</span></span>|  
|<span data-ttu-id="1f03c-1579">PENDING_OFF</span><span class="sxs-lookup"><span data-stu-id="1f03c-1579">PENDING_OFF</span></span>|<span data-ttu-id="1f03c-1580">スナップショット分離トランザクションのサポートが遷移中の状態 (ON から OFF) です。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1580">The support for snapshot isolation transactions is in transition state (from ON to OFF).</span></span><br /><br /> <span data-ttu-id="1f03c-1581">これ以降に開始されるスナップショット トランザクションは、このデータベースにアクセスできません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1581">Snapshot transactions started after this time cannot access this database.</span></span> <span data-ttu-id="1f03c-1582">このデータベースのバージョン管理の負荷は、依然として更新トランザクションが担っています。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1582">Update transactions still pay the cost of versioning in this database.</span></span> <span data-ttu-id="1f03c-1583">既存のスナップショット トランザクションからは、このデータベースに引き続き問題なくアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1583">Existing snapshot transactions can still access this database without a problem.</span></span> <span data-ttu-id="1f03c-1584">PENDING_OFF の状態は、データベースのスナップショット分離の状態が ON のときにアクティブであったすべてのスナップショット トランザクションが完了するまで OFF になりません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1584">The state PENDING_OFF does not become OFF until all snapshot transactions that were active when the database snapshot isolation state was ON finish.</span></span>|  
  
 <span data-ttu-id="1f03c-1585">行のバージョン管理データベース オプションの両方の状態を判断するには、sys.databases カタログ ビューを使用します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1585">Use the sys.databases catalog view to determine the state of both row versioning database options.</span></span>  
  
 <span data-ttu-id="1f03c-1586">ユーザー テーブルと、master と msdb に格納されている一部のシステム テーブルに対して更新を行うと、常に行のバージョンが生成されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1586">All updates to user tables and some system tables stored in master and msdb generate row versions.</span></span>  
  
 <span data-ttu-id="1f03c-1587">master データベースと msdb データベースでは、ALLOW_SNAPSHOT_ISOLATION オプションが自動的に ON に設定されます。このオプションを無効にすることはできません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1587">The ALLOW_SNAPSHOT_ISOLATION option is automatically set ON in the master and msdb databases, and cannot be disabled.</span></span>  
  
 <span data-ttu-id="1f03c-1588">master、tempdb、または msdb では、ユーザーが READ_COMMITTED_SNAPSHOT オプションを ON に設定することはできません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1588">Users cannot set the READ_COMMITTED_SNAPSHOT option ON in master, tempdb, or msdb.</span></span>  
  
### <a name="using-row-versioning-based-isolation-levels"></a><span data-ttu-id="1f03c-1589">行のバージョン管理に基づく分離レベルの使用</span><span class="sxs-lookup"><span data-stu-id="1f03c-1589">Using Row Versioning-based Isolation Levels</span></span>  

 <span data-ttu-id="1f03c-1590">行のバージョン管理フレームワークは、[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] では常に有効になっており、複数の機能で使用されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1590">The row versioning framework is always enabled in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)], and is used by multiple features.</span></span> <span data-ttu-id="1f03c-1591">このフレームワークは、行のバージョン管理に基づく分離レベルを提供するだけでなく、トリガーと複数のアクティブな結果セット (MARS) セッションで行われた変更のサポートおよびオンラインのインデックス操作でのデータ読み取りのサポートに使用されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1591">Besides providing row versioning-based isolation levels, it is used to support modifications made in triggers and multiple active result sets (MARS) sessions, and to support data reads for ONLINE index operations.</span></span>  
  
 <span data-ttu-id="1f03c-1592">行のバージョン管理に基づく分離レベルは、データベース レベルで有効になっています。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1592">Row versioning-based isolation levels are enabled at the database level.</span></span> <span data-ttu-id="1f03c-1593">この分離レベルが有効になっているデータベースのオブジェクトにアクセスするアプリケーションでは、次の分離レベルを使用してクエリを実行できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1593">Any application accessing objects from enabled databases can run queries using the following isolation levels:</span></span>  
  
-   <span data-ttu-id="1f03c-1594">Read Committed。次のコード例に示すように、`READ_COMMITTED_SNAPSHOT` データベース オプションを `ON` に設定して行のバージョン管理を使用します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1594">Read-committed that uses row versioning by setting the `READ_COMMITTED_SNAPSHOT` database option to `ON` as shown in the following code example:</span></span>  
  
    ```sql  
    ALTER DATABASE AdventureWorks2012  
        SET READ_COMMITTED_SNAPSHOT ON;  
    ```  
  
     <span data-ttu-id="1f03c-1595">データベースで READ COMMITTED が有効になっている場合、Read Committed 分離レベルで実行されているすべてのクエリで行のバージョン管理が使用されます。つまり、読み取り操作により更新操作がブロックされることはありません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1595">When the database is enabled for READ_COMMITTED_SNAPSHOT, all queries running under the read committed isolation level use row versioning, which means that read operations do not block update operations.</span></span>  
  
-   <span data-ttu-id="1f03c-1596">次のコード例に示すように、`ALLOW_SNAPSHOT_ISOLATION` データベース オプションを `ON` に設定することによってスナップショット分離を有効にします。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1596">Snapshot isolation by setting the `ALLOW_SNAPSHOT_ISOLATION` database option to `ON` as shown in the following code example:</span></span>  
  
    ```sql  
    ALTER DATABASE AdventureWorks2012  
        SET ALLOW_SNAPSHOT_ISOLATION ON;  
    ```  
  
     <span data-ttu-id="1f03c-1597">スナップショット分離レベルで実行中のトランザクションでは、スナップショットが有効になっているデータベースのテーブルにアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1597">A transaction running under snapshot isolation can access tables in the database that have been enabled for snapshot.</span></span> <span data-ttu-id="1f03c-1598">スナップショットが有効になっていないテーブルにアクセスするには、分離レベルを変更する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1598">To access tables that have not been enabled for snapshot, the isolation level must be changed.</span></span> <span data-ttu-id="1f03c-1599">たとえば、次のコード例では、スナップショット トランザクションで実行中に 2 つのテーブルを結合する `SELECT` ステートメントを示します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1599">For example, the following code example shows a `SELECT` statement that joins two tables while running under a snapshot transaction.</span></span> <span data-ttu-id="1f03c-1600">1 つのテーブルは、スナップショット分離が無効なデータベースに属しています。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1600">One table belongs to a database in which snapshot isolation is not enabled.</span></span> <span data-ttu-id="1f03c-1601">スナップショット分離レベルで `SELECT` ステートメントを実行すると、実行に失敗します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1601">When the `SELECT` statement runs under snapshot isolation, it fails to execute successfully.</span></span>  
  
    ```sql  
    SET TRANSACTION ISOLATION LEVEL SNAPSHOT;  
    BEGIN TRAN  
        SELECT t1.col5, t2.col5  
            FROM Table1 as t1  
            INNER JOIN SecondDB.dbo.Table2 as t2  
                ON t1.col1 = t2.col2;  
    ```  
  
     <span data-ttu-id="1f03c-1602">次に、トランザクション分離レベルを Read Committed に変更するように変更した同じ `SELECT` ステートメントのコード例を示します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1602">The following code example shows the same `SELECT` statement that has been modified to change the transaction isolation level to read-committed.</span></span> <span data-ttu-id="1f03c-1603">この変更により、`SELECT` ステートメントは正常に実行されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1603">Because of this change, the `SELECT` statement executes successfully.</span></span>  
  
    ```sql  
    SET TRANSACTION ISOLATION LEVEL SNAPSHOT;  
    BEGIN TRAN  
        SELECT t1.col5, t2.col5  
            FROM Table1 as t1  
            WITH (READCOMMITTED)  
            INNER JOIN SecondDB.dbo.Table2 as t2  
                ON t1.col1 = t2.col2;  
    ```  
  
#### <a name="limitations-of-transactions-using-row-versioning-based-isolation-levels"></a><span data-ttu-id="1f03c-1604">行のバージョン管理に基づく分離レベルを使用したトランザクションの制限事項</span><span class="sxs-lookup"><span data-stu-id="1f03c-1604">Limitations of Transactions Using Row Versioning-based Isolation Levels</span></span>  

 <span data-ttu-id="1f03c-1605">行のバージョン管理に基づく分離レベルを使用して作業する場合は、次の制限事項を考慮してください。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1605">Consider the following limitations when working with row versioning-based isolation levels:</span></span>  
  
-   <span data-ttu-id="1f03c-1606">READ_COMMITTED_SNAPSHOT は、tempdb、msdb、または master では有効にできません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1606">READ_COMMITTED_SNAPSHOT cannot be enabled in tempdb, msdb, or master.</span></span>  
  
-   <span data-ttu-id="1f03c-1607">グローバルな一時テーブルは tempdb に格納されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1607">Global temp tables are stored in tempdb.</span></span> <span data-ttu-id="1f03c-1608">スナップショット トランザクション内でグローバルな一時テーブルにアクセスする場合は、次のいずれかの操作を行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1608">When accessing global temp tables inside a snapshot transaction, one of the following must happen:</span></span>  
  
    -   <span data-ttu-id="1f03c-1609">tempdb で ALLOW_SNAPSHOT_ISOLATION データベース オプションを ON に設定します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1609">Set the ALLOW_SNAPSHOT_ISOLATION database option ON in tempdb.</span></span>  
  
    -   <span data-ttu-id="1f03c-1610">分離ヒントを使用して、ステートメントの分離レベルを変更します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1610">Use an isolation hint to change the isolation level for the statement.</span></span>  
  
-   <span data-ttu-id="1f03c-1611">スナップショット トランザクションは、次の場合に失敗します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1611">Snapshot transactions fail when:</span></span>  
  
    -   <span data-ttu-id="1f03c-1612">スナップショット トランザクションが開始してからデータベースにアクセスするまで、データベースが読み取り専用になっている場合。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1612">A database is made read-only after the snapshot transaction starts, but before the snapshot transaction accesses the database.</span></span>  
  
    -   <span data-ttu-id="1f03c-1613">複数のデータベースのオブジェクトにアクセスするときに、スナップショット トランザクションが開始してからデータベースにアクセスするまでの間にデータベースの復旧が行われるようにデータベースの状態が変更された場合。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1613">If accessing objects from multiple databases, a database state was changed in such a way that database recovery occurred after a snapshot transaction starts, but before the snapshot transaction accesses the database.</span></span> <span data-ttu-id="1f03c-1614">たとえば、データベースが OFFLINE に設定されてから ONLINE に設定された場合、データベースを自動終了して開く場合、またはデータベースをデタッチ後にアタッチする場合などがあります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1614">For example: the database was set to OFFLINE and then to ONLINE, database autoclose and open, or database detach and attach.</span></span>  
  
-   <span data-ttu-id="1f03c-1615">分散パーティション データベースのクエリなど、分散トランザクションはスナップショット分離ではサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1615">Distributed transactions, including queries in distributed partitioned databases, are not supported under snapshot isolation.</span></span>  
  
-   [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] <span data-ttu-id="1f03c-1616">では、複数バージョンのシステム メタデータは保持されません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1616">does not keep multiple versions of system metadata.</span></span> <span data-ttu-id="1f03c-1617">テーブルおよび他のデータベース オブジェクト (インデックス、ビュー、データ型、ストアド プロシージャ、および共通言語ランタイム関数) のデータ定義言語 (DDL) ステートメントにより、メタデータが変更されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1617">Data definition language (DDL) statements on tables and other database objects (indexes, views, data types, stored procedures, and common language runtime functions) change metadata.</span></span> <span data-ttu-id="1f03c-1618">DDL ステートメントでオブジェクトを変更する場合、スナップショット分離では、オブジェクトへの同時参照が原因で、スナップショット トランザクションが失敗します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1618">If a DDL statement modifies an object, any concurrent reference to the object under snapshot isolation causes the snapshot transaction to fail.</span></span> <span data-ttu-id="1f03c-1619">READ_COMMITTED_SNAPSHOT データベース オプションが ON の場合、Read Committed トランザクションにはこの制限がありません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1619">Read-committed transactions do not have this limitation when the READ_COMMITTED_SNAPSHOT database option is ON.</span></span>  
  
     <span data-ttu-id="1f03c-1620">たとえば、データベース管理者が、次の `ALTER INDEX` ステートメントを実行したとします。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1620">For example, a database administrator executes the following `ALTER INDEX` statement.</span></span>  
  
    ```sql  
    USE AdventureWorks2012;  
    GO  
    ALTER INDEX AK_Employee_LoginID  
        ON HumanResources.Employee REBUILD;  
    GO  
    ```  
  
     <span data-ttu-id="1f03c-1621">`ALTER INDEX` ステートメントの実行時にアクティブなスナップショット トランザクションでは、`HumanResources.Employee` ステートメントの実行後に `ALTER INDEX` テーブルを参照すると、エラーが発生します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1621">Any snapshot transaction that is active when the `ALTER INDEX` statement is executed receives an error if it attempts to reference the `HumanResources.Employee` table after the `ALTER INDEX` statement is executed.</span></span> <span data-ttu-id="1f03c-1622">行のバージョン管理を使用する Read Committed トランザクションは影響を受けません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1622">Read-committed transactions using row versioning are not affected.</span></span>  
  
    > [!NOTE]  
    >  <span data-ttu-id="1f03c-1623">BULK INSERT 操作 (たとえば、制約チェックを無効にする場合など) により、挿入先テーブルのメタデータが変更されることがあります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1623">BULK INSERT operations may cause changes to target table metadata (for example, when disabling constraint checks).</span></span> <span data-ttu-id="1f03c-1624">このような変更が発生すると、一括挿入されたテーブルにアクセスする同時実行中のスナップショット分離トランザクションは失敗します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1624">When this happens, concurrent snapshot isolation transactions accessing bulk inserted tables fail.</span></span>  
  
 <span data-ttu-id="1f03c-1625">[このガイドの [](#Top) ![トップに戻る] リンクで使用される矢印アイコン](media/uparrow16x16.gif "[トップに戻る] リンクで使用される矢印アイコン")</span><span class="sxs-lookup"><span data-stu-id="1f03c-1625">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
## <a name="customizing-locking-and-row-versioning"></a><span data-ttu-id="1f03c-1626">ロックおよび行のバージョン管理のカスタマイズ</span><span class="sxs-lookup"><span data-stu-id="1f03c-1626">Customizing Locking and Row Versioning</span></span>  
  
### <a name="customizing-the-lock-time-out"></a><span data-ttu-id="1f03c-1627">ロック タイムアウトのカスタマイズ</span><span class="sxs-lookup"><span data-stu-id="1f03c-1627">Customizing the Lock Time-Out</span></span>  

 <span data-ttu-id="1f03c-1628">別のトランザクションが競合するロックをリソースで既に所有しているために [!INCLUDE[msCoName](../includes/msconame-md.md)] [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] で同じリソースへのロックをトランザクションに許可できない場合、そのトランザクションはブロックされ、既存のロックが解放されるまで待機状態になります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1628">When an instance of the [!INCLUDE[msCoName](../includes/msconame-md.md)] [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] cannot grant a lock to a transaction because another transaction already owns a conflicting lock on the resource, the first transaction becomes blocked waiting for the existing lock to be released.</span></span> <span data-ttu-id="1f03c-1629">既定では、強制タイムアウト時間は設定されないので、ロック前にリソースがロックされているかどうかを調べる方法はデータにアクセスする以外にありません。そして、データにアクセスすると無期限にブロックされる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1629">By default, there is no mandatory time-out period and no way to test whether a resource is locked before locking it, except to attempt to access the data (and potentially get blocked indefinitely).</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="1f03c-1630">[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] では、**sys.dm_os_waiting_tasks** 動的管理ビューを使用して、特定のプロセスがブロックされているかどうか、またどのプロセスがブロックしているかを判断できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1630">In [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)], use the **sys.dm_os_waiting_tasks** dynamic management view to determine whether a process is being blocked and who is blocking it.</span></span> <span data-ttu-id="1f03c-1631">以前のバージョンの [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] では、**sp_who** システム ストアド プロシージャを使用していました。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1631">In earlier versions of [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)], use the **sp_who** system stored procedure.</span></span>  
  
 <span data-ttu-id="1f03c-1632">LOCK_TIMEOUT 設定により、ブロックされたリソースをステートメントが待機する最大時間をアプリケーションから設定できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1632">The LOCK_TIMEOUT setting allows an application to set a maximum time that a statement waits on a blocked resource.</span></span> <span data-ttu-id="1f03c-1633">待機時間が LOCK_TIMEOUT の設定を超えると、ブロックされているステートメントが自動的に取り消され、エラー メッセージ 1222 (`Lock request time-out period exceeded`) がアプリケーションに返されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1633">When a statement has waited longer than the LOCK_TIMEOUT setting, the blocked statement is canceled automatically, and error message 1222 (`Lock request time-out period exceeded`) is returned to the application.</span></span> <span data-ttu-id="1f03c-1634">ただし、このステートメントが含まれているトランザクションは、[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] によってロールバックされたり取り消されたりしません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1634">Any transaction containing the statement, however, is not rolled back or canceled by [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="1f03c-1635">したがって、アプリケーションはエラー メッセージ 1222 をトラップできるエラー ハンドラーを備えている必要があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1635">Therefore, the application must have an error handler that can trap error message 1222.</span></span> <span data-ttu-id="1f03c-1636">アプリケーションでこのエラーをトラップしないと、トランザクション内の各ステートメントが取り消されたことが認識されません。トランザクション内のこれ以降のステートメントが、実行されなかったステートメントに依存している可能性があるので、エラーが発生することがあります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1636">If an application does not trap the error, the application can proceed unaware that an individual statement within a transaction has been canceled, and errors can occur because statements later in the transaction might depend on the statement that was never executed.</span></span>  
  
 <span data-ttu-id="1f03c-1637">エラー メッセージ 1222 をトラップするエラー ハンドラーを実装すると、アプリケーションでタイムアウト状況を処理し、ブロックされたステートメントを自動的に再実行したりトランザクション全体をロールバックするなどの救済措置を講じることができます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1637">Implementing an error handler that traps error message 1222 allows an application to handle the time-out situation and take remedial action, such as: automatically resubmitting the statement that was blocked or rolling back the entire transaction.</span></span>  
  
 <span data-ttu-id="1f03c-1638">現在の LOCK_TIMEOUT 設定を確認するには、@ 関数を実行し @LOCK_TIMEOUT ます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1638">To determine the current LOCK_TIMEOUT setting, execute the @@LOCK_TIMEOUT function:</span></span>  
  
```sql  
SELECT @@lock_timeout;  
GO  
```  
  
### <a name="customizing-transaction-isolation-level"></a><span data-ttu-id="1f03c-1639">トランザクション分離レベルのカスタマイズ</span><span class="sxs-lookup"><span data-stu-id="1f03c-1639">Customizing Transaction Isolation Level</span></span>  

 <span data-ttu-id="1f03c-1640">READ COMMITTED は、[!INCLUDE[msCoName](../includes/msconame-md.md)] [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] の既定の分離レベルです。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1640">READ COMMITTED is the default isolation level for the [!INCLUDE[msCoName](../includes/msconame-md.md)] [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)].</span></span> <span data-ttu-id="1f03c-1641">アプリケーションを異なる分離レベルで動作させる必要がある場合、次の方法を使用して分離レベルを設定できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1641">If an application must operate at a different isolation level, it can use the following methods to set the isolation level:</span></span>  
  
-   <span data-ttu-id="1f03c-1642">[SET TRANSACTION ISOLATION LEVEL](/sql/t-sql/statements/set-transaction-isolation-level-transact-sql) ステートメントを実行します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1642">Run the [SET TRANSACTION ISOLATION LEVEL](/sql/t-sql/statements/set-transaction-isolation-level-transact-sql) statement.</span></span>  
  
-   <span data-ttu-id="1f03c-1643">System.Data.SqlClient マネージド名前空間を使用している ADO.NET アプリケーションでは、SqlConnection.BeginTransaction メソッドを使用して *IsolationLevel* オプションを指定できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1643">ADO.NET applications that use the System.Data.SqlClient managed namespace can specify an *IsolationLevel* option by using the SqlConnection.BeginTransaction method.</span></span>  
  
-   <span data-ttu-id="1f03c-1644">ADO を使用するアプリケーションでは、`Autocommit Isolation Levels` プロパティを設定できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1644">Applications that use ADO can set the `Autocommit Isolation Levels` property.</span></span>  
  
-   <span data-ttu-id="1f03c-1645">トランザクションを開始するとき、OLE DB を使用しているアプリケーションでは、*isoLevel* を必要なトランザクション分離レベルに設定して ITransactionLocal::StartTransaction を呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1645">When starting a transaction, applications using OLE DB can call ITransactionLocal::StartTransaction with *isoLevel* set to the desired transaction isolation level.</span></span> <span data-ttu-id="1f03c-1646">OLE DB を使用するアプリケーションでは、自動コミット モードの分離レベルを指定するときに、DBPROPSET_SESSION プロパティの DBPROP_SESS_AUTOCOMMITISOLEVELS を必要なトランザクション分離レベルに設定できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1646">When specifying the isolation level in autocommit mode, applications that use OLE DB can set the DBPROPSET_SESSION property DBPROP_SESS_AUTOCOMMITISOLEVELS to the desired transaction isolation level.</span></span>  
  
-   <span data-ttu-id="1f03c-1647">ODBC を使用するアプリケーションでは、SQLSetConnectAttr を使用して SQL_COPT_SS_TXN_ISOLATION 属性を設定できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1647">Applications that use ODBC can set the SQL_COPT_SS_TXN_ISOLATION attribute by using SQLSetConnectAttr.</span></span>  
  
 <span data-ttu-id="1f03c-1648">分離レベルを指定すると、[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] セッションのクエリおよびデータ操作言語 (DML) ステートメントすべてに対するロック動作は、その分離レベルで動作します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1648">When the isolation level is specified, the locking behavior for all queries and data manipulation language (DML) statements in the [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] session operates at that isolation level.</span></span> <span data-ttu-id="1f03c-1649">分離レベルは、セッションが終了するか、または分離レベルが別のレベルに設定されるまで有効です。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1649">The isolation level remains in effect until the session terminates or until the isolation level is set to another level.</span></span>  
  
 <span data-ttu-id="1f03c-1650">次の例では、`SERIALIZABLE` 分離レベルを設定します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1650">The following example sets the `SERIALIZABLE` isolation level:</span></span>  
  
```sql  
USE AdventureWorks2012;  
GO  
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;  
GO  
BEGIN TRANSACTION;  
SELECT BusinessEntityID  
    FROM HumanResources.Employee;  
GO  
```  
  
 <span data-ttu-id="1f03c-1651">分離レベルは、必要に応じて個別のクエリまたは DML ステートメントでテーブル レベルのヒントを指定することによりオーバーライドできます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1651">The isolation level can be overridden for individual query or DML statements, if necessary, by specifying a table-level hint.</span></span> <span data-ttu-id="1f03c-1652">テーブル レベルのヒントを指定しても、セッション内の他のステートメントに影響はありません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1652">Specifying a table-level hint does not affect other statements in the session.</span></span> <span data-ttu-id="1f03c-1653">テーブル レベルのヒントを使用して既定の動作を変更する操作は、どうしても必要な場合にのみ行うことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1653">We recommend that table-level hints be used to change the default behavior only when absolutely necessary.</span></span>  
  
 <span data-ttu-id="1f03c-1654">データの読み取り時に共有ロックが要求されない分離レベルを設定した場合でも、[!INCLUDE[ssDE](../includes/ssde-md.md)]ではメタデータの読み取り時にロックの取得が必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1654">The [!INCLUDE[ssDE](../includes/ssde-md.md)] might have to acquire locks when reading metadata even when the isolation level is set to a level where share locks are not requested when reading data.</span></span> <span data-ttu-id="1f03c-1655">たとえば、トランザクションが READ UNCOMMITTED 分離レベルで実行されている場合、データの読み取り時には共有ロックが取得されませんが、システム カタログ ビューの読み取り時にはロックが要求されることがあります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1655">For example, a transaction running at the read-uncommitted isolation level does not acquire share locks when reading data, but might sometime request locks when reading a system catalog view.</span></span> <span data-ttu-id="1f03c-1656">つまり、READ UNCOMMITTED 分離レベルで実行されているトランザクションでは、同時実行トランザクションでテーブルのメタデータが変更されているときに、そのテーブルに対してクエリが実行されると、ブロッキングを発生させることがあります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1656">This means it is possible for a read uncommitted transaction to cause blocking when querying a table when a concurrent transaction is modifying the metadata of that table.</span></span>  
  
 <span data-ttu-id="1f03c-1657">現在設定されているトランザクション分離レベルを特定するには、次の例に示すように、`DBCC USEROPTIONS` ステートメントを使用します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1657">To determine the transaction isolation level currently set, use the `DBCC USEROPTIONS` statement as shown in the following example.</span></span> <span data-ttu-id="1f03c-1658">次に示す結果セットは、使用中のシステムの結果セットとは異なる場合があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1658">The result set may vary from the result set on your system.</span></span>  
  
```sql  
USE AdventureWorks2012;  
GO  
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;  
GO  
DBCC USEROPTIONS;  
GO  
```  
  
 [!INCLUDE[ssResult](../includes/ssresult-md.md)]  
  
 `Set Option                   Value`  
  
 `---------------------------- -------------------------------------------`  
  
 `textsize                     2147483647`  
  
 `language                     us_english`  
  
 `dateformat                   mdy`  
  
 `datefirst                    7`  
  
 `...                          ...`  
  
 `Isolation level              repeatable read`  
  
 ``  
  
 `(14 row(s) affected)`  
  
 ``  
  
 `DBCC execution completed. If DBCC printed error messages, contact your system administrator.`  
  
### <a name="locking-hints"></a><span data-ttu-id="1f03c-1659">ロック ヒント</span><span class="sxs-lookup"><span data-stu-id="1f03c-1659">Locking Hints</span></span>  

 <span data-ttu-id="1f03c-1660">SELECT、INSERT、UPDATE、DELETE の各ステートメント内で参照する個別のテーブルにロック ヒントを指定できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1660">Locking hints can be specified for individual table references in the SELECT, INSERT, UPDATE, and DELETE statements.</span></span> <span data-ttu-id="1f03c-1661">ロック ヒントでは、[!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)]のインスタンスがテーブル データに使用するロックの種類や行のバージョン管理が指定されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1661">The hints specify the type of locking or row versioning the instance of the [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] uses for the table data.</span></span> <span data-ttu-id="1f03c-1662">テーブルレベルのロック ヒントは、オブジェクトにかけるロックの種類を詳細に制御する場合に使用できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1662">Table-level locking hints can be used when a finer control of the types of locks acquired on an object is required.</span></span> <span data-ttu-id="1f03c-1663">これらのロック ヒントは、セッションの現在のトランザクション分離レベルをオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1663">These locking hints override the current transaction isolation level for the session.</span></span>  
  
 <span data-ttu-id="1f03c-1664">ロック ヒントの指定とその動作の詳細については、「[テーブル ヒント &#40;Transact-SQL&#41;](/sql/t-sql/queries/hints-transact-sql-table)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1664">For more information about the specific locking hints and their behaviors, see [Table Hints &#40;Transact-SQL&#41;](/sql/t-sql/queries/hints-transact-sql-table).</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="1f03c-1665">[!INCLUDE[ssDE](../includes/ssde-md.md)]のクエリ オプティマイザーでは、ほとんどの場合、適切なロック レベルが選択されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1665">The [!INCLUDE[ssDE](../includes/ssde-md.md)] query optimizer almost always chooses the correct locking level.</span></span> <span data-ttu-id="1f03c-1666">必要な場合に限り、テーブルレベルのロック ヒントを使用して既定のロック動作を変更することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1666">We recommend that table-level locking hints be used to change the default locking behavior only when necessary.</span></span> <span data-ttu-id="1f03c-1667">ロック レベルを禁止すると、コンカレンシーが低下することがあります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1667">Disallowing a locking level can adversely affect concurrency.</span></span>  
  
 <span data-ttu-id="1f03c-1668">[!INCLUDE[ssDE](../includes/ssde-md.md)]では、データの読み取り時に共有ロックの要求を回避するロック ヒントが指定された SELECT を処理している場合でも、メタデータの読み取り時にロックの取得が必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1668">The [!INCLUDE[ssDE](../includes/ssde-md.md)] might have to acquire locks when reading metadata, even when processing a select with a locking hint that prevents requests for share locks when reading data.</span></span> <span data-ttu-id="1f03c-1669">たとえば、NOLOCK ヒントを使用する SELECT では、データの読み取り時には共有ロックが取得されませんが、システム カタログ ビューの読み取り時にはロックが要求される場合があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1669">For example, a SELECT using the NOLOCK hint does not acquire share locks when reading data, but might sometime request locks when reading a system catalog view.</span></span> <span data-ttu-id="1f03c-1670">そのため、NOLOCK を使用する SELECT ステートメントはブロックされる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1670">This means it is possible for a SELECT statement using NOLOCK to be blocked.</span></span>  
  
 <span data-ttu-id="1f03c-1671">次の例のように、トランザクションの分離レベルを `SERIALIZABLE` に設定し、テーブルレベルのロック ヒントとして `NOLOCK` を `SELECT` ステートメントで使用すると、シリアル化可能なトランザクションの管理に通常使用されるキー範囲ロックが取得されません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1671">As shown in the following example, if the transaction isolation level is set to `SERIALIZABLE`, and the table-level locking hint `NOLOCK` is used with the `SELECT` statement, key-range locks typically used to maintain serializable transactions are not taken.</span></span>  
  
```sql  
USE AdventureWorks2012;  
GO  
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;  
GO  
BEGIN TRANSACTION;  
GO  
SELECT JobTitle  
    FROM HumanResources.Employee WITH (NOLOCK);  
GO  
  
-- Get information about the locks held by   
-- the transaction.  
SELECT    
        resource_type,   
        resource_subtype,   
        request_mode  
    FROM sys.dm_tran_locks  
    WHERE request_session_id = @@spid;  
  
-- End the transaction.  
ROLLBACK;  
GO  
```  
  
 <span data-ttu-id="1f03c-1672">獲得されるロックのうち `HumanResources.Employee` を参照するのはスキーマ安定度 (Sch-S) ロックのみです。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1672">The only lock taken that references `HumanResources.Employee` is a schema stability (Sch-S) lock.</span></span> <span data-ttu-id="1f03c-1673">この場合、シリアル化可能性は保証されません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1673">In this case, serializability is no longer guaranteed.</span></span>  
  
 <span data-ttu-id="1f03c-1674">[!INCLUDE[ssCurrent](../includes/sscurrent-md.md)] では、ALTER TABLE の LOCK_ESCALATION オプションを指定することでテーブル ロックの使用を回避し、パーティション テーブルに対する HoBT ロックを有効にすることができます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1674">In [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)], the LOCK_ESCALATION option of ALTER TABLE can disfavor table locks, and enable HoBT locks on partitioned tables.</span></span> <span data-ttu-id="1f03c-1675">このオプションはロック ヒントではありませんが、ロックのエスカレーションを減らすために使用することができます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1675">This option is not a locking hint, but can but used to reduce lock escalation.</span></span> <span data-ttu-id="1f03c-1676">詳細については、「[ALTER TABLE &#40;Transact-SQL&#41;](/sql/t-sql/statements/alter-table-transact-sql)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1676">For more information, see [ALTER TABLE &#40;Transact-SQL&#41;](/sql/t-sql/statements/alter-table-transact-sql).</span></span>  
  
###  <a name="customizing-locking-for-an-index"></a><a name="Customize"></a> <span data-ttu-id="1f03c-1677">インデックスのロックのカスタマイズ</span><span class="sxs-lookup"><span data-stu-id="1f03c-1677">Customizing Locking for an Index</span></span>  

 <span data-ttu-id="1f03c-1678">[!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)]では、ほとんどの場合において、クエリに対し最適なロック粒度を自動的に選択するという動的ロック ストラテジを採用しています。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1678">The [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] uses a dynamic locking strategy that automatically chooses the best locking granularity for queries in most cases.</span></span> <span data-ttu-id="1f03c-1679">テーブルまたはインデックスのアクセス パターンが一定していることがわかっていて、リソースの競合を解決する必要がある場合を除き、ページと行のロックがオンになっている既定のロック レベルをオーバーライドしないことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1679">We recommend that you do not override the default locking levels, which have page and row locking on, unless table or index access patterns are well understood and consistent, and there is a resource contention problem to solve.</span></span> <span data-ttu-id="1f03c-1680">ロック レベルをオーバーライドすると、テーブルまたはインデックスへの同時アクセスのパフォーマンスが大きく低下することがあります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1680">Overriding a locking level can significantly impede concurrent access to a table or index.</span></span> <span data-ttu-id="1f03c-1681">たとえば、ユーザーが頻繁にアクセスする大きなテーブルに対してテーブルレベルのロックのみを指定すると、ボトルネックが発生します。これは、ユーザーがテーブルにアクセスする前に、テーブルレベルのロックが解除されるのを待たなければならなくなるためです。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1681">For example, specifying only table-level locks on a large table that users access heavily can cause bottlenecks because users must wait for the table-level lock to be released before accessing the table.</span></span>  
  
 <span data-ttu-id="1f03c-1682">アクセス パターンが一定していることがわかっている場合、ページまたは行のロックを禁止することが効果的なケースもいくつかあります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1682">There are a few cases where disallowing page or row locking can be beneficial, if the access patterns are well understood and consistent.</span></span> <span data-ttu-id="1f03c-1683">たとえば、あるデータベース アプリケーションでバッチ処理により週単位で更新される参照テーブルを使用しているとします。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1683">For example, a database application uses a lookup table that is updated weekly in a batch process.</span></span> <span data-ttu-id="1f03c-1684">共有 (S) ロックされているテーブルに、同時に読み取りを行うユーザーがアクセスし、排他 (X) ロックされているテーブルに、週に 1 回のバッチ更新がアクセスします。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1684">Concurrent readers access the table with a shared (S) lock and the weekly batch update accesses the table with an exclusive (X) lock.</span></span> <span data-ttu-id="1f03c-1685">テーブル上でページと行のロックをオフにし、読み取り側が共有テーブル ロックを通過して同時にテーブルにアクセスできるようにすることで、週を通したロック オーバーヘッドを小さくできます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1685">Turning off page and row locking on the table reduces the locking overhead throughout the week by allowing readers to concurrently access the table through shared table locks.</span></span> <span data-ttu-id="1f03c-1686">バッチ ジョブの実行時には、排他テーブル ロックを獲得できるので、効率的に更新を完了できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1686">When the batch job runs, it can complete the update efficiently because it obtains an exclusive table lock.</span></span>  
  
 <span data-ttu-id="1f03c-1687">週に 1 回のバッチ更新による更新の実行中は同時読み取りによるテーブルへのアクセスがブロックされるため、ページと行のロックをオフにすることが適切かどうかは状況によって異なります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1687">Turning off page and row locking might or might not be acceptable because the weekly batch update will block the concurrent readers from accessing the table while the update runs.</span></span> <span data-ttu-id="1f03c-1688">バッチ ジョブによっていくつかの行またはページのみが変更される場合は、行またはページ レベルのロックを許可するようにロック レベルを変更できます。この場合、他のセッションはブロックされることなくテーブルから読み出しを行うことができます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1688">If the batch job only changes a few rows or pages, you can change the locking level to allow row or page level locking, which will enable other sessions to read from the table without blocking.</span></span> <span data-ttu-id="1f03c-1689">バッチ ジョブで大量の更新を扱う場合は、バッチ ジョブを効率的に完了するためにテーブル上で排他ロックを取得することが最善の方法です。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1689">If the batch job has a large number of updates, obtaining an exclusive lock on the table may be the best way to ensure the batch job finishes efficiently.</span></span>  
  
 <span data-ttu-id="1f03c-1690">2 つの同時処理が同じテーブル上で行ロックを取得した後にブロックすると、どちらもページをロックする必要があるため、デッドロックが発生する場合があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1690">Occasionally a deadlock occurs when two concurrent operations acquire row locks on the same table and then block because they both need to lock the page.</span></span> <span data-ttu-id="1f03c-1691">行ロックを禁止することで、どちらかの処理が待機するようになるため、デッドロックを回避できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1691">Disallowing row locks forces one of the operations to wait, avoiding the deadlock.</span></span>  
  
 <span data-ttu-id="1f03c-1692">インデックスで使用するロックの粒度は、CREATE INDEX ステートメントまたは ALTER INDEX ステートメントを使用して設定できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1692">The granularity of locking used on an index can be set using the CREATE INDEX and ALTER INDEX statements.</span></span> <span data-ttu-id="1f03c-1693">ロック設定は、インデックス ページとテーブル ページの両方に適用されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1693">The lock settings apply to both the index pages and the table pages.</span></span> <span data-ttu-id="1f03c-1694">また、CREATE TABLE ステートメントと ALTER TABLE ステートメントを使用して、PRIMARY KEY 制約および UNIQUE 制約によるロック粒度を設定することもできます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1694">In addition, the CREATE TABLE and ALTER TABLE statements can be used to set locking granularity on PRIMARY KEY and UNIQUE constraints.</span></span> <span data-ttu-id="1f03c-1695">旧バージョンとの互換性を維持するために、 **sp_indexoption**システムストアドプロシージャでも粒度を設定できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1695">For backwards compatibility, the **sp_indexoption** system stored procedure can also set the granularity.</span></span> <span data-ttu-id="1f03c-1696">特定のインデックスの現在のロックのオプションを表示するには、INDEXPROPERTY 関数を使用します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1696">To display the current locking option for a given index, use the INDEXPROPERTY function.</span></span> <span data-ttu-id="1f03c-1697">特定のインデックスに対して、ページレベルのロック、行レベルのロック、またはこの 2 つのロックの組み合わせを禁止することができます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1697">Page-level locks, row-level locks, or a combination of page-level and row-level locks can be disallowed for a given index.</span></span>  
  
|<span data-ttu-id="1f03c-1698">禁止されるロック</span><span class="sxs-lookup"><span data-stu-id="1f03c-1698">Disallowed locks</span></span>|<span data-ttu-id="1f03c-1699">インデックスにかけられるロック</span><span class="sxs-lookup"><span data-stu-id="1f03c-1699">Index accessed by</span></span>|  
|----------------------|-----------------------|  
|<span data-ttu-id="1f03c-1700">ページレベルのロック</span><span class="sxs-lookup"><span data-stu-id="1f03c-1700">Page level</span></span>|<span data-ttu-id="1f03c-1701">行レベルおよびテーブルレベルのロック</span><span class="sxs-lookup"><span data-stu-id="1f03c-1701">Row-level and table-level locks</span></span>|  
|<span data-ttu-id="1f03c-1702">行レベルのロック</span><span class="sxs-lookup"><span data-stu-id="1f03c-1702">Row level</span></span>|<span data-ttu-id="1f03c-1703">ページレベルおよびテーブルレベルのロック</span><span class="sxs-lookup"><span data-stu-id="1f03c-1703">Page-level and table-level locks</span></span>|  
|<span data-ttu-id="1f03c-1704">ページレベルおよび行レベルのロック</span><span class="sxs-lookup"><span data-stu-id="1f03c-1704">Page level and row level</span></span>|<span data-ttu-id="1f03c-1705">テーブルレベルのロック</span><span class="sxs-lookup"><span data-stu-id="1f03c-1705">Table-level locks</span></span>|  
  
 <span data-ttu-id="1f03c-1706">[このガイドの [](#Top) ![トップに戻る] リンクで使用される矢印アイコン](media/uparrow16x16.gif "[トップに戻る] リンクで使用される矢印アイコン")</span><span class="sxs-lookup"><span data-stu-id="1f03c-1706">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
##  <a name="advanced-transaction-information"></a><a name="Advanced"></a> <span data-ttu-id="1f03c-1707">詳細なトランザクション情報</span><span class="sxs-lookup"><span data-stu-id="1f03c-1707">Advanced Transaction Information</span></span>  
  
### <a name="nesting-transactions"></a><span data-ttu-id="1f03c-1708">トランザクションの入れ子</span><span class="sxs-lookup"><span data-stu-id="1f03c-1708">Nesting Transactions</span></span>  

 <span data-ttu-id="1f03c-1709">明示的なトランザクションは入れ子にすることができます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1709">Explicit transactions can be nested.</span></span> <span data-ttu-id="1f03c-1710">これは、トランザクション内の既存のプロセスからでもアクティブ トランザクションがないプロセスからでも呼び出せるストアド プロシージャ内のトランザクションをサポートすることを主な目的としています。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1710">This is primarily intended to support transactions in stored procedures that can be called either from a process already in a transaction or from processes that have no active transaction.</span></span>  
  
 <span data-ttu-id="1f03c-1711">次の例は、入れ子構造のトランザクションの使用方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1711">The following example shows the intended use of nested transactions.</span></span> <span data-ttu-id="1f03c-1712">プロシージャ `TransProc` は、プロセスのトランザクション モードに関係なくトランザクションを実行します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1712">The procedure `TransProc` enforces its transaction regardless of the transaction mode of any process that executes it.</span></span> <span data-ttu-id="1f03c-1713">トランザクションがアクティブであるときに `TransProc` を呼び出すと、`TransProc` 内の入れ子になっているトランザクションは概して無視され、外側のトランザクションに対して行った最終的な操作に基づいて INSERT ステートメントがコミットまたはロールバックされます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1713">If `TransProc` is called when a transaction is active, the nested transaction in `TransProc` is largely ignored, and its INSERT statements are committed or rolled back based on the final action taken for the outer transaction.</span></span> <span data-ttu-id="1f03c-1714">未完了のトランザクションがないプロセスが `TransProc` を実行した場合は、プロシージャの最後に INSERT ステートメントが COMMIT TRANSACTION によって有効にコミットされます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1714">If `TransProc` is executed by a process that does not have an outstanding transaction, the COMMIT TRANSACTION at the end of the procedure effectively commits the INSERT statements.</span></span>  
  
```sql  
SET QUOTED_IDENTIFIER OFF;  
GO  
SET NOCOUNT OFF;  
GO  
CREATE TABLE TestTrans(Cola INT PRIMARY KEY,  
               Colb CHAR(3) NOT NULL);  
GO  
CREATE PROCEDURE TransProc @PriKey INT, @CharCol CHAR(3) AS  
BEGIN TRANSACTION InProc  
INSERT INTO TestTrans VALUES (@PriKey, @CharCol)  
INSERT INTO TestTrans VALUES (@PriKey + 1, @CharCol)  
COMMIT TRANSACTION InProc;  
GO  
/* Start a transaction and execute TransProc. */  
BEGIN TRANSACTION OutOfProc;  
GO  
EXEC TransProc 1, 'aaa';  
GO  
/* Roll back the outer transaction, this will  
   roll back TransProc's nested transaction. */  
ROLLBACK TRANSACTION OutOfProc;  
GO  
EXECUTE TransProc 3,'bbb';  
GO  
/* The following SELECT statement shows only rows 3 and 4 are   
   still in the table. This indicates that the commit  
   of the inner transaction from the first EXECUTE statement of  
   TransProc was overridden by the subsequent rollback. */  
SELECT * FROM TestTrans;  
GO  
```  
  
 <span data-ttu-id="1f03c-1715">[!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)]では、入れ子の内側のトランザクションのコミットが無視されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1715">Committing inner transactions is ignored by the [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)].</span></span> <span data-ttu-id="1f03c-1716">内側のトランザクションは、最も外側にあるトランザクションの最後に行われた操作に基づいてコミットまたはロールバックされます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1716">The transaction is either committed or rolled back based on the action taken at the end of the outermost transaction.</span></span> <span data-ttu-id="1f03c-1717">外側のトランザクションがコミットされると、入れ子の内側のトランザクションもコミットされます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1717">If the outer transaction is committed, the inner nested transactions are also committed.</span></span> <span data-ttu-id="1f03c-1718">外側のトランザクションがロールバックされると、内側のトランザクションも、個々がコミットされたかどうかに関係なくすべてロールバックされます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1718">If the outer transaction is rolled back, then all inner transactions are also rolled back, regardless of whether or not the inner transactions were individually committed.</span></span>  
  
 <span data-ttu-id="1f03c-1719">COMMIT TRANSACTION または COMMIT WORK への各呼び出しは、最後に実行された BEGIN TRANSACTION に適用されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1719">Each call to COMMIT TRANSACTION or COMMIT WORK applies to the last executed BEGIN TRANSACTION.</span></span> <span data-ttu-id="1f03c-1720">BEGIN TRANSACTION ステートメントが入れ子になっている場合、最後の入れ子になっているトランザクション、つまり最も内側のトランザクションだけに COMMIT ステートメントが適用されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1720">If the BEGIN TRANSACTION statements are nested, then a COMMIT statement applies only to the last nested transaction, which is the innermost transaction.</span></span> <span data-ttu-id="1f03c-1721">入れ子になったトランザクション内の COMMIT TRANSACTION *transaction_name*ステートメントが、外側のトランザクションのトランザクション名を参照している場合でも、コミットは最も内側のトランザクションにのみ適用されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1721">Even if a COMMIT TRANSACTION *transaction_name* statement within a nested transaction refers to the transaction name of the outer transaction, the commit applies only to the innermost transaction.</span></span>  
  
 <span data-ttu-id="1f03c-1722">ROLLBACK TRANSACTION ステートメントの*transaction_name*パラメーターでは、入れ子になった一連の名前付きトランザクションの内部トランザクションを参照することはできません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1722">It is not legal for the *transaction_name* parameter of a ROLLBACK TRANSACTION statement to refer to the inner transactions of a set of named nested transactions.</span></span> <span data-ttu-id="1f03c-1723">*transaction_name* で参照できるのは、最も外側のトランザクションの名前のみです。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1723">*transaction_name* can refer only to the transaction name of the outermost transaction.</span></span> <span data-ttu-id="1f03c-1724">入れ子構造になっている一連のトランザクションの任意のレベルで、外側のトランザクションの名前を使用して ROLLBACK TRANSACTION *transaction_name* ステートメントで実行すると、入れ子構造のトランザクションすべてがロールバックされます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1724">If a ROLLBACK TRANSACTION *transaction_name* statement using the name of the outer transaction is executed at any level of a set of nested transactions, all of the nested transactions are rolled back.</span></span> <span data-ttu-id="1f03c-1725">入れ子になったトランザクションの任意のレベルで、 *transaction_name*パラメーターを指定せずに rollback WORK ステートメントまたは rollback transaction ステートメントを実行すると、最も外側のトランザクションを含め、入れ子になったすべてのトランザクションがロールバックされます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1725">If a ROLLBACK WORK or ROLLBACK TRANSACTION statement without a *transaction_name* parameter is executed at any level of a set of nested transaction, it rolls back all of the nested transactions, including the outermost transaction.</span></span>  
  
 <span data-ttu-id="1f03c-1726">@ 関数は、 @TRANCOUNT 現在のトランザクションの入れ子レベルを記録します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1726">The @@TRANCOUNT function records the current transaction nesting level.</span></span> <span data-ttu-id="1f03c-1727">各 BEGIN TRANSACTION ステートメントでは @TRANCOUNT 、@ に1を加算します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1727">Each BEGIN TRANSACTION statement increments @@TRANCOUNT by one.</span></span> <span data-ttu-id="1f03c-1728">COMMIT TRANSACTION または COMMIT WORK ステートメントはそれぞれ @TRANCOUNT 、@ を1ずつデクリメントします。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1728">Each COMMIT TRANSACTION or COMMIT WORK statement decrements @@TRANCOUNT by one.</span></span> <span data-ttu-id="1f03c-1729">ROLLBACK WORK ステートメントまたは ROLLBACK TRANSACTION ステートメントでトランザクション名がない場合は、入れ子になったすべてのトランザクションをロールバックし、@ @TRANCOUNT を0に減らします。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1729">A ROLLBACK WORK or a ROLLBACK TRANSACTION statement that does not have a transaction name rolls back all nested transactions and decrements @@TRANCOUNT to 0.</span></span> <span data-ttu-id="1f03c-1730">入れ子になった一連のトランザクションの最も外側にあるトランザクションの名前を使用する ROLLBACK TRANSACTION は、入れ子になったすべてのトランザクションをロールバックし、@ @TRANCOUNT を0に減らします。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1730">A ROLLBACK TRANSACTION that uses the transaction name of the outermost transaction in a set of nested transactions rolls back all of the nested transactions and decrements @@TRANCOUNT to 0.</span></span> <span data-ttu-id="1f03c-1731">トランザクションが既に存在するかどうかが不明な場合は、[@] を選択し @TRANCOUNT て、それが1つ以上であるかどうかを確認します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1731">When you are unsure if you are already in a transaction, SELECT @@TRANCOUNT to determine if it is 1 or more.</span></span> <span data-ttu-id="1f03c-1732">@ @TRANCOUNT が0の場合、トランザクションには存在しません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1732">If @@TRANCOUNT is 0, you are not in a transaction.</span></span>  
  
### <a name="using-bound-sessions"></a><span data-ttu-id="1f03c-1733">バインドされたセッションの使用</span><span class="sxs-lookup"><span data-stu-id="1f03c-1733">Using Bound Sessions</span></span>  

 <span data-ttu-id="1f03c-1734">バインドされたセッションを使用すると、同一サーバー上の複数のセッションにまたがるアクションの調整が容易になります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1734">Bound sessions ease the coordination of actions across multiple sessions on the same server.</span></span> <span data-ttu-id="1f03c-1735">バインドされたセッションでは、2 つ以上のセッションで同じトランザクションとロックを共有できます。また、ロックの競合が発生しないで同じデータを操作できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1735">Bound sessions allow two or more sessions to share the same transaction and locks, and can work on the same data without lock conflicts.</span></span> <span data-ttu-id="1f03c-1736">バインドされたセッションは、同じアプリケーション内の複数のセッションからも、セッションが異なる複数のアプリケーションからも作成できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1736">Bound sessions can be created from multiple sessions within the same application or from multiple applications with separate sessions.</span></span>  
  
 <span data-ttu-id="1f03c-1737">バインドされたセッションに参加するために、セッションは**sp_getbindtoken**または**srv_getbindtoken** (Open Data Services を通じて) を呼び出して、バインドトークンを取得します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1737">To participate in a bound session, a session calls **sp_getbindtoken** or **srv_getbindtoken** (through Open Data Services) to get a bind token.</span></span> <span data-ttu-id="1f03c-1738">バインド トークンは、バインドされたトランザクションをそれぞれ一意に識別する文字列です。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1738">A bind token is a character string that uniquely identifies each bound transaction.</span></span> <span data-ttu-id="1f03c-1739">取得したバインド トークンは、現在のセッションにバインドされる他のセッションに送信されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1739">The bind token is then sent to the other sessions to be bound with the current session.</span></span> <span data-ttu-id="1f03c-1740">他のセッションは、最初のセッションから受信したバインド トークンを使用して **sp_bindsession** を呼び出すことにより、トランザクションにバインドされます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1740">The other sessions bind to the transaction by calling **sp_bindsession**, using the bind token received from the first session.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="1f03c-1741">**Sp_getbindtoken**または**srv_getbindtoken**を成功させるには、セッションにアクティブなユーザートランザクションが存在している必要があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1741">A session must have an active user transaction in order for **sp_getbindtoken** or **srv_getbindtoken** to succeed.</span></span>  
  
 <span data-ttu-id="1f03c-1742">最初のセッションを作成するアプリケーション コードから、その後最初のセッションに他のセッションをバインドするアプリケーション コードに、バインド トークンが転送される必要があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1742">Bind tokens must be transmitted from the application code that makes the first session to the application code that subsequently binds their sessions to the first session.</span></span> <span data-ttu-id="1f03c-1743">別のプロセスによって開始されたトランザクションのバインド トークンをアプリケーションで取得するための [!INCLUDE[tsql](../includes/tsql-md.md)] ステートメントや API 関数はありません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1743">There is no [!INCLUDE[tsql](../includes/tsql-md.md)] statement or API function that an application can use to get the bind token for a transaction started by another process.</span></span> <span data-ttu-id="1f03c-1744">バインド トークンは、次に示す方法を使用して転送できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1744">Some of the methods that can be used to transmit a bind token include the following:</span></span>  
  
-   <span data-ttu-id="1f03c-1745">バインドされるセッションがすべて同じアプリケーション プロセスから開始されている場合、バインド トークンをグローバル メモリに格納するか、パラメーターとして関数に渡すことができます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1745">If the sessions are all initiated from the same application process, bind tokens can be stored in global memory or passed into functions as a parameter.</span></span>  
  
-   <span data-ttu-id="1f03c-1746">バインドされるセッションが異なるアプリケーション プロセスで作成されている場合、RPC (リモート プロシージャ コール) や DDE (動的データ交換) などの IPC (プロセス間通信) を使用してバインド トークンを転送できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1746">If the sessions are made from separate application processes, bind tokens can be transmitted using interprocess communication (IPC), such as a remote procedure call (RPC) or dynamic data exchange (DDE).</span></span>  
  
-   <span data-ttu-id="1f03c-1747">[!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)]のインスタンス内の、最初のセッションにバインドを試みるプロセスから読み取れるテーブルに、バインド トークンを格納します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1747">Bind tokens can be stored in a table in an instance of the [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] that can be read by processes wanting to bind to the first session.</span></span>  
  
 <span data-ttu-id="1f03c-1748">バインドされたセッションのうち、一度にアクティブにできるのは 1 つだけです。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1748">Only one session in a set of bound sessions can be active at any time.</span></span> <span data-ttu-id="1f03c-1749">あるセッションがインスタンス上でステートメントを実行している場合、またはインスタンスからの結果が保留中の場合、そのセッションにバインドされている他のセッションでは、現在のセッションが処理を完了するか、現在のステートメントが取り消されるまで、そのインスタンスにアクセスできません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1749">If one session is executing a statement on the instance or has results pending from the instance, no other session bound to it can access the instance until the current session finishes processing or cancels the current statement.</span></span> <span data-ttu-id="1f03c-1750">そのインスタンスでバインドされた別のセッションからのステートメントが処理されていてビジー状態の場合、トランザクション領域が使用中なのでそのセッションを後で再試行する必要があることを示すエラーが発生します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1750">If the instance is busy processing a statement from another of the bound sessions, an error occurs indicating that the transaction space is in use and the session should retry later.</span></span>  
  
 <span data-ttu-id="1f03c-1751">セッションをバインドするときに、各セッションの分離レベル設定が保持されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1751">When you bind sessions, each session retains its isolation level setting.</span></span> <span data-ttu-id="1f03c-1752">SET TRANSACTION ISOLATION LEVEL を使用して 1 つのセッションの分離レベル設定を変更しても、そのセッションにバインドされている他のセッションの分離レベル設定は変更されません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1752">Using SET TRANSACTION ISOLATION LEVEL to change the isolation level setting of one session does not affect the setting of any other session bound to it.</span></span>  
  
#### <a name="types-of-bound-sessions"></a><span data-ttu-id="1f03c-1753">バインドされたセッションの種類</span><span class="sxs-lookup"><span data-stu-id="1f03c-1753">Types of Bound Sessions</span></span>  

 <span data-ttu-id="1f03c-1754">バインドされたセッションには "ローカル" と "分散" の 2 種類があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1754">The two types of bound sessions are local and distributed.</span></span>  
  
-   <span data-ttu-id="1f03c-1755">バインドされたローカル セッション</span><span class="sxs-lookup"><span data-stu-id="1f03c-1755">Local bound session</span></span>  
  
     <span data-ttu-id="1f03c-1756">バインドされたセッションは、[!INCLUDE[ssDE](../includes/ssde-md.md)]の 1 つのインスタンスで、1 つのトランザクションのトランザクション領域を共有できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1756">Allows bound sessions to share the transaction space of a single transaction in a single instance of the [!INCLUDE[ssDE](../includes/ssde-md.md)].</span></span>  
  
-   <span data-ttu-id="1f03c-1757">バインドされた分散セッション</span><span class="sxs-lookup"><span data-stu-id="1f03c-1757">Distributed bound session</span></span>  
  
     <span data-ttu-id="1f03c-1758">[!INCLUDE[msCoName](../includes/msconame-md.md)] 分散トランザクション コーディネーター (MS DTC) を使用して、バインドされたセッションは、トランザクション全体がコミットまたはロールバックされるまで、2 つ以上のインスタンス間で同じトランザクションを共有できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1758">Allows bound sessions to share the same transaction across two or more instances until the entire transaction is either committed or rolled back by using [!INCLUDE[msCoName](../includes/msconame-md.md)] Distributed Transaction Coordinator (MS DTC).</span></span>  
  
 <span data-ttu-id="1f03c-1759">バインドされた分散セッションは、文字列のバインド トークンによって識別されるのではなく、分散トランザクション ID 番号によって識別されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1759">Distributed bound sessions are not identified by a character string bind token; they are identified by distributed transaction identification numbers.</span></span> <span data-ttu-id="1f03c-1760">バインドされたセッションがローカル トランザクションに関係していて、リモート サーバーで SET REMOTE_PROC_TRANSACTIONS ON を指定して RPC を実行している場合、MS DTC により、バインドされたローカル トランザクションがバインドされた分散トランザクションに自動的に昇格し、MS DTC セッションが開始します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1760">If a bound session is involved in a local transaction and executes an RPC on a remote server with SET REMOTE_PROC_TRANSACTIONS ON, the local bound transaction is automatically promoted to a distributed bound transaction by MS DTC and an MS DTC session is started.</span></span>  
  
#### <a name="when-to-use-bound-sessions"></a><span data-ttu-id="1f03c-1761">バインドされたセッションの用途</span><span class="sxs-lookup"><span data-stu-id="1f03c-1761">When to Use Bound Sessions</span></span>  

 <span data-ttu-id="1f03c-1762">以前のバージョンの [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] では、バインドされたセッションは、主に、特定の拡張ストアド プロシージャの開発に使用されていました。このような拡張ストアド プロシージャでは、セッションを呼び出すプロセスに代わって [!INCLUDE[tsql](../includes/tsql-md.md)] ステートメントを実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1762">In earlier versions of [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)], bound sessions were primarily used in developing extended stored procedures that must execute [!INCLUDE[tsql](../includes/tsql-md.md)] statements on behalf of the process that calls them.</span></span> <span data-ttu-id="1f03c-1763">呼び出しプロセスをバインド トークンで拡張ストアド プロシージャのパラメーターの 1 つとして渡せば、プロシージャは呼び出し側プロセスのトランザクション領域を結合できます。これにより、拡張ストアド プロシージャを呼び出し元プロセスに統合できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1763">Having the calling process pass in a bind token as one parameter of the extended stored procedure allows the procedure to join the transaction space of the calling process, thereby integrating the extended stored procedure with the calling process.</span></span>  
  
 <span data-ttu-id="1f03c-1764">[!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)]では、CLR を使用して記述されたストアド プロシージャは、拡張ストアド プロシージャよりも安全性、拡張性、安定性が高くなります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1764">In the [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)], stored procedures written using CLR are more secure, scalable, and stable than extended stored procedures.</span></span> <span data-ttu-id="1f03c-1765">CLR ストアドプロシージャでは、 **Sqlcontext**オブジェクトを使用して、 **sp_bindsession**ではなく、呼び出し元セッションのコンテキストを結合します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1765">CLR-stored procedures use the **SqlContext** object to join the context of the calling session, not **sp_bindsession**.</span></span>  
  
 <span data-ttu-id="1f03c-1766">また、バインドされたセッションは、1 つのビジネス トランザクションで個別のプログラムが連携するようなビジネス ロジックを持つ、3 層構造のアプリケーションの開発に使用できます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1766">Bound sessions can be used to develop three-tier applications in which business logic is incorporated into separate programs that work cooperatively on a single business transaction.</span></span> <span data-ttu-id="1f03c-1767">このようなプログラムでは、データベースへのアクセス調整に注意を払う必要があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1767">These programs must be coded to carefully coordinate their access to a database.</span></span> <span data-ttu-id="1f03c-1768">2 つのセッションで同じロックを共有するので、その 2 つのプログラムで同じデータを同時に変更しないでください。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1768">Because the two sessions share the same locks, the two programs must not try to modify the same data at the same time.</span></span> <span data-ttu-id="1f03c-1769">トランザクションの一部として機能するセッションはどの時点においても 1 つだけです。並列実行はできません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1769">At any point in time, only one session can be doing work as part of the transaction; there can be no parallel execution.</span></span> <span data-ttu-id="1f03c-1770">すべての DML ステートメントが完了しそれらの結果が取得された時点など、セッション間のトランザクション切り替えは明確な降伏点でのみ行えます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1770">The transaction can only be switched between sessions at well-defined yield points, such as when all DML statements have completed and their results have been retrieved.</span></span>  
  
### <a name="coding-efficient-transactions"></a><span data-ttu-id="1f03c-1771">効率的なトランザクションのコーディング</span><span class="sxs-lookup"><span data-stu-id="1f03c-1771">Coding Efficient Transactions</span></span>  

 <span data-ttu-id="1f03c-1772">トランザクションはできるだけ短くすることが重要です。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1772">It is important to keep transactions as short as possible.</span></span> <span data-ttu-id="1f03c-1773">トランザクションが開始されると、終了するまでの間、トランザクションの ACID プロパティ (原子性、一貫性、分離性、および持続性) を損なわないよう、多数のリソースを DBMS (データベース管理システム) で確保する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1773">When a transaction is started, a database management system (DBMS) must hold many resources until the end of the transaction to protect the atomicity, consistency, isolation, and durability (ACID) properties of the transaction.</span></span> <span data-ttu-id="1f03c-1774">データを変更する場合、他のトランザクションによる読み取りを防ぐために変更する行に排他ロックをかけて保護する必要があり、排他ロックは、トランザクションがコミットされるかロールバックされるまでかけておく必要があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1774">If data is modified, the modified rows must be protected with exclusive locks that prevent any other transaction from reading the rows, and exclusive locks must be held until the transaction is committed or rolled back.</span></span> <span data-ttu-id="1f03c-1775">トランザクションの分離レベルの設定によっては、トランザクションのコミットまたはロールバックまで解除できないロックが SELECT ステートメントによってかけられる場合があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1775">Depending on transaction isolation level settings, SELECT statements may acquire locks that must be held until the transaction is committed or rolled back.</span></span> <span data-ttu-id="1f03c-1776">特に、ユーザー数が多いシステムの場合、コンカレント接続どうしによるリソースのロックの競合を減らす目的で、トランザクションをできるだけ短くする必要があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1776">Especially in systems with many users, transactions must be kept as short as possible to reduce locking contention for resources between concurrent connections.</span></span> <span data-ttu-id="1f03c-1777">実行時間が長く、効率の悪いトランザクションでもユーザー数が少なければ問題になりにくいですが、ユーザー数が数千にも及ぶシステムでは容認できません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1777">Long-running, inefficient transactions may not be a problem with small numbers of users, but they are intolerable in a system with thousands of users.</span></span> <span data-ttu-id="1f03c-1778">[!INCLUDE[ssSQL14](../includes/sssql14-md.md)][!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] 以降では、遅延持続性トランザクションがサポートされます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1778">Beginning with [!INCLUDE[ssSQL14](../includes/sssql14-md.md)][!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] supports delayed durable transactions.</span></span> <span data-ttu-id="1f03c-1779">遅延持続性トランザクションでは、持続性が保証されません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1779">Delayed durable transactions do not guarantee durability.</span></span> <span data-ttu-id="1f03c-1780">詳しくは、[トランザクションの持続性](../relational-databases/logs/control-transaction-durability.md)に関するトピックをご覧ください。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1780">See the topic [Transaction Durability](../relational-databases/logs/control-transaction-durability.md) for more information.</span></span>  
  
#### <a name="coding-guidelines"></a><span data-ttu-id="1f03c-1781">コーディングのガイドライン</span><span class="sxs-lookup"><span data-stu-id="1f03c-1781">Coding Guidelines</span></span>  

 <span data-ttu-id="1f03c-1782">効率的なトランザクションをコーディングするためのガイドラインは次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1782">These are guidelines for coding efficient transactions:</span></span>  
  
-   <span data-ttu-id="1f03c-1783">トランザクション中にユーザーによる入力を求めないようにします。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1783">Do not require input from users during a transaction.</span></span>  
  
     <span data-ttu-id="1f03c-1784">トランザクションを開始する前に、必要なすべての入力をユーザーが終えるようにします。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1784">Get all required input from users before a transaction is started.</span></span> <span data-ttu-id="1f03c-1785">トランザクション中に追加のユーザー入力が必要になった場合は、現在のトランザクションをロールバックし、ユーザーが入力を終えてからトランザクションを再度開始します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1785">If additional user input is required during a transaction, roll back the current transaction and restart the transaction after the user input is supplied.</span></span> <span data-ttu-id="1f03c-1786">ユーザーの反応が早くても、人間の反応はコンピューターの処理速度に比べるとはるかに低速です。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1786">Even if users respond immediately, human reaction times are vastly slower than computer speeds.</span></span> <span data-ttu-id="1f03c-1787">トランザクションが確保しているすべてのリソースが長時間確保されることにより、ブロッキングの問題が発生する場合があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1787">All resources held by the transaction are held for an extremely long time, which has the potential to cause blocking problems.</span></span> <span data-ttu-id="1f03c-1788">ユーザーが反応しない場合、応答が (場合によっては数分後か数時間後に) あるまでトランザクションはアクティブな状態で、重要なリソースをロックし続けます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1788">If users do not respond, the transaction remains active, locking critical resources until they respond, which may not happen for several minutes or even hours.</span></span>  
  
-   <span data-ttu-id="1f03c-1789">データの参照中は、できるだけトランザクションを開かないようにします。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1789">Do not open a transaction while browsing through data, if at all possible.</span></span>  
  
     <span data-ttu-id="1f03c-1790">トランザクションは、事前のすべてのデータ分析が完了するまで開始しないでください。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1790">Transactions should not be started until all preliminary data analysis has been completed.</span></span>  
  
-   <span data-ttu-id="1f03c-1791">トランザクションはできるだけ短くします。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1791">Keep the transaction as short as possible.</span></span>  
  
     <span data-ttu-id="1f03c-1792">どのような変更が必要なのか把握した上でトランザクションを開始し、変更ステートメントを実行し、すぐにコミットまたはロールバックします。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1792">After you know the modifications that have to be made, start a transaction, execute the modification statements, and then immediately commit or roll back.</span></span> <span data-ttu-id="1f03c-1793">トランザクションは必要になってから開きます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1793">Do not open the transaction before it is required.</span></span>  
  
-   <span data-ttu-id="1f03c-1794">ブロックを減らすため、読み取り専用のクエリには行のバージョン管理に基づく分離レベルの使用を検討します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1794">To reduce blocking, consider using a row versioning-based isolation level for read-only queries.</span></span>  
  
-   <span data-ttu-id="1f03c-1795">低いトランザクション分離レベルを賢く利用します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1795">Make intelligent use of lower transaction isolation levels.</span></span>  
  
     <span data-ttu-id="1f03c-1796">多くのアプリケーションは、READ COMMITTED トランザクション分離レベルを使用するように簡単にコーディングできます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1796">Many applications can be readily coded to use a read-committed transaction isolation level.</span></span> <span data-ttu-id="1f03c-1797">すべてのトランザクションで SERIALIZABLE トランザクション分離レベルが必要なわけではありません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1797">Not all transactions require the serializable transaction isolation level.</span></span>  
  
-   <span data-ttu-id="1f03c-1798">オプティミスティック コンカレンシー オプションなど、カーソルのコンカレンシーが低いオプションを賢く利用します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1798">Make intelligent use of lower cursor concurrency options, such as optimistic concurrency options.</span></span>  
  
     <span data-ttu-id="1f03c-1799">同時に更新が行われる確率が低いシステムの場合、めったに発生しない "ユーザーがデータを読み取った後に他のユーザーがそのデータを変更した" というエラーを処理するオーバーヘッドは、読み取る行を常にロックするオーバーヘッドに比べて小さくできます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1799">In a system with a low probability of concurrent updates, the overhead of dealing with an occasional "somebody else changed your data after you read it" error can be much lower than the overhead of always locking rows as they are read.</span></span>  
  
-   <span data-ttu-id="1f03c-1800">トランザクション中は、アクセスするデータ量をできるだけ少なくします。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1800">Access the least amount of data possible while in a transaction.</span></span>  
  
     <span data-ttu-id="1f03c-1801">アクセスするデータ量が少なければ、ロックされる行数が減るので、トランザクション間の競合が減少します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1801">This lessens the number of locked rows, thereby reducing contention between transactions.</span></span>  
  
#### <a name="avoiding-concurrency-and-resource-problems"></a><span data-ttu-id="1f03c-1802">コンカレンシーとリソースの問題の回避</span><span class="sxs-lookup"><span data-stu-id="1f03c-1802">Avoiding Concurrency and Resource Problems</span></span>  

 <span data-ttu-id="1f03c-1803">コンカレンシーおよびリソースの問題を防ぐには、暗黙のトランザクションを注意深く管理します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1803">To prevent concurrency and resource problems, manage implicit transactions carefully.</span></span> <span data-ttu-id="1f03c-1804">暗黙のトランザクションを使用する場合、COMMIT または ROLLBACK の直後の [!INCLUDE[tsql](../includes/tsql-md.md)] ステートメントから新しいトランザクションが自動的に開始されます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1804">When using implicit transactions, the next [!INCLUDE[tsql](../includes/tsql-md.md)] statement after COMMIT or ROLLBACK automatically starts a new transaction.</span></span> <span data-ttu-id="1f03c-1805">その結果、アプリケーションでデータが参照されている間や、ユーザーからの入力を要求している間にも新しいトランザクションが開くことができます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1805">This can cause a new transaction to be opened while the application browses through data, or even when it requires input from the user.</span></span> <span data-ttu-id="1f03c-1806">データの変更を防ぐことが必要な最後のトランザクションが完了した後、データの変更を防ぐことが必要な次のトランザクションまでは暗黙のトランザクションを無効にしてください。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1806">After completing the last transaction required to protect data modifications, turn off implicit transactions until a transaction is once again required to protect data modifications.</span></span> <span data-ttu-id="1f03c-1807">そうすることで、アプリケーションでデータが参照されている間やユーザーが入力している間は、[!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)]が自動コミット モードになります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1807">This process lets the [!INCLUDE[ssDEnoversion](../includes/ssdenoversion-md.md)] use autocommit mode while the application is browsing data and getting input from the user.</span></span>  
  
 <span data-ttu-id="1f03c-1808">スナップショット分離レベルが有効である場合、新しいトランザクションがロックをかけることはありませんが、実行時間の長いトランザクションを実行する間はそれ以前のトランザクションが `tempdb` から削除されません。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1808">In addition, when the snapshot isolation level is enabled, although a new transaction will not hold locks, a long-running transaction will prevent the old versions from being removed from `tempdb`.</span></span>  
  
### <a name="managing-long-running-transactions"></a><span data-ttu-id="1f03c-1809">実行時間の長いトランザクションの管理</span><span class="sxs-lookup"><span data-stu-id="1f03c-1809">Managing Long-Running Transactions</span></span>  

 <span data-ttu-id="1f03c-1810">"*実行時間の長いトランザクション*" とは、適切なタイミングでコミットまたはロールバックされていないアクティブなトランザクションです。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1810">A *long-running transaction* is an active transaction that has not been committed or roll backed the transaction in a timely manner.</span></span> <span data-ttu-id="1f03c-1811">たとえば、トランザクションの開始と終了をユーザーが制御する場合、トランザクションの実行時間が長くなる一般的な原因は、トランザクションを開始したユーザーが、トランザクションがユーザーからの応答を待っているにもかかわらず、席を外してしまうことです。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1811">For example, if the beginning and end of a transaction is controlled by the user, a typical cause of a long-running transaction is a user starting a transaction and then leaving while the transaction waits for a response from the user.</span></span>  
  
 <span data-ttu-id="1f03c-1812">トランザクションの実行時間が長くなると、次のように、データベースへの深刻な問題が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1812">A long running transaction can cause serious problems for a database, as follows:</span></span>  
  
-   <span data-ttu-id="1f03c-1813">アクティブなトランザクションが多数のコミットされていない変更を実行した後にサーバーインスタンスがシャットダウンされた場合、その後の再起動の復旧フェーズには、 **recovery interval**サーバー構成オプションまたは ALTER database... によって指定された時間よりもかなり長い時間がかかることがあります。TARGET_RECOVERY_TIME オプションを設定します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1813">If a server instance is shut down after an active transaction has performed many uncommitted modifications, the recovery phase of the subsequent restart can take much longer than the time specified by the **recovery interval** server configuration option or by the ALTER DATABASE... SET TARGET_RECOVERY_TIME option.</span></span> <span data-ttu-id="1f03c-1814">これらのオプションではそれぞれ、アクティブなチェックポイントと間接的なチェックポイントの生成頻度を制御します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1814">These options control the frequency of active and indirect checkpoints, respectively.</span></span> <span data-ttu-id="1f03c-1815">チェックポイントの種類について詳しくは、「[データベース チェックポイント &#40;SQL Server&#41;](../relational-databases/logs/database-checkpoints-sql-server.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1815">For more information about the types of checkpoints, see [Database Checkpoints &#40;SQL Server&#41;](../relational-databases/logs/database-checkpoints-sql-server.md).</span></span>  
  
-   <span data-ttu-id="1f03c-1816">さらに重要な注意事項として、待機状態のトランザクション自体によって生成される可能性のあるログ量はわずかですが、ログの切り捨てが無期限に停止されるため、トランザクション ログが大きくなり、満杯になる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1816">More importantly, although a waiting transaction might generate very little log, it holds up log truncation indefinitely, causing the transaction log to grow and possibly fill up.</span></span> <span data-ttu-id="1f03c-1817">トランザクション ログが満杯になると、データベースでは以降の更新を実行できなくなります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1817">If the transaction log fills up, the database cannot perform any more updates.</span></span> <span data-ttu-id="1f03c-1818">詳細については、「[完全なトランザクションログのトラブルシューティング &#40;SQL Server エラー 9002&#41;](../relational-databases/logs/troubleshoot-a-full-transaction-log-sql-server-error-9002.md)」と「[トランザクションログ &#40;SQL Server&#41;](../relational-databases/logs/the-transaction-log-sql-server.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1818">For more information, see [Troubleshoot a Full Transaction Log &#40;SQL Server Error 9002&#41;](../relational-databases/logs/troubleshoot-a-full-transaction-log-sql-server-error-9002.md), and [The Transaction Log &#40;SQL Server&#41;](../relational-databases/logs/the-transaction-log-sql-server.md).</span></span>  
  
#### <a name="discovering-long-running-transactions"></a><span data-ttu-id="1f03c-1819">実行時間の長いトランザクションの検出</span><span class="sxs-lookup"><span data-stu-id="1f03c-1819">Discovering Long-Running Transactions</span></span>  

 <span data-ttu-id="1f03c-1820">実行時間の長いトランザクションを検索するには、以下のいずれかの方法を使用します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1820">To look for long-running transactions, use one of the following:</span></span>  
  
-   <span data-ttu-id="1f03c-1821">**sys.dm_tran_database_transactions**</span><span class="sxs-lookup"><span data-stu-id="1f03c-1821">**sys.dm_tran_database_transactions**</span></span>  
  
     <span data-ttu-id="1f03c-1822">この動的管理ビューは、データベース レベルでのトランザクションに関する情報を返します。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1822">This dynamic management view returns information about transactions at the database level.</span></span> <span data-ttu-id="1f03c-1823">実行時間の長いトランザクションで特に関係のある列としては、最初のログ レコードの時間 (**database_transaction_begin_time**)、トランザクションの現在の状態 (**database_transaction_state**)、トランザクション ログ内の開始レコードのログ シーケンス番号 (LSN) (**database_transaction_begin_lsn**) があります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1823">For a long-running transaction, columns of particular interest include the time of the first log record (**database_transaction_begin_time**), the current state of the transaction (**database_transaction_state**), and the log sequence number (LSN) of the begin record in the transaction log (**database_transaction_begin_lsn**).</span></span>  
  
     <span data-ttu-id="1f03c-1824">詳しくは、「[sys.dm_tran_database_transactions &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-database-transactions-transact-sql)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1824">For more information, see [sys.dm_tran_database_transactions &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-database-transactions-transact-sql).</span></span>  
  
-   <span data-ttu-id="1f03c-1825">DBCC OPENTRAN</span><span class="sxs-lookup"><span data-stu-id="1f03c-1825">DBCC OPENTRAN</span></span>  
  
     <span data-ttu-id="1f03c-1826">このステートメントを使用すると、トランザクション所有者のユーザー ID を特定できます。これにより、トランザクションの実行元を特定して、より規則正しくトランザクションを終了する (トランザクションをロールバックするのではなくコミットする) ことができます。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1826">This statement lets you identify the user ID of the owner of the transaction, so you can potentially track down the source of the transaction for a more orderly termination (committing it rather than rolling it back).</span></span> <span data-ttu-id="1f03c-1827">詳しくは、「[DBCC OPENTRAN &#40;Transact-SQL&#41;](/sql/t-sql/database-console-commands/dbcc-opentran-transact-sql)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1827">For more information, see [DBCC OPENTRAN &#40;Transact-SQL&#41;](/sql/t-sql/database-console-commands/dbcc-opentran-transact-sql).</span></span>  
  
#### <a name="stopping-a-transaction"></a><span data-ttu-id="1f03c-1828">トランザクションの停止</span><span class="sxs-lookup"><span data-stu-id="1f03c-1828">Stopping a Transaction</span></span>  

 <span data-ttu-id="1f03c-1829">KILL ステートメントの使用が必要になる場合もあります。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1829">You may have to use the KILL statement.</span></span> <span data-ttu-id="1f03c-1830">ただし、重要なプロセスが実行中の場合は特に、このステートメントの使用には十分注意してください。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1830">Use this statement very carefully, however, especially when critical processes are running.</span></span> <span data-ttu-id="1f03c-1831">詳しくは、「[KILL &#40;Transact-SQL&#41;](/sql/t-sql/language-elements/kill-transact-sql)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="1f03c-1831">For more information, see [KILL &#40;Transact-SQL&#41;](/sql/t-sql/language-elements/kill-transact-sql).</span></span>  
  
 <span data-ttu-id="1f03c-1832">[このガイドの [](#Top) ![トップに戻る] リンクで使用される矢印アイコン](media/uparrow16x16.gif "[トップに戻る] リンクで使用される矢印アイコン")</span><span class="sxs-lookup"><span data-stu-id="1f03c-1832">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="1f03c-1833">参照</span><span class="sxs-lookup"><span data-stu-id="1f03c-1833">See Also</span></span>  

 <span data-ttu-id="1f03c-1834">[SQL Server 2005 行のバージョン管理ベースのトランザクション分離](https://msdn.microsoft.com/library/ms345124(v=sql.90).aspx) </span><span class="sxs-lookup"><span data-stu-id="1f03c-1834">[SQL Server 2005 Row Versioning-Based Transaction Isolation](https://msdn.microsoft.com/library/ms345124(v=sql.90).aspx) </span></span>  
 <span data-ttu-id="1f03c-1835">[行のバージョン管理のオーバーヘッド](https://blogs.msdn.com/b/sqlserverstorageengine/archive/2008/03/30/overhead-of-row-versioning.aspx) </span><span class="sxs-lookup"><span data-stu-id="1f03c-1835">[Overhead of Row Versioning](https://blogs.msdn.com/b/sqlserverstorageengine/archive/2008/03/30/overhead-of-row-versioning.aspx) </span></span>  
 [<span data-ttu-id="1f03c-1836">SQL Server 2008 で自律トランザクションを作成する方法</span><span class="sxs-lookup"><span data-stu-id="1f03c-1836">How to create an autonomous transaction in SQL Server 2008</span></span>](https://blogs.msdn.com/b/sqlprogrammability/archive/2008/08/22/how-to-create-an-autonomous-transaction-in-sql-server-2008.aspx)  
  
  
