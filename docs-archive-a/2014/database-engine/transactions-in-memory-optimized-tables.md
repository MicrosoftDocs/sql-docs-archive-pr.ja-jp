---
title: メモリ最適化テーブルのトランザクション |Microsoft Docs
ms.custom: ''
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: 2cd07d26-a1f1-4034-8d6f-f196eed1b763
author: stevestein
ms.author: sstein
ms.openlocfilehash: bc9109c7243e609e5ddd820b61386183761167bf
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/04/2020
ms.locfileid: "87742473"
---
# <a name="transactions-in-memory-optimized-tables"></a><span data-ttu-id="c4d5d-102">メモリ最適化テーブルでのトランザクション</span><span class="sxs-lookup"><span data-stu-id="c4d5d-102">Transactions in Memory-Optimized Tables</span></span>
  <span data-ttu-id="c4d5d-103">ディスク ベース テーブルでの行のバージョン管理 (SNAPSHOT 分離または READ_COMMITTED_SNAPSHOT を使用) では、オプティミスティック コンカレンシーの形式を使用します。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-103">Row versioning on disk-based tables (using SNAPSHOT isolation or READ_COMMITTED_SNAPSHOT) provides a form of optimistic concurrency control.</span></span> <span data-ttu-id="c4d5d-104">リーダーとライターは相互にブロックしません。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-104">Readers and writers do not block each other.</span></span> <span data-ttu-id="c4d5d-105">メモリ最適化テーブルでは、ライターはライターをブロックしません。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-105">With memory-optimized tables, writers do not block writers.</span></span> <span data-ttu-id="c4d5d-106">ディスク ベース テーブルの行のバージョン管理では、あるトランザクションが行をロックすると、この行を更新しようとする同時実行トランザクションがブロックされます。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-106">With row versioning on disk-based tables, one transaction locks the row and concurrent transactions attempting to update the row are blocked.</span></span> <span data-ttu-id="c4d5d-107">メモリ最適化テーブルの場合は、ロックは生じません。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-107">There is no locking with memory-optimized tables.</span></span> <span data-ttu-id="c4d5d-108">その代わり、2 つのトランザクションで同じ行を更新しようとすると、書き込みと書き込みの競合 (エラー 41302) が発生することになります。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-108">Instead, if two transactions attempt to update the same row, a write/write conflict (error 41302) will occur.</span></span>

 <span data-ttu-id="c4d5d-109">ディスクベーステーブルとは異なり、メモリ最適化テーブルでは、より高い分離レベル、REPEATABLE READ、SERIALIZABLE を使用したオプティミスティック同時実行制御が可能です。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-109">Unlike disk-based tables, memory-optimized tables allow optimistic concurrency control with the higher isolation levels, REPEATABLE READ and SERIALIZABLE.</span></span> <span data-ttu-id="c4d5d-110">分離レベルを強制するためにロックが使用されることはありません。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-110">Locks are not taken to enforce the isolation levels.</span></span> <span data-ttu-id="c4d5d-111">その代わり、トランザクションの終了時に、REPEATABLE READ または SERIALIZABLE の仮定を確認する検証が適用されます。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-111">Instead, at the end of the transaction validation ensures the repeatable read or serializability assumptions.</span></span> <span data-ttu-id="c4d5d-112">仮定に違反している場合、トランザクションは終了します。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-112">If the assumptions are violated, the transaction is terminated.</span></span> <span data-ttu-id="c4d5d-113">詳細については、「 [Transaction Isolation Levels](../../2014/database-engine/transaction-isolation-levels.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-113">For more information, see [Transaction Isolation Levels](../../2014/database-engine/transaction-isolation-levels.md).</span></span>

 <span data-ttu-id="c4d5d-114">メモリ最適化テーブルの重要なトランザクションセマンティクスは次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-114">The important transaction semantics for memory-optimized tables are:</span></span>

-   <span data-ttu-id="c4d5d-115">複数バージョン管理</span><span class="sxs-lookup"><span data-stu-id="c4d5d-115">Multi-versioning</span></span>

-   <span data-ttu-id="c4d5d-116">スナップショットベースのトランザクション分離</span><span class="sxs-lookup"><span data-stu-id="c4d5d-116">Snapshot-based transaction isolation</span></span>

-   <span data-ttu-id="c4d5d-117">Optimistic</span><span class="sxs-lookup"><span data-stu-id="c4d5d-117">Optimistic</span></span>

-   <span data-ttu-id="c4d5d-118">競合の検出</span><span class="sxs-lookup"><span data-stu-id="c4d5d-118">Conflict detection</span></span>

 <span data-ttu-id="c4d5d-119">これらのセマンティクスのそれぞれについて、以下のセクションで説明します。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-119">Each of these semantics is explained in the following sections.</span></span>

## <a name="multi-versioning-in-memory-optimized-tables"></a><span data-ttu-id="c4d5d-120">メモリ最適化テーブルでの複数バージョン管理</span><span class="sxs-lookup"><span data-stu-id="c4d5d-120">Multi-Versioning in Memory-Optimized Tables</span></span>
 <span data-ttu-id="c4d5d-121">メモリ最適化テーブルの行は、バージョンが異なる場合があります。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-121">Rows in memory-optimized tables can have different versions.</span></span> <span data-ttu-id="c4d5d-122">同時実行トランザクションでは、同じ行の異なるバージョンにアクセスする可能性があります。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-122">Concurrent transactions access potentially different versions of the same row.</span></span>

 <span data-ttu-id="c4d5d-123">メモリ最適化テーブルのデータは、バージョンに基づいています。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-123">Memory-optimized table data is version-based.</span></span> <span data-ttu-id="c4d5d-124">いずれの行についても、さまざまに異なる時点で有効な異なる行バージョンがあります。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-124">For any row there may be different row versions that are valid at different points in time.</span></span> <span data-ttu-id="c4d5d-125">ディスク ベース テーブルでは、READ_COMMITTED_SNAPSHOT または ALLOW_SNAPSHOT_ISOLATION が ON に設定されている場合に、異なる行バージョンが保持されます。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-125">Disk-based tables maintain different row versions when READ_COMMITTED_SNAPSHOT or ALLOW_SNAPSHOT_ISOLATION is ON.</span></span> <span data-ttu-id="c4d5d-126">メモリ最適化テーブルでは、READ_COMMITTED_SNAPSHOT および ALLOW_SNAPSHOT_ISOLATION が OFF に設定されている場合でも、異なる行バージョンが保持されます。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-126">Memory-optimized tables maintain different row versions, even if READ_COMMITTED_SNAPSHOT and ALLOW_SNAPSHOT_ISOLATION are OFF.</span></span> <span data-ttu-id="c4d5d-127">メモリ最適化テーブルの行バージョンは、tempdb では保持されません。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-127">The row versions of memory-optimized tables are not maintained in tempdb.</span></span> <span data-ttu-id="c4d5d-128">代わりに、行バージョンは、メモリ内に行を格納するメモリ最適化データ構造の一部として、インラインに保持されます。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-128">Instead, the row versions are maintained in-line, as part of the memory-optimized data structures storing the rows in memory.</span></span>

## <a name="snapshot-based-transaction-isolation-for-memory-optimized-tables"></a><span data-ttu-id="c4d5d-129">メモリ最適化テーブルのスナップショットベースのトランザクション分離</span><span class="sxs-lookup"><span data-stu-id="c4d5d-129">Snapshot-Based Transaction Isolation for Memory-Optimized Tables</span></span>
 <span data-ttu-id="c4d5d-130">1 つのトランザクションのすべての操作では、メモリ最適化テーブルについてトランザクション上の一貫性のある同じスナップショットを使用します。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-130">All operations in a single transaction use the same transactionally-consistent snapshot of the memory-optimized tables.</span></span> <span data-ttu-id="c4d5d-131">メモリ最適化テーブルのトランザクション分離はすべてスナップショットベースです。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-131">All transaction isolation for memory-optimized tables is snapshot-based.</span></span> <span data-ttu-id="c4d5d-132">たとえば、SERIALIZABLE 分離レベルを使用してメモリ最適化されるテーブルにアクセスするトランザクションでは、トランザクション上の一貫性のある同じスナップショットに対するすべての操作を実行します。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-132">For example, a transaction using the serializable isolation level to access memory-optimized tables will perform all operations on the same transactionally consistent snapshot.</span></span>

 <span data-ttu-id="c4d5d-133">メモリ最適化テーブルにアクセスするトランザクションでは、この行のバージョン管理を使用して、テーブルの行についてトランザクション上の一貫性のあるスナップショットを取得します。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-133">Transactions that access memory-optimized tables use this row versioning to obtain a transactionally consistent snapshot of the rows in the tables.</span></span> <span data-ttu-id="c4d5d-134">トランザクションの各ステートメントで読み取るデータは、トランザクション上の一貫性のあるバージョンのデータとなります。これは、トランザクションの開始時に存在していたデータです。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-134">The data read by any statement in the transaction will be the transactionally consistent version of the data that existed at the time the transaction started.</span></span> <span data-ttu-id="c4d5d-135">したがって、同時実行トランザクションで行われる変更は、現在のトランザクションのステートメントからは認識されません。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-135">Therefore, any modifications made by concurrently running transactions are not visible to statements in the current transaction.</span></span>

## <a name="optimistic-concurrency-control-for-memory-optimized-tables"></a><span data-ttu-id="c4d5d-136">メモリ最適化テーブルのオプティミスティック コンカレンシー</span><span class="sxs-lookup"><span data-stu-id="c4d5d-136">Optimistic Concurrency Control for Memory-Optimized Tables</span></span>
 <span data-ttu-id="c4d5d-137">競合と失敗はまれであり、メモリ最適化テーブルに対するトランザクションでは、同時実行トランザクションに競合はなく、操作は成功すると仮定します。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-137">Conflicts and failures are rare and transactions on memory-optimized tables assume there are no conflicts with concurrent transactions and operations succeed.</span></span> <span data-ttu-id="c4d5d-138">トランザクションでは、トランザクション分離を保証するためのロックまたはラッチをメモリ最適化テーブルに対して使用しません。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-138">Transactions do not take locks or latches on memory-optimized table to guarantee transaction isolation.</span></span> <span data-ttu-id="c4d5d-139">ライターはリーダーをブロックしません。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-139">Writers do not block readers.</span></span> <span data-ttu-id="c4d5d-140">ライターはライターをブロックしません。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-140">Writers do not block writers.</span></span> <span data-ttu-id="c4d5d-141">その代わり、トランザクションは、他のトランザクションとの競合がないという (オプティミスティックな) 仮定の下で実行されます。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-141">Instead, transactions proceed under the (optimistic) assumption that there will be no conflicts with other transactions.</span></span> <span data-ttu-id="c4d5d-142">ロックおよびラッチを使用せず、他のトランザクションが同じ行を処理し終わるまで待機しないことで、パフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-142">Not using locks and latches and not waiting for other transactions to finish processing the same rows improves performance.</span></span>

 <span data-ttu-id="c4d5d-143">これに加えて、トランザクション (TxA) がコミット処理中の他のトランザクション (TxB) で挿入または変更された行を読み取る場合、コミットの発生を待機する代わりに他のトランザクションがコミットされると仮定します。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-143">In addition, if a transaction (TxA) reads rows that have been inserted or modified by another transaction (TxB) that is in the process of committing, it will optimistically assume the other transaction will commit rather than wait for the commit to occur.</span></span> <span data-ttu-id="c4d5d-144">この場合、トランザクション TxA は、トランザクション TxB に対するコミット依存関係を適用します。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-144">In this case, transaction TxA will take a commit dependency on transaction TxB.</span></span>

## <a name="conflict-detection-validation-and-commit-dependency-checks"></a><span data-ttu-id="c4d5d-145">競合検出、検証、コミットの依存関係の確認</span><span class="sxs-lookup"><span data-stu-id="c4d5d-145">Conflict Detection, Validation, and Commit Dependency Checks</span></span>
 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] <span data-ttu-id="c4d5d-146">は、分離レベルの違反を検出すると共に、同時実行トランザクション間の競合を検出し、競合状態のトランザクションの一方を終了します。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-146">detects conflicts between concurrent transactions, as well as isolation level violations, and will doom one of the conflicting transactions.</span></span> <span data-ttu-id="c4d5d-147">このトランザクションは再試行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-147">This transaction will need to be retried.</span></span> <span data-ttu-id="c4d5d-148">(詳細については、「[メモリ最適化テーブルでのトランザクションの再試行ロジックのガイドライン](../relational-databases/in-memory-oltp/memory-optimized-tables.md)」を参照してください)。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-148">(For more information, see [Guidelines for Retry Logic for Transactions on Memory-Optimized Tables](../relational-databases/in-memory-oltp/memory-optimized-tables.md).)</span></span>

 <span data-ttu-id="c4d5d-149">システムでは、競合もトランザクション分離の違反もないとオプティミスティックに仮定します。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-149">The system optimistically assumes there are no conflicts and no violations of transaction isolation.</span></span> <span data-ttu-id="c4d5d-150">データベースの一貫性が損なわれる可能性がある競合や、トランザクション分離に違反する可能性がある競合が発生した場合は、それらの競合が検出されて、そのトランザクションは終了します。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-150">If any conflicts occur that may cause inconsistencies in the database or that may violate transaction isolation, these conflicts are detected, and the transaction is terminated.</span></span>

 <span data-ttu-id="c4d5d-151">競合が検出されると、トランザクションは終了し、クライアントは再試行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-151">If a conflict is detected, the transaction is terminated and the client needs to retry.</span></span>

 <span data-ttu-id="c4d5d-152">次の表は、メモリ最適化テーブルにアクセスするトランザクションのエラー状態をまとめたものです。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-152">The following table summarizes the error conditions for transactions that accesses memory-optimized tables.</span></span>

### <a name="error-conditions-for-transactions-accessing-memory-optimized-tables"></a><span data-ttu-id="c4d5d-153">メモリ最適化テーブルにアクセスするトランザクションのエラー状態。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-153">Error conditions for transactions accessing memory-optimized tables.</span></span>

|<span data-ttu-id="c4d5d-154">エラー</span><span class="sxs-lookup"><span data-stu-id="c4d5d-154">Error</span></span>|<span data-ttu-id="c4d5d-155">通信の種類</span><span class="sxs-lookup"><span data-stu-id="c4d5d-155">Scenario</span></span>|
|-----------|--------------|
|<span data-ttu-id="c4d5d-156">書き込みの競合。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-156">Write conflict.</span></span> <span data-ttu-id="c4d5d-157">トランザクションの開始以降に更新されたレコードを更新しようとしています。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-157">Attempting to update a record that has been updated since the transaction started.</span></span>|<span data-ttu-id="c4d5d-158">同時実行トランザクションによって更新または削除された行を更新または削除します。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-158">UPDATE or DELETE a row that has been updated or deleted by a concurrent transaction.</span></span>|
|<span data-ttu-id="c4d5d-159">REPEATABLE READ の検証の失敗。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-159">Repeatable read validation failure.</span></span>|<span data-ttu-id="c4d5d-160">トランザクションで読み取った行が、トランザクションの開始以降に変更 (更新または削除) されています。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-160">A row that was read by the transaction has changed (updated or deleted) since the transaction started.</span></span> <span data-ttu-id="c4d5d-161">REPEATABLE READ および SERIALIZABLE トランザクション分離レベルを使用する際には通常、REPEATABLE READ の検証が行われます。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-161">Repeatable read validation is typically occurs when using REPEATABLE READ and SERIALIZABLE transaction isolation levels.</span></span>|
|<span data-ttu-id="c4d5d-162">SERIALIZABLE の検証の失敗。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-162">Serializable validation failure.</span></span>|<span data-ttu-id="c4d5d-163">新しい (ファントム) 行が、トランザクションの開始以降にトランザクションのスキャンの範囲の 1 つに挿入されています。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-163">A new (phantom) row has been inserted in one of the scan ranges in the transaction, since the transaction started.</span></span> <span data-ttu-id="c4d5d-164">トランザクションの開始前に行がデータベースにコミットされている場合、トランザクションではその行を認識できます。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-164">The row would have been visible to the transaction if the row had been committed to the database before the transaction started.</span></span> <span data-ttu-id="c4d5d-165">SERIALIZABLE 分離を使用し、PRIMARY キー制約を検証する際には通常、SERIALIZABLE の検証が行われます。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-165">SERIALIZABLE validation typically occurs when using SERIALIZABLE isolation and validating PRIMARY KEY constraints.</span></span>|
|<span data-ttu-id="c4d5d-166">コミットの依存関係の失敗。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-166">Commit dependency failure.</span></span>|<span data-ttu-id="c4d5d-167">トランザクションで他のトランザクションに対する依存関係を適用しましたが、この表に記載されたエラーのいずれか、メモリ不足の状態、またはトランザクション ログへのコミットの失敗が原因で、コミットが失敗しました。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-167">The transaction took a dependency on another transaction that failed to commit, either due to one of the failures in this table, an out-of-memory condition, or due to failure to commit to the transaction log.</span></span> <span data-ttu-id="c4d5d-168">このエラーは、読み取り/書き込みトランザクションおよび読み取り専用トランザクションの両方で発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-168">This failure can occur with both read/write and read-only transactions.</span></span>|

### <a name="transaction-lifetime"></a><span data-ttu-id="c4d5d-169">トランザクションの有効期間</span><span class="sxs-lookup"><span data-stu-id="c4d5d-169">Transaction Lifetime</span></span>
 <span data-ttu-id="c4d5d-170">前の表に示すエラーは、トランザクションのさまざまなポイントで発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-170">The failures mentioned in the previous table can occur at different points during a transaction.</span></span> <span data-ttu-id="c4d5d-171">次の図は、メモリ最適化テーブルにアクセスするトランザクションのフェーズを示しています。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-171">The following figure illustrates the phases of a transaction that accesses memory-optimized tables.</span></span>

 <span data-ttu-id="c4d5d-172">![トランザクションの有効期間。](../../2014/database-engine/media/hekaton-transactions.gif "トランザクションの有効期間。")</span><span class="sxs-lookup"><span data-stu-id="c4d5d-172">![Lifetime of a transaction.](../../2014/database-engine/media/hekaton-transactions.gif "Lifetime of a transaction.")</span></span>
<span data-ttu-id="c4d5d-173">メモリ最適化テーブルにアクセスするトランザクションの有効期間。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-173">Lifetime of a transaction that accesses memory-optimized tables.</span></span>

#### <a name="regular-processing"></a><span data-ttu-id="c4d5d-174">通常の処理</span><span class="sxs-lookup"><span data-stu-id="c4d5d-174">Regular Processing</span></span>
 <span data-ttu-id="c4d5d-175">このフェーズでは、ユーザーが発行した [!INCLUDE[tsql](../includes/tsql-md.md)] ステートメントが実行されます。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-175">During this phase, the user-issued [!INCLUDE[tsql](../includes/tsql-md.md)] statements are executed.</span></span> <span data-ttu-id="c4d5d-176">行がテーブルから読み取られ、新しい行バージョンがデータベースに書き込まれます。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-176">Rows are read from the tables, and new row versions are written to the database.</span></span> <span data-ttu-id="c4d5d-177">トランザクションは、他のすべての同時実行トランザクションから分離されます。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-177">The transaction is isolated from all other concurrent transactions.</span></span> <span data-ttu-id="c4d5d-178">トランザクションでは、トランザクションの開始時点で存在するメモリ最適化テーブルのスナップショットを使用します。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-178">The transaction uses the snapshot of the memory-optimized tables that exists at the start of the transaction.</span></span>

 <span data-ttu-id="c4d5d-179">トランザクションのこのフェーズにおけるテーブルへの書き込みは、他のトランザクションではまだ確認できません。ただし、1 つの例外として、行の更新と削除は、書き込みの競合を検出するために、他のトランザクションでの更新操作と削除操作で確認できます。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-179">Writes to the tables in this phase of the transaction are not yet visible to other transactions, with one exception: row updates and deletes are visible to update and delete operations in other transactions, in order to detect write conflicts.</span></span>

 <span data-ttu-id="c4d5d-180">トランザクションの論理的な開始以降に行が更新または削除されたことを更新操作や削除操作で確認すると、その操作はエラー 41302 で失敗します。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-180">If an update or delete operation sees that a row has been updated or deleted since the logical start of the transaction, the operation will fail with error 41302.</span></span> <span data-ttu-id="c4d5d-181">エラー 41302 のメッセージは、"現在のトランザクションが、トランザクションが開始してから更新されたテーブル X のレコードを更新しようとしました。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-181">The message for error 41302 is "The current transaction attempted to update a record in table X that has been updated since this transaction started.</span></span> <span data-ttu-id="c4d5d-182">トランザクションは中止されました。" というものです。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-182">The transaction was aborted."</span></span>

 <span data-ttu-id="c4d5d-183">このエラーが発生すると、(XACT_ABORT が OFF の場合でも) トランザクションが破棄されます。つまり、トランザクションはユーザー セッションの終了時にロールバックされます。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-183">This error dooms the transaction (even if XACT_ABORT is OFF), meaning that the transaction will be rolled back when the user session ends.</span></span> <span data-ttu-id="c4d5d-184">失敗したトランザクションはコミットできません。ログに書き込まず、メモリ最適化テーブルにアクセスしない読み取り操作のみがサポートされます。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-184">Doomed transactions cannot be committed and only support read operations that do not write to the log and do not access memory-optimized tables.</span></span>

#####  <a name="commit-dependencies"></a><a name="cd"></a><span data-ttu-id="c4d5d-185">コミットの依存関係</span><span class="sxs-lookup"><span data-stu-id="c4d5d-185">Commit Dependencies</span></span>
 <span data-ttu-id="c4d5d-186">通常の処理中、トランザクションでは、検証またはコミット フェーズであるがまだコミットされていない、他のトランザクションによって書き込まれた行を読み取ることができます。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-186">During regular processing, a transaction can read rows written by other transactions that are in the validation or commit phase, but have not yet committed.</span></span> <span data-ttu-id="c4d5d-187">トランザクションの論理的終了時刻が検証フェーズの開始時に割り当てられているため、行が表示されます。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-187">The rows are visible because the logical end time of the transactions has been assigned at the start of the validation phase.</span></span>

 <span data-ttu-id="c4d5d-188">コミットされていない行をトランザクションで読み取る場合は、そのトランザクションに対するコミット依存関係を使用します。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-188">If a transaction reads such uncommitted rows, it will take a commit dependency on that transaction.</span></span> <span data-ttu-id="c4d5d-189">これには 2 つの主要な関連事項があります。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-189">This has two main implications:</span></span>

-   <span data-ttu-id="c4d5d-190">トランザクションは、依存先のトランザクションがコミットされるまでコミットできません。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-190">A transaction cannot commit until the transactions it depends on have committed.</span></span> <span data-ttu-id="c4d5d-191">つまり、依存関係がすべてクリアされるまで、コミット フェーズに入ることはできません。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-191">In other words, it cannot enter the commit phase, until all dependencies have cleared.</span></span>

-   <span data-ttu-id="c4d5d-192">また、結果セットは、依存関係がすべてクリアされるまで、クライアントに返されません。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-192">In addition, result sets are not returned to the client until all dependencies have cleared.</span></span> <span data-ttu-id="c4d5d-193">したがって、クライアントはコミットされていないデータを確認できません。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-193">This prevents the client from observing uncommitted data.</span></span>

 <span data-ttu-id="c4d5d-194">従属トランザクションのいずれかがコミットに失敗した場合は、コミット依存関係のエラーが発生します。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-194">If any of the dependent transactions fails to commit, there is a commit dependency failure.</span></span> <span data-ttu-id="c4d5d-195">つまり、トランザクションはエラー 41301 ("現在のトランザクションが依存している前のトランザクションが中止されたため、現在のトランザクションはコミットできません。") によりコメントされません。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-195">This means the transaction will fail to commit with error 41301 ("A previous transaction that the current transaction took a dependency on has aborted, and the current transaction can no longer commit.").</span></span>

#### <a name="validation-phase"></a><span data-ttu-id="c4d5d-196">検証フェーズ</span><span class="sxs-lookup"><span data-stu-id="c4d5d-196">Validation Phase</span></span>
 <span data-ttu-id="c4d5d-197">検証フェーズでは、トランザクションの論理的開始から論理的終了までの期間について、システムは要求されたトランザクション分離レベルに必要な仮定が true であったことを検証します。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-197">During the validation phase, the system validates that the assumptions necessary for the requested transaction isolation level were true between the logical start and logical end of the transaction.</span></span>

 <span data-ttu-id="c4d5d-198">検証フェーズの開始時に、トランザクションには論理的終了時刻が割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-198">At the start of the validation phase, the transaction is assigned a logical end time.</span></span> <span data-ttu-id="c4d5d-199">データベースに書き込まれた行バージョンは、論理的終了時刻の時点で他のトランザクションから確認できるようになります。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-199">The row versions written in the database become visible to other transactions at the logical end time.</span></span> <span data-ttu-id="c4d5d-200">詳細については、「[依存関係のコミット](#cd)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-200">For more information, see [Commit Dependencies](#cd).</span></span>

##### <a name="repeatable-read-validation"></a><span data-ttu-id="c4d5d-201">REPEATABLE READ の検証</span><span class="sxs-lookup"><span data-stu-id="c4d5d-201">Repeatable Read Validation</span></span>
 <span data-ttu-id="c4d5d-202">トランザクションの分離レベルが REPEATABLE READ または SERIALIZABLE である場合、または REPEATABLE READ または SERIALIZABLE 分離でテーブルにアクセスする場合 (詳細については、「[トランザクション分離レベル](../../2014/database-engine/transaction-isolation-levels.md)の個々の操作の分離」セクションを参照)、システムは読み取りが反復可能であることを検証します。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-202">If the isolation level of the transaction is REPEATABLE READ or SERIALIZABLE, or if tables are accessed under REPEATABLE READ or SERIALIZABLE isolation (for more information, see the section on Isolation of Individual Operations in [Transaction Isolation Levels](../../2014/database-engine/transaction-isolation-levels.md)), the system validates that the reads are repeatable.</span></span> <span data-ttu-id="c4d5d-203">つまり、トランザクションによって読み取られる行バージョンが、トランザクションの論理的終了時刻の時点で依然として有効な行バージョンであることを検証します。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-203">This means it validates that the versions of the rows read by the transaction are still valid row versions at the logical end time of the transaction.</span></span>

 <span data-ttu-id="c4d5d-204">更新または変更された行がある場合、トランザクションはエラー 41305 ("現在のトランザクションは、REPEATABLE READ の検証の失敗が原因でコミットされませんでした。") によりコミットされません。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-204">If any of the rows have been updated or changed, the transaction fails to commit with error 41305 ("The current transaction failed to commit due to a repeatable read validation failure.").</span></span>

 <span data-ttu-id="c4d5d-205">このエラーは、挿入操作、更新操作、または削除操作の後、およびトランザクションのコミット前にテーブルが削除された場合にも発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-205">This error can also occur if a table is dropped after an insert, update, or delete operation and before the transaction commits.</span></span> <span data-ttu-id="c4d5d-206">このことは、ネイティブ コンパイル ストアド プロシージャでの挿入操作、更新操作、または削除操作にのみ当てはまります。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-206">This applies only to insert, update, or delete operations in natively compiled stored procedures.</span></span> <span data-ttu-id="c4d5d-207">解釈された [!INCLUDE[tsql](../includes/tsql-md.md)] を使用して実行される書き込み操作では、DROP TABLE ステートメントによるブロックを行い、トランザクションがコミットされるまで待機します。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-207">Such write operations performed through interpreted [!INCLUDE[tsql](../includes/tsql-md.md)] cause the DROP TABLE statement to block and wait until the transaction commits.</span></span>

##### <a name="serializable-validation"></a><span data-ttu-id="c4d5d-208">SERIALIZABLE の検証</span><span class="sxs-lookup"><span data-stu-id="c4d5d-208">Serializable Validation</span></span>
 <span data-ttu-id="c4d5d-209">SERIALIZABLE の検証は、次の 2 つの場合に発生します。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-209">Serializable validation is performed in two cases:</span></span>

-   <span data-ttu-id="c4d5d-210">トランザクションの分離レベルが SERIALIZABLE であるか、テーブルが SERIALIZABLE 分離の下でアクセスされる場合。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-210">If the isolation level of the transaction is SERIALIZABLE or tables are accessed under SERIALIZABLE isolation.</span></span>

-   <span data-ttu-id="c4d5d-211">PRIMARY KEY 制約に対して作成されたインデックスなど、一意のインデックスに行が挿入された場合。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-211">If rows are inserted in a unique index, such as the index created for a PRIMARY KEY constraint.</span></span> <span data-ttu-id="c4d5d-212">システムは、同じキーを持つ行が同時に挿入されていないことを検証します。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-212">The system validates that no rows with the same key have been concurrently inserted.</span></span>

 <span data-ttu-id="c4d5d-213">システムは、ファントム行がデータベースに書き込まれていないことを検証します。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-213">The system validates that no phantom rows have been written to the database.</span></span> <span data-ttu-id="c4d5d-214">トランザクションで実行される読み取り操作が評価され、その読み取り操作のスキャン範囲に新しい行が挿入されていないことが判定されます。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-214">The read operations performed by the transaction are evaluated to determine that no new rows were inserted in the scan ranges of these read operations.</span></span>

 <span data-ttu-id="c4d5d-215">一意のインデックスにキーを挿入する場合は、暗黙の読み取り操作が行われ、そのキーが重複していないことが判定されます。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-215">Insertion of a key in a unique index includes an implicit read operation, to determine that the key is not a duplicate.</span></span> <span data-ttu-id="c4d5d-216">一意のインデックスに対する SERIALIZABLE の検証では、2 つのトランザクションで同時に同じキーを挿入した場合、これらのインデックスで重複が不可能であることを確認します。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-216">Serializable validation for unique indexes ensures these indexes cannot have duplicates in case two transactions concurrently insert the same key.</span></span>

 <span data-ttu-id="c4d5d-217">ファントム行が検出された場合、トランザクションはエラー 41325 ("現在のトランザクションは、REPEATABLE READ の検証の失敗が原因でコミットされませんでした。") によりコミットされません。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-217">If phantom rows are detected, the transaction fails to commit with error 41325 ("The current transaction failed to commit due to a serializable validation failure.").</span></span>

#### <a name="commit-processing"></a><span data-ttu-id="c4d5d-218">コミット処理</span><span class="sxs-lookup"><span data-stu-id="c4d5d-218">Commit Processing</span></span>
 <span data-ttu-id="c4d5d-219">検証が成功し、トランザクション依存関係がすべてクリアされると、トランザクションはコミット処理フェーズに入ります。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-219">If validation succeeds and all transaction dependencies clear, the transaction enters the commit processing phase.</span></span> <span data-ttu-id="c4d5d-220">このフェーズでは、持続性のあるテーブルへの変更はログに書き込まれ、そのログはディスクに書き込まれて、持続性が確保されます。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-220">During this phase the changes to durable tables are written to the log, and the log is written to disk, to ensure durability.</span></span> <span data-ttu-id="c4d5d-221">トランザクションのログ レコードがディスクに書き込まれると、制御はクライアントに返されます。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-221">Once the log record for the transaction has been written to disk, control is returned to the client.</span></span>

 <span data-ttu-id="c4d5d-222">このトランザクションの依存関係はすべてクリアされ、このトランザクションのコミットを待機していたすべてのトランザクションを処理できるようになります。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-222">All commit dependencies on this transaction are cleared, and all transactions that had been waiting for this transaction to commit can proceed.</span></span>

## <a name="limitations"></a><span data-ttu-id="c4d5d-223">制限事項</span><span class="sxs-lookup"><span data-stu-id="c4d5d-223">Limitations</span></span>

-   <span data-ttu-id="c4d5d-224">複数データベースにまたがるトランザクションは、メモリ最適化テーブルではサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-224">Cross-database transactions are not supported with memory-optimized tables.</span></span> <span data-ttu-id="c4d5d-225">メモリ最適化テーブルにアクセスする各トランザクションは、複数のデータベースにアクセスできません。ただし、tempdb への読み取り/書き込みアクセスとシステム データベース マスターへの読み取り専用アクセスは例外です。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-225">Every transaction that accesses memory-optimized tables cannot access more than one database, with the exception of read-write access to tempdb and read-only access to the system database master.</span></span>

-   <span data-ttu-id="c4d5d-226">分散トランザクションは、メモリ最適化テーブルではサポートされません。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-226">Distributed transactions are not supported with memory-optimized tables.</span></span> <span data-ttu-id="c4d5d-227">BEGIN DISTRIBUTED TRANSACTION で開始される分散トランザクションは、メモリ最適化テーブルにアクセスできません。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-227">Distributed transactions started with BEGIN DISTRIBUTED TRANSACTION cannot access memory-optimized tables.</span></span>

-   <span data-ttu-id="c4d5d-228">メモリ最適化テーブルは、ロックをサポートしません。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-228">Memory-optimized tables do not support locking.</span></span> <span data-ttu-id="c4d5d-229">ロック ヒント (TABLOCK、XLOCK、ROWLOCK など) による明示的なロックは、メモリ最適化テーブルではサポートされません。</span><span class="sxs-lookup"><span data-stu-id="c4d5d-229">Explicit locks through locking hints (such as TABLOCK, XLOCK, ROWLOCK) are not supported with memory-optimized tables.</span></span>

## <a name="see-also"></a><span data-ttu-id="c4d5d-230">参照</span><span class="sxs-lookup"><span data-stu-id="c4d5d-230">See Also</span></span>
 [<span data-ttu-id="c4d5d-231">メモリ最適化テーブルを対象にするトランザクションについて</span><span class="sxs-lookup"><span data-stu-id="c4d5d-231">Understanding Transactions on Memory-Optimized Tables</span></span>](../../2014/database-engine/understanding-transactions-on-memory-optimized-tables.md)


