---
title: CLR でホストされる環境 |Microsoft Docs
ms.custom: ''
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: clr
ms.topic: reference
helpviewer_keywords:
- type-safe code [CLR integration]
- UNSAFE permission set
- run-time environments [CLR integration]
- common language runtime [SQL Server], about CLR integration
- application domains [CLR integration]
- host protection attributes [CLR integration]
- managed code [SQL Server], common language runtime
- permission sets [CLR integration]
- reliability [CLR integration]
- SAFE permission set
- code access security [CLR integration]
- EXTERNAL_ACCESS permission set
- verifying type safety
- scalability [CLR integration]
- hosted environments [CLR integration]
- HPAs [CLR integration]
ms.assetid: d280d359-08f0-47b5-a07e-67dd2a58ad73
author: rothja
ms.author: jroth
ms.openlocfilehash: bd04536d1dfb8a4657fbe116cdfd38a6639a6327
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/04/2020
ms.locfileid: "87720025"
---
# <a name="clr-hosted-environment"></a><span data-ttu-id="3b772-102">CLR ホスト環境</span><span class="sxs-lookup"><span data-stu-id="3b772-102">CLR Hosted Environment</span></span>
  <span data-ttu-id="3b772-103">[!INCLUDE[msCoName](../../../includes/msconame-md.md)] .NET Framework CLR (共通言語ランタイム) は、[!INCLUDE[msCoName](../../../includes/msconame-md.md)] Visual C#、[!INCLUDE[msCoName](../../../includes/msconame-md.md)] Visual Basic、[!INCLUDE[msCoName](../../../includes/msconame-md.md)] Visual C++ など、多くの最新のプログラミング言語を実行する環境です。</span><span class="sxs-lookup"><span data-stu-id="3b772-103">The [!INCLUDE[msCoName](../../../includes/msconame-md.md)] .NET Framework common language runtime (CLR) is an environment that executes many modern programming languages, including [!INCLUDE[msCoName](../../../includes/msconame-md.md)] Visual C#, [!INCLUDE[msCoName](../../../includes/msconame-md.md)] Visual Basic, and [!INCLUDE[msCoName](../../../includes/msconame-md.md)] Visual C++.</span></span> <span data-ttu-id="3b772-104">CLR の特色には、ガベージ コレクションが行われるメモリ、プリエンプティブなスレッド処理、メタデータ サービス (型リフレクション)、コードの検証可能性、コード アクセス セキュリティなどがあります。</span><span class="sxs-lookup"><span data-stu-id="3b772-104">The CLR features garbage-collected memory, pre-emptive threading, metadata services (type reflection), code verifiability, and code access security.</span></span> <span data-ttu-id="3b772-105">CLR では、クラスの検索と読み込み、メモリ内でのインスタンスのレイアウト、メソッド呼び出しの解決、ネイティブ コードの生成、セキュリティの設定、およびランタイム コンテキスト境界の設定にメタデータが使用されます。</span><span class="sxs-lookup"><span data-stu-id="3b772-105">The CLR uses metadata to locate and load classes, lay out instances in memory, resolve method invocations, generate native code, enforce security, and set run-time context boundaries.</span></span>  
  
 <span data-ttu-id="3b772-106">CLR と [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] のランタイム環境では、メモリ、スレッド、および同期の処理方法が異なります。</span><span class="sxs-lookup"><span data-stu-id="3b772-106">The CLR and [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] differ as run-time environments in the way they handle memory, threads, and synchronization.</span></span> <span data-ttu-id="3b772-107">このトピックでは、すべてのシステム リソースが統一的に管理されるように、これら 2 つのランタイムを統合する方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="3b772-107">This topic describes the way in which these two run times are integrated so that all system resources are managed uniformly.</span></span> <span data-ttu-id="3b772-108">また、信頼性が高く、セキュリティで保護された実行環境をユーザー コードに提供するために、CLR CAS (コード アクセス セキュリティ) と [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] セキュリティを統合する方法についても説明します。</span><span class="sxs-lookup"><span data-stu-id="3b772-108">This topic also covers the way in which CLR code access security (CAS) and [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] security are integrated to provide a reliable and secure execution environment for user code.</span></span>  
  
## <a name="basic-concepts-of-clr-architecture"></a><span data-ttu-id="3b772-109">CLR アーキテクチャの基本概念</span><span class="sxs-lookup"><span data-stu-id="3b772-109">Basic Concepts of CLR Architecture</span></span>  
 <span data-ttu-id="3b772-110">.NET Framework では、プログラマは高級言語を使ってクラスを実装し、そのクラスの構造 (クラスのフィールドやプロパティなど) とメソッドを定義します。</span><span class="sxs-lookup"><span data-stu-id="3b772-110">In the .NET Framework, a programmer writes in a high-level language that implements a class defining its structure (for example, the fields or properties of the class) and methods.</span></span> <span data-ttu-id="3b772-111">このようなメソッドの一部は、静的関数にすることができます。</span><span class="sxs-lookup"><span data-stu-id="3b772-111">Some of these methods can be static functions.</span></span> <span data-ttu-id="3b772-112">プログラムをコンパイルするとアセンブリと呼ばれるファイルが作成されます。このファイルには、MSIL ([!INCLUDE[msCoName](../../../includes/msconame-md.md)] Intermediate Language) 形式のコンパイル済みコードと、依存アセンブリへのすべての参照を含むマニフェストが含まれます。</span><span class="sxs-lookup"><span data-stu-id="3b772-112">The compilation of the program produces a file called an assembly that contains the compiled code in the [!INCLUDE[msCoName](../../../includes/msconame-md.md)] intermediate language (MSIL), and a manifest that contains all references to dependent assemblies.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="3b772-113">アセンブリは CLR アーキテクチャの不可欠な要素です。</span><span class="sxs-lookup"><span data-stu-id="3b772-113">Assemblies are a vital element in the architecture of the CLR.</span></span> <span data-ttu-id="3b772-114">アセンブリは、.NET Framework のアプリケーション コードのパッケージ化、配置、およびバージョン管理の単位になります。</span><span class="sxs-lookup"><span data-stu-id="3b772-114">They are the units of packaging, deployment, and versioning of application code in the .NET Framework.</span></span> <span data-ttu-id="3b772-115">アセンブリを使用して、データベース内部にアプリケーション コードを配置し、完全なデータベース アプリケーションの管理、バックアップ、および復元を行うための統一された方法を提供できます。</span><span class="sxs-lookup"><span data-stu-id="3b772-115">Using assemblies, you can deploy application code inside the database and provide a uniform way to administer, back up, and restore complete database applications.</span></span>  
  
 <span data-ttu-id="3b772-116">アセンブリ マニフェストには、アセンブリに関するメタデータが含まれており、プログラムで定義されているすべての構造体、フィールド、プロパティ、クラス、継承関係、関数、およびメソッドの情報が記述されています。</span><span class="sxs-lookup"><span data-stu-id="3b772-116">The assembly manifest contains metadata about the assembly, describing all of the structures, fields, properties, classes, inheritance relationships, functions, and methods defined in the program.</span></span> <span data-ttu-id="3b772-117">マニフェストでは、アセンブリ ID の確立、アセンブリの実装を構成するファイルの指定、アセンブリを構成する型やリソースの指定、他のアセンブリに対するコンパイル時の依存関係の列挙、およびアセンブリを正しく実行するために必要な権限セットの指定を行います。</span><span class="sxs-lookup"><span data-stu-id="3b772-117">The manifest establishes the assembly identity, specifies the files that make up the assembly implementation, specifies the types and resources that make up the assembly, itemizes the compile-time dependencies on other assemblies, and specifies the set of permissions required for the assembly to run properly.</span></span> <span data-ttu-id="3b772-118">この情報を実行時に使用して、参照の解決、バージョン バインド ポリシーの設定、および読み込まれたアセンブリの整合性の検証が行われます。</span><span class="sxs-lookup"><span data-stu-id="3b772-118">This information is used at run time to resolve references, enforce version binding policy, and validate the integrity of loaded assemblies.</span></span>  
  
 <span data-ttu-id="3b772-119">.NET Framework では、アプリケーションがメタデータでキャプチャできる追加情報により、クラス、プロパティ、関数、およびメソッドに注釈を付けるためのカスタム属性がサポートされます。</span><span class="sxs-lookup"><span data-stu-id="3b772-119">The .NET Framework supports custom attributes for annotating classes, properties, functions, and methods with additional information the application may capture in metadata.</span></span> <span data-ttu-id="3b772-120">すべての .NET Framework コンパイラでは、このような注釈を解釈せずに使用し、アセンブリ メタデータとして格納します。</span><span class="sxs-lookup"><span data-stu-id="3b772-120">All .NET Framework compilers consume these annotations without interpretation and store them as assembly metadata.</span></span> <span data-ttu-id="3b772-121">このような注釈は、他のメタデータと同じ方法で調べることができます。</span><span class="sxs-lookup"><span data-stu-id="3b772-121">These annotations can be examined in the same way as any other metadata.</span></span>  
  
 <span data-ttu-id="3b772-122">マネージド コードは、オペレーティング システムが直接実行するのではなく、CLR で MSIL として実行されます。</span><span class="sxs-lookup"><span data-stu-id="3b772-122">Managed code is MSIL executed in the CLR, rather than directly by the operating system.</span></span> <span data-ttu-id="3b772-123">マネージド コード アプリケーションは、自動ガベージ コレクション、ランタイム型チェック、セキュリティ サポートなどの CLR サービスを使用します。</span><span class="sxs-lookup"><span data-stu-id="3b772-123">Managed code applications acquire CLR services, such as automatic garbage collection, run-time type checking, and security support.</span></span> <span data-ttu-id="3b772-124">これらのサービスは、プラットフォームや言語に依存しない統一的な動作を、マネージド コード アプリケーションに提供するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="3b772-124">These services help provide uniform platform- and language-independent behavior of managed code applications.</span></span>  
  
## <a name="design-goals-of-clr-integration"></a><span data-ttu-id="3b772-125">CLR 統合の設計目標</span><span class="sxs-lookup"><span data-stu-id="3b772-125">Design Goals of CLR Integration</span></span>  
 <span data-ttu-id="3b772-126">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] の CLR ホスト環境 (CLR 統合) 内でユーザー コードを実行するときは、次の設計目標が適用されます。</span><span class="sxs-lookup"><span data-stu-id="3b772-126">When user code runs inside the CLR-hosted environment in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] (called CLR integration), the following design goals apply:</span></span>  
  
###### <a name="reliability-safety"></a><span data-ttu-id="3b772-127">信頼性 (安全性)</span><span class="sxs-lookup"><span data-stu-id="3b772-127">Reliability (Safety)</span></span>  
 <span data-ttu-id="3b772-128">ユーザーからの応答を要求するメッセージ ボックスの表示やプロセスの終了など、データベース エンジン プロセスの整合性に影響を与える操作は、ユーザー コードから実行できないようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="3b772-128">User code should not be allowed to perform operations that compromise the integrity of the Database Engine process, such as popping a message box requesting a user response or exiting the process.</span></span> <span data-ttu-id="3b772-129">ユーザー コードからデータベース エンジンのメモリ バッファーや内部データ構造体への上書きを許可しないでください。</span><span class="sxs-lookup"><span data-stu-id="3b772-129">User code should not be able to overwrite Database Engine memory buffers or internal data structures.</span></span>  
  
###### <a name="scalability"></a><span data-ttu-id="3b772-130">スケーラビリティ</span><span class="sxs-lookup"><span data-stu-id="3b772-130">Scalability</span></span>  
 <span data-ttu-id="3b772-131">スケジュール設定とメモリ管理の内部モデルは、[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] と CLR で異なります。</span><span class="sxs-lookup"><span data-stu-id="3b772-131">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] and the CLR have different internal models for scheduling and memory management.</span></span> [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] <span data-ttu-id="3b772-132">では、協調動作する非プリエンプティブなスレッド モデルがサポートされます。このモデルでは、定期的に、またはスレッドがロックや I/O を待機しているときに、スレッドの実行が自主的に明け渡されます。</span><span class="sxs-lookup"><span data-stu-id="3b772-132">supports a cooperative, non-preemptive threading model in which the threads voluntarily yield execution periodically, or when they are waiting on locks or I/O.</span></span> <span data-ttu-id="3b772-133">CLR では、プリエンプティブなスレッド モデルがサポートされます。</span><span class="sxs-lookup"><span data-stu-id="3b772-133">The CLR supports a preemptive threading model.</span></span> <span data-ttu-id="3b772-134">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 内部で実行されているユーザー コードから、オペレーティング システムのスレッド プリミティブを直接呼び出すことができると、そのユーザー コードは [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] タスク スケジューラに適切に統合されず、システムのスケーラビリティを低下させる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="3b772-134">If user code running inside [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] can directly call the operating system threading primitives, then it does not integrate well into the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] task scheduler and can degrade the scalability of the system.</span></span> <span data-ttu-id="3b772-135">CLR では仮想メモリと物理メモリが区別されませんが、[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] では物理メモリが直接管理され、構成可能な制限内で物理メモリを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="3b772-135">The CLR does not distinguish between virtual and physical memory, but [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] directly manages physical memory and is required to use physical memory within a configurable limit.</span></span>  
  
 <span data-ttu-id="3b772-136">このようにスレッド処理、スケジュール設定、およびメモリ管理のモデルが異なるため、数千の同時実行ユーザー セッションをサポートするまで規模が拡大された RDBMS (リレーショナル データベース管理システム) では統合が課題になります。</span><span class="sxs-lookup"><span data-stu-id="3b772-136">The different models for threading, scheduling, and memory management present an integration challenge for a relational database management system (RDBMS) that scales to support thousands of concurrent user sessions.</span></span> <span data-ttu-id="3b772-137">アーキテクチャでは、スレッド処理、メモリ、および同期プリミティブの API (アプリケーション プログラミング インターフェイス) を直接呼び出すユーザー コードによってシステムのスケーラビリティが損なわれないことを保証する必要があります。</span><span class="sxs-lookup"><span data-stu-id="3b772-137">The architecture should ensure that the scalability of the system is not compromised by user code calling application programming interfaces (APIs) for threading, memory, and synchronization primitives directly.</span></span>  
  
###### <a name="security"></a><span data-ttu-id="3b772-138">セキュリティ</span><span class="sxs-lookup"><span data-stu-id="3b772-138">Security</span></span>  
 <span data-ttu-id="3b772-139">データベースで実行されるユーザー コードがテーブルや列などのデータベース オブジェクトにアクセスする際には、[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] の認証規則と承認規則に従う必要があります。</span><span class="sxs-lookup"><span data-stu-id="3b772-139">User code running in the database must follow [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] authentication and authorization rules when accessing database objects such as tables and columns.</span></span> <span data-ttu-id="3b772-140">また、データベース管理者は、データベースで実行しているユーザー コードからファイルやネットワーク アクセスなどのオペレーティング システム リソースへのアクセスを制御できる必要があります。</span><span class="sxs-lookup"><span data-stu-id="3b772-140">In addition, database administrators should be able to control access to operating system resources, such as files and network access, from user code running in the database.</span></span> <span data-ttu-id="3b772-141">(Transact-SQL などの非マネージド言語とは異なり) このようなリソースにアクセスする API が用意されているマネージド プログラミング言語ではこのことが重要になります。</span><span class="sxs-lookup"><span data-stu-id="3b772-141">This becomes important as managed programming languages (unlike non-managed languages such as Transact-SQL) provide APIs to access such resources.</span></span> <span data-ttu-id="3b772-142">[!INCLUDE[ssDE](../../../includes/ssde-md.md)] プロセス外のコンピューター リソースにアクセスするユーザー コードには、システムによりセキュリティで保護された方法が提供される必要があります。</span><span class="sxs-lookup"><span data-stu-id="3b772-142">The system must provide a secure way for user code to access machine resources outside the [!INCLUDE[ssDE](../../../includes/ssde-md.md)] process.</span></span> <span data-ttu-id="3b772-143">詳細については、「 [CLR 統合のセキュリティ](security/clr-integration-security.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="3b772-143">For more information, see [CLR Integration Security](security/clr-integration-security.md).</span></span>  
  
###### <a name="performance"></a><span data-ttu-id="3b772-144">パフォーマンス</span><span class="sxs-lookup"><span data-stu-id="3b772-144">Performance</span></span>  
 <span data-ttu-id="3b772-145">[!INCLUDE[ssDE](../../../includes/ssde-md.md)]で実行されるマネージド ユーザー コードと、サーバーの外部で実行されるマネージド ユーザー コードのコンピューター処理パフォーマンスは同程度になる必要があります。</span><span class="sxs-lookup"><span data-stu-id="3b772-145">Managed user code running in the [!INCLUDE[ssDE](../../../includes/ssde-md.md)] should have computational performance comparable to the same code run outside the server.</span></span> <span data-ttu-id="3b772-146">マネージド ユーザー コードからのデータ アクセスは、ネイティブ [!INCLUDE[tsql](../../../includes/tsql-md.md)] ほど高速ではありません。</span><span class="sxs-lookup"><span data-stu-id="3b772-146">Database access from managed user code is not as fast as native [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span></span> <span data-ttu-id="3b772-147">詳細については、「 [CLR 統合のパフォーマンス](clr-integration-architecture-performance.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="3b772-147">For more information, see [Performance of CLR Integration](clr-integration-architecture-performance.md).</span></span>  
  
## <a name="clr-services"></a><span data-ttu-id="3b772-148">CLR サービス</span><span class="sxs-lookup"><span data-stu-id="3b772-148">CLR Services</span></span>  
 <span data-ttu-id="3b772-149">CLR により、[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] との CLR 統合のデザイン目標を達成するのに役立つ多数のサービスが提供されます。</span><span class="sxs-lookup"><span data-stu-id="3b772-149">The CLR provides a number of services to help achieve the design goals of CLR integration with [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span>  
  
###### <a name="type-safety-verification"></a><span data-ttu-id="3b772-150">タイプセーフ検証</span><span class="sxs-lookup"><span data-stu-id="3b772-150">Type safety verification</span></span>  
 <span data-ttu-id="3b772-151">タイプ セーフなコードとは、メモリ構造にアクセスする際に適切に定義された方法のみを使用するコードのことです。</span><span class="sxs-lookup"><span data-stu-id="3b772-151">Type-safe code is code that accesses memory structures only in well-defined ways.</span></span> <span data-ttu-id="3b772-152">たとえば、有効なオブジェクト参照を例として考えると、タイプ セーフなコードでは、実際のフィールド メンバーに対応してメモリの固定オフセット位置にアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="3b772-152">For example, given a valid object reference, type-safe code can access memory at fixed offsets corresponding to actual field members.</span></span> <span data-ttu-id="3b772-153">一方、オブジェクトに属するメモリの範囲の内外を問わず、任意のオフセット位置でメモリにアクセスするコードは、タイプ セーフではありません。</span><span class="sxs-lookup"><span data-stu-id="3b772-153">However, if the code accesses memory at arbitrary offsets inside or outside the range of memory that belongs to the object, then it is not type-safe.</span></span> <span data-ttu-id="3b772-154">アセンブリを CLR に読み込むと、JIT (Just-In-Time) コンパイルを使用して MSIL にコンパイルされる前に、ランタイムによって、コードのタイプ セーフティを判断するためにそのコードを調べる検証フェーズが実行されます。</span><span class="sxs-lookup"><span data-stu-id="3b772-154">When assemblies are loaded in the CLR, prior to the MSIL being compiled using just-in-time (JIT) compilation, the runtime performs a verification phase that examines code to determine its type-safety.</span></span> <span data-ttu-id="3b772-155">この検証に正常に合格するコードを、検証可能なタイプ セーフなコードと呼びます。</span><span class="sxs-lookup"><span data-stu-id="3b772-155">Code that successfully passes this verification is called verifiably type-safe code.</span></span>  
  
###### <a name="application-domains"></a><span data-ttu-id="3b772-156">アプリケーション ドメイン</span><span class="sxs-lookup"><span data-stu-id="3b772-156">Application domains</span></span>  
 <span data-ttu-id="3b772-157">CLR では、マネージド コード アセンブリを読み込み、実行できるホスト プロセス内の実行領域として、アプリケーション ドメインの概念がサポートされます。</span><span class="sxs-lookup"><span data-stu-id="3b772-157">The CLR supports the notion of application domains as execution zones within a host process where managed code assemblies can be loaded and executed.</span></span> <span data-ttu-id="3b772-158">アプリケーション ドメインの境界でアセンブリどうしが分離されます。</span><span class="sxs-lookup"><span data-stu-id="3b772-158">The application domain boundary provides isolation between assemblies.</span></span> <span data-ttu-id="3b772-159">アセンブリは、静的変数やデータ メンバーの可視性、およびコードを動的に呼び出す機能に関して分離されます。</span><span class="sxs-lookup"><span data-stu-id="3b772-159">The assemblies are isolated in terms of visibility of static variables and data members and the ability to call code dynamically.</span></span> <span data-ttu-id="3b772-160">また、アプリケーション ドメインはコードのロードとアンロード用のメカニズムでもあります。</span><span class="sxs-lookup"><span data-stu-id="3b772-160">Application domains are also the mechanism for loading and unloading code.</span></span> <span data-ttu-id="3b772-161">アプリケーション ドメインをアンロードしないと、コードをメモリからアンロードできません。</span><span class="sxs-lookup"><span data-stu-id="3b772-161">Code can be unloaded from memory only by unloading the application domain.</span></span> <span data-ttu-id="3b772-162">詳細については、「[アプリケーションドメインと CLR 統合のセキュリティ](../../database-engine/dev-guide/application-domains-and-clr-integration-security.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="3b772-162">For more information, see [Application Domains and CLR Integration Security](../../database-engine/dev-guide/application-domains-and-clr-integration-security.md).</span></span>  
  
###### <a name="code-access-security-cas"></a><span data-ttu-id="3b772-163">コード アクセス セキュリティ (CAS)</span><span class="sxs-lookup"><span data-stu-id="3b772-163">Code Access Security (CAS)</span></span>  
 <span data-ttu-id="3b772-164">CLR セキュリティ システムには、マネージド コードに権限を割り当てて、そのコードで実行できる操作の種類を制御する方法が用意されています。</span><span class="sxs-lookup"><span data-stu-id="3b772-164">The CLR security system provides a way to control what kinds of operations managed code can perform by assigning permissions to code.</span></span> <span data-ttu-id="3b772-165">コード アクセス権限は、コード ID (アセンブリの署名やコードの作成元など) に基づいて割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="3b772-165">Code access permissions are assigned based on code identity (for example, the signature of the assembly or the origin of the code).</span></span>  
  
 <span data-ttu-id="3b772-166">CLR では、コンピューター管理者が設定できるコンピューター全体のポリシーが規定されます。</span><span class="sxs-lookup"><span data-stu-id="3b772-166">The CLR provides for a computer-wide policy that can be set by the computer administrator.</span></span> <span data-ttu-id="3b772-167">このポリシーでは、コンピューターで実行される任意のマネージド コードに許可される権限が定義されます。</span><span class="sxs-lookup"><span data-stu-id="3b772-167">This policy defines the permission grants for any managed code running on the machine.</span></span> <span data-ttu-id="3b772-168">さらに、マネージド コードに新たな制限を指定するために [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] などのホストで使用できるホストレベルのセキュリティ ポリシーがあります。</span><span class="sxs-lookup"><span data-stu-id="3b772-168">In addition, there is a host-level security policy that can be used by hosts such as [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] to specify additional restrictions on managed code.</span></span>  
  
 <span data-ttu-id="3b772-169">.NET Framework のマネージド API により、コード アクセス権限で保護されているリソースでの操作が公開される場合、そのリソースへのアクセスが行われる前に、API がそのアクセス権限を要求することになります。</span><span class="sxs-lookup"><span data-stu-id="3b772-169">If a managed API in the .NET Framework exposes operations on resources that are protected by a code access permission, the API will demand that permission before accessing the resource.</span></span> <span data-ttu-id="3b772-170">この要求により、CLR セキュリティ システムが呼び出し履歴内のすべての単位のコード (アセンブリ) を包括的にチェックします。</span><span class="sxs-lookup"><span data-stu-id="3b772-170">This demand causes the CLR security system to trigger a comprehensive check of every unit of code (assembly) in the call stack.</span></span> <span data-ttu-id="3b772-171">この処理は、リソースにアクセスする権限が呼び出しチェーン全体に許可されている場合にのみ行われます。</span><span class="sxs-lookup"><span data-stu-id="3b772-171">Only if the entire call chain has permission will access to the resource be granted.</span></span>  
  
 <span data-ttu-id="3b772-172">Reflection.Emit API を使用してマネージド コードを動的に生成する機能は、[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] の CLR ホスト環境の内部ではサポートされないことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="3b772-172">Note that the ability to generate managed code dynamically, using the Reflection.Emit API, is not supported inside the CLR-hosted environment in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="3b772-173">このようなコードには実行するための CAS 権限がないので、コードは実行時に失敗します。</span><span class="sxs-lookup"><span data-stu-id="3b772-173">Such code would not have the CAS permissions to run and would therefore fail at run time.</span></span> <span data-ttu-id="3b772-174">詳細については、「 [CLR 統合コードアクセスセキュリティ](security/clr-integration-code-access-security.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="3b772-174">For more information, see [CLR Integration Code Access Security](security/clr-integration-code-access-security.md).</span></span>  
  
###### <a name="host-protection-attributes-hpas"></a><span data-ttu-id="3b772-175">HPA (ホスト保護属性)</span><span class="sxs-lookup"><span data-stu-id="3b772-175">Host Protection Attributes (HPAs)</span></span>  
 <span data-ttu-id="3b772-176">CLR には、.NET Framework の一部であるマネージド API に、特定の属性で注釈を付けるメカニズムが用意されています。このような属性は CLR のホストにとって意味のある属性です。</span><span class="sxs-lookup"><span data-stu-id="3b772-176">The CLR provides a mechanism to annotate managed APIs that are part of the .NET Framework with certain attributes that may be of interest to a host of the CLR.</span></span> <span data-ttu-id="3b772-177">次に、このような属性の例を示します。</span><span class="sxs-lookup"><span data-stu-id="3b772-177">Examples of such attributes include:</span></span>  
  
-   <span data-ttu-id="3b772-178">SharedState。共有状態 (静的なクラス フィールドなど) を作成または管理する機能が API で公開されるかどうかを示します。</span><span class="sxs-lookup"><span data-stu-id="3b772-178">SharedState, which indicates whether the API exposes the ability to create or manage shared state (for example, static class fields).</span></span>  
  
-   <span data-ttu-id="3b772-179">Synchronization。スレッド間で同期を実行する機能が API で公開されるかどうかを示します。</span><span class="sxs-lookup"><span data-stu-id="3b772-179">Synchronization, which indicates whether the API exposes the ability to perform synchronization between threads.</span></span>  
  
-   <span data-ttu-id="3b772-180">ExternalProcessMgmt。ホスト プロセスを制御する方法が API で公開されるかどうかを示します。</span><span class="sxs-lookup"><span data-stu-id="3b772-180">ExternalProcessMgmt, which indicates whether the API exposes a way to control the host process.</span></span>  
  
 <span data-ttu-id="3b772-181">これらの属性を例として考えると、ホストされている環境で禁止される必要がある SharedState 属性などの HPA の一覧をホストで指定できます。</span><span class="sxs-lookup"><span data-stu-id="3b772-181">Given these attributes, the host can specify a list of HPAs, such as the SharedState attribute, that should be disallowed in the hosted environment.</span></span> <span data-ttu-id="3b772-182">この場合、CLR では禁止一覧の HPA で注釈が付けられている API がユーザー コードから呼び出されることを拒否します。</span><span class="sxs-lookup"><span data-stu-id="3b772-182">In this case, the CLR denies attempts by user code to call APIs that are annotated by the HPAs in the prohibited list.</span></span> <span data-ttu-id="3b772-183">詳細については、「[ホスト保護属性と CLR 統合プログラミング](../clr-integration-security-host-protection-attributes/host-protection-attributes-and-clr-integration-programming.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="3b772-183">For more information, see [Host Protection Attributes and CLR Integration Programming](../clr-integration-security-host-protection-attributes/host-protection-attributes-and-clr-integration-programming.md).</span></span>  
  
## <a name="how-sql-server-and-the-clr-work-together"></a><span data-ttu-id="3b772-184">SQL Server と CLR の連携方法</span><span class="sxs-lookup"><span data-stu-id="3b772-184">How SQL Server and the CLR Work Together</span></span>  
 <span data-ttu-id="3b772-185">ここでは、[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] と CLR のスレッド処理、スケジュール設定、同期、およびメモリ管理のモデルが [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] に統合されている様式について説明します。</span><span class="sxs-lookup"><span data-stu-id="3b772-185">This section discusses how [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] integrates the threading, scheduling, synchronization, and memory management models of [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] and the CLR.</span></span> <span data-ttu-id="3b772-186">特に、スケーラビリティ、信頼性、およびセキュリティの目標に照らし合わせて、この統合について解説します。</span><span class="sxs-lookup"><span data-stu-id="3b772-186">In particular, this section examines the integration in light of scalability, reliability, and security goals.</span></span> <span data-ttu-id="3b772-187">基本的には、[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] は、CLR が [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] の内部でホストされているときに CLR のオペレーティング システムとして機能します。</span><span class="sxs-lookup"><span data-stu-id="3b772-187">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] essentially acts as the operating system for the CLR when it is hosted inside [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="3b772-188">CLR は、スレッド処理、スケジュール設定、同期、およびメモリ管理用に [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] によって実装される低レベルのルーチンを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="3b772-188">The CLR calls low-level routines implemented by [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] for threading, scheduling, synchronization, and memory management.</span></span> <span data-ttu-id="3b772-189">このようなルーチンは、[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] エンジンの残りの部分で使用されるプリミティブと同じです。</span><span class="sxs-lookup"><span data-stu-id="3b772-189">These are the same primitives that the rest of the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] engine uses.</span></span> <span data-ttu-id="3b772-190">このアプローチを使用すると、スケーラビリティ、信頼性、およびセキュリティに関するいくつかの利点が得られます。</span><span class="sxs-lookup"><span data-stu-id="3b772-190">This approach provides several scalability, reliability, and security benefits.</span></span>  
  
###### <a name="scalability-common-threading-scheduling-and-synchronization"></a><span data-ttu-id="3b772-191">スケーラビリティ : 一般的なスレッド処理、スケジュール設定、および同期</span><span class="sxs-lookup"><span data-stu-id="3b772-191">Scalability: Common threading, scheduling, and synchronization</span></span>  
 <span data-ttu-id="3b772-192">CLR は、ユーザー コードを実行するため、および CLR 自体の内部で使用するために、スレッドを作成する [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] API を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="3b772-192">CLR calls [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] APIs for creating threads, both for running user code and for its own internal use.</span></span> <span data-ttu-id="3b772-193">複数のスレッド間で同期するために、CLR は [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 同期オブジェクトを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="3b772-193">In order to synchronize between multiple threads, the CLR calls [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] synchronization objects.</span></span> <span data-ttu-id="3b772-194">これにより、スレッドが同期オブジェクトを待機しているときに、[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] スケジューラは他のタスクのスケジュールを設定できます。</span><span class="sxs-lookup"><span data-stu-id="3b772-194">This allows the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] scheduler to schedule other tasks when a thread is waiting on a synchronization object.</span></span> <span data-ttu-id="3b772-195">たとえば、CLR からガベージ コレクションが開始されると、CLR のすべてのスレッドがガベージ コレクションの終了を待機します。</span><span class="sxs-lookup"><span data-stu-id="3b772-195">For example, when the CLR initiates garbage collection, all of its threads wait for garbage collection to finish.</span></span> <span data-ttu-id="3b772-196">CLR スレッドと CLR スレッドが待機している同期オブジェクトは [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] スケジューラに認識されるので、[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] では、CLR に関連しない他のデータベース タスクを実行しているスレッドにスケジュールを設定できます。</span><span class="sxs-lookup"><span data-stu-id="3b772-196">Because the CLR threads and the synchronization objects they are waiting on are known to the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] scheduler, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] can schedule threads that are running other database tasks not involving the CLR.</span></span> <span data-ttu-id="3b772-197">また、これにより、[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] が CLR 同期オブジェクトによって取得されるロックに関連するデッドロックを検出し、デッドロックを除去する従来の技法を使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="3b772-197">This also enables [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] to detect deadlocks that involve locks taken by CLR synchronization objects and employ traditional techniques for deadlock removal.</span></span>  
  
 <span data-ttu-id="3b772-198">マネージド コードは、[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] でプリエンプティブに実行されます。</span><span class="sxs-lookup"><span data-stu-id="3b772-198">Managed code runs preemptively in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="3b772-199">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] スケジューラには、非常に長い間実行が明け渡されていないスレッドを検出して停止する機能が備わっています。</span><span class="sxs-lookup"><span data-stu-id="3b772-199">The [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] scheduler has the ability to detect and stop threads that have not yielded for a significant amount of time.</span></span> <span data-ttu-id="3b772-200">CLR スレッドを [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] スレッドにフックする機能は、[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] スケジューラが CLR の "ランナウェイ" スレッドを識別し、それらのスレッドの優先度を管理できることを意味します。</span><span class="sxs-lookup"><span data-stu-id="3b772-200">The ability to hook CLR threads to [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] threads implies that the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] scheduler can identify "runaway" threads in the CLR and manage their priority.</span></span> <span data-ttu-id="3b772-201">このようなランナウェイ スレッドは中断され、キューに戻されます。</span><span class="sxs-lookup"><span data-stu-id="3b772-201">Such runaway threads are suspended and put back in the queue.</span></span> <span data-ttu-id="3b772-202">繰り返しランナウェイ スレッドとして識別されたスレッドは、実行中の他のワーカーを実行できるように、一定期間実行が許可されません。</span><span class="sxs-lookup"><span data-stu-id="3b772-202">Threads that are repeatedly identified as runaway threads are not allowed to run for a given period of time so that other executing workers can run.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="3b772-203">データにアクセスしたり、ガベージ コレクションを起動するのに十分なメモリを割り当てる実行時間の長いマネージド コードは、自動的に処理が明け渡されます。</span><span class="sxs-lookup"><span data-stu-id="3b772-203">Long-running managed code that accesses data or allocates enough memory to trigger garbage collection will yield automatically.</span></span> <span data-ttu-id="3b772-204">データにアクセスしない、またはガベージ コレクションを起動するのに十分なマネージド メモリを割り当てない、実行時間の長いマネージド コードは、.NET Framework の System.Thread.Sleep() 関数を呼び出して、明示的に実行を明け渡す必要があります。</span><span class="sxs-lookup"><span data-stu-id="3b772-204">Long-running managed code that does not access data or allocate enough managed memory to trigger garbage collection should explicitly yield by calling the System.Thread.Sleep() function of the .NET Framework.</span></span>  
  
###### <a name="scalability-common-memory-management"></a><span data-ttu-id="3b772-205">スケーラビリティ : 一般的なメモリ管理</span><span class="sxs-lookup"><span data-stu-id="3b772-205">Scalability: Common memory management</span></span>  
 <span data-ttu-id="3b772-206">CLR は、CLR のメモリの割り当ておよび割り当て解除を行うために [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] プリミティブを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="3b772-206">The CLR calls [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] primitives for allocating and de-allocating its memory.</span></span> <span data-ttu-id="3b772-207">CLR で使用されるメモリはシステムの総メモリ使用量の一部を占有するので、[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] はメモリの使用量を構成済みのメモリ制限内に抑えることができ、CLR と [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] が競い合ってメモリを確保することはありません。</span><span class="sxs-lookup"><span data-stu-id="3b772-207">Because the memory used by the CLR is accounted for in the total memory usage of the system, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] can stay within its configured memory limits and ensure the CLR and [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] are not competing with each other for memory.</span></span> <span data-ttu-id="3b772-208">また、[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] では、システムのメモリが制約されているときに CLR からのメモリ要求を拒否し、他のタスクでメモリが必要なときにメモリ使用量を抑えるように CLR に要求することもできます。</span><span class="sxs-lookup"><span data-stu-id="3b772-208">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] can also reject CLR memory requests when system memory is constrained, and ask CLR to reduce its memory use when other tasks need memory.</span></span>  
  
###### <a name="reliability-application-domains-and-unrecoverable-exceptions"></a><span data-ttu-id="3b772-209">信頼性 : アプリケーション ドメインと回復できない例外</span><span class="sxs-lookup"><span data-stu-id="3b772-209">Reliability: Application domains and unrecoverable exceptions</span></span>  
 <span data-ttu-id="3b772-210">.NET Framework API のマネージド コードで、メモリ不足やスタック オーバーフローなどの重大な例外が発生した場合、必ずそのようなエラーから回復し、API の実装に対して一貫性のある正しいセマンティクスを保証できるとは限りません。</span><span class="sxs-lookup"><span data-stu-id="3b772-210">When managed code in the .NET Framework APIs encounters critical exceptions, such as out-of-memory or stack overflow, it is not always possible to recover from such failures and ensure consistent and correct semantics for their implementation.</span></span> <span data-ttu-id="3b772-211">これらの API により、このようなエラーへの応答でスレッドを中断する例外が発生します。</span><span class="sxs-lookup"><span data-stu-id="3b772-211">These APIs raise a thread abort exception in response to these failures.</span></span>  
  
 <span data-ttu-id="3b772-212">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] でホストされているときは、CLR がスレッドの中断が発生したアプリケーション ドメインのすべての共有状態を検出することで、このようなスレッドの中断が処理されます。</span><span class="sxs-lookup"><span data-stu-id="3b772-212">When hosted in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)], such thread aborts are handled as follows: the CLR detects any shared state in the application domain in which the thread abort occurs.</span></span> <span data-ttu-id="3b772-213">CLR では、同期オブジェクトが存在するかどうかを確認することで、この処理を行います。</span><span class="sxs-lookup"><span data-stu-id="3b772-213">The CLR does this by checking for the presence of synchronization objects.</span></span> <span data-ttu-id="3b772-214">アプリケーション ドメインに共有状態が存在する場合は、アプリケーション ドメイン自体がアンロードされます。</span><span class="sxs-lookup"><span data-stu-id="3b772-214">If there is shared state in the application domain, then the application domain itself is unloaded.</span></span> <span data-ttu-id="3b772-215">アプリケーション ドメインをアンロードすると、そのアプリケーション ドメインで現在実行されているデータベース トランザクションが停止します。</span><span class="sxs-lookup"><span data-stu-id="3b772-215">The unloading of the application domain stops database transactions that are currently running in that application domain.</span></span> <span data-ttu-id="3b772-216">共有状態が存在すると、例外が発生したユーザー セッション以外のユーザー セッションに、このような重大な例外の影響が拡大する可能性があるので、[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] と CLR では、共有状態が存在する可能性を減少させる手順が実行されます。</span><span class="sxs-lookup"><span data-stu-id="3b772-216">Because the presence of shared state can widen the impact of such critical exceptions to user sessions other than the one triggering the exception, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] and the CLR have taken steps to reduce the likelihood of shared state.</span></span> <span data-ttu-id="3b772-217">詳細については、.NET Framework のドキュメントを参照してください。</span><span class="sxs-lookup"><span data-stu-id="3b772-217">For more information, see the .NET Framework documentation.</span></span>  
  
###### <a name="security-permission-sets"></a><span data-ttu-id="3b772-218">セキュリティ : 権限セット</span><span class="sxs-lookup"><span data-stu-id="3b772-218">Security: Permission sets</span></span>  
 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] <span data-ttu-id="3b772-219">では、データベースに配置されるコードの信頼性とセキュリティに関する要件をユーザーが指定できます。</span><span class="sxs-lookup"><span data-stu-id="3b772-219">allows users to specify the reliability and security requirements for code deployed into the database.</span></span> <span data-ttu-id="3b772-220">データベースにアセンブリをアップロードするとき、アセンブリの作成者は SAFE、EXTERNAL_ACCESS、および UNSAFE の 3 つの権限セットのうちのいずれかをアセンブリに指定できます。</span><span class="sxs-lookup"><span data-stu-id="3b772-220">When assemblies are uploaded into the database, the author of the assembly can specify one of three permission sets for that assembly: SAFE, EXTERNAL_ACCESS and UNSAFE.</span></span>  
  
|||||  
|-|-|-|-|  
|<span data-ttu-id="3b772-221">権限セット</span><span class="sxs-lookup"><span data-stu-id="3b772-221">Permission set</span></span>|<span data-ttu-id="3b772-222">SAFE</span><span class="sxs-lookup"><span data-stu-id="3b772-222">SAFE</span></span>|<span data-ttu-id="3b772-223">EXTERNAL_ACCESS</span><span class="sxs-lookup"><span data-stu-id="3b772-223">EXTERNAL_ACCESS</span></span>|<span data-ttu-id="3b772-224">UNSAFE</span><span class="sxs-lookup"><span data-stu-id="3b772-224">UNSAFE</span></span>|  
|<span data-ttu-id="3b772-225">コード アクセス セキュリティ</span><span class="sxs-lookup"><span data-stu-id="3b772-225">Code Access Security</span></span>|<span data-ttu-id="3b772-226">実行のみ</span><span class="sxs-lookup"><span data-stu-id="3b772-226">Execute only</span></span>|<span data-ttu-id="3b772-227">実行および外部リソースへのアクセス</span><span class="sxs-lookup"><span data-stu-id="3b772-227">Execute + access to external resources</span></span>|<span data-ttu-id="3b772-228">無制限</span><span class="sxs-lookup"><span data-stu-id="3b772-228">Unrestricted</span></span>|  
|<span data-ttu-id="3b772-229">プログラミング モデルの制限事項</span><span class="sxs-lookup"><span data-stu-id="3b772-229">Programming model restrictions</span></span>|<span data-ttu-id="3b772-230">はい</span><span class="sxs-lookup"><span data-stu-id="3b772-230">Yes</span></span>|<span data-ttu-id="3b772-231">はい</span><span class="sxs-lookup"><span data-stu-id="3b772-231">Yes</span></span>|<span data-ttu-id="3b772-232">制限事項なし</span><span class="sxs-lookup"><span data-stu-id="3b772-232">No restrictions</span></span>|  
|<span data-ttu-id="3b772-233">検証可能性の要件</span><span class="sxs-lookup"><span data-stu-id="3b772-233">Verifiability requirement</span></span>|<span data-ttu-id="3b772-234">はい</span><span class="sxs-lookup"><span data-stu-id="3b772-234">Yes</span></span>|<span data-ttu-id="3b772-235">はい</span><span class="sxs-lookup"><span data-stu-id="3b772-235">Yes</span></span>|<span data-ttu-id="3b772-236">いいえ</span><span class="sxs-lookup"><span data-stu-id="3b772-236">No</span></span>|  
|<span data-ttu-id="3b772-237">ネイティブ コードを呼び出す機能</span><span class="sxs-lookup"><span data-stu-id="3b772-237">Ability to call native code</span></span>|<span data-ttu-id="3b772-238">いいえ</span><span class="sxs-lookup"><span data-stu-id="3b772-238">No</span></span>|<span data-ttu-id="3b772-239">いいえ</span><span class="sxs-lookup"><span data-stu-id="3b772-239">No</span></span>|<span data-ttu-id="3b772-240">はい</span><span class="sxs-lookup"><span data-stu-id="3b772-240">Yes</span></span>|  
  
 <span data-ttu-id="3b772-241">SAFE は、許可されているプログラミング モデルの中でも多くの制限事項が関連付けられており、最も信頼性が高く、セキュリティで保護されたモードです。</span><span class="sxs-lookup"><span data-stu-id="3b772-241">SAFE is the most reliable and secure mode with associated restrictions in terms of the allowed programming model.</span></span> <span data-ttu-id="3b772-242">SAFE アセンブリには、実行、計算の実行、およびローカル データベースへのアクセスを行うには十分な権限が許可されます。</span><span class="sxs-lookup"><span data-stu-id="3b772-242">SAFE assemblies are given enough permission to run, perform computations, and have access to the local database.</span></span> <span data-ttu-id="3b772-243">SAFE アセンブリは検証可能なタイプ セーフである必要があり、アンマネージ コードを呼び出すことはできません。</span><span class="sxs-lookup"><span data-stu-id="3b772-243">SAFE assemblies need to be verifiably type safe and are not allowed to call unmanaged code.</span></span>  
  
 <span data-ttu-id="3b772-244">UNSAFE は、データベース管理者のみが作成できる信頼性の高いコードに指定します。</span><span class="sxs-lookup"><span data-stu-id="3b772-244">UNSAFE is for highly trusted code that can only be created by database administrators.</span></span> <span data-ttu-id="3b772-245">この信頼性の高いコードにはコード アクセス セキュリティに関する制限がなく、アンマネージ (ネイティブ) コードを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="3b772-245">This trusted code has no code access security restrictions, and it can call unmanaged (native) code.</span></span>  
  
 <span data-ttu-id="3b772-246">EXTERNAL_ACCESS には、両者の中間に位置するセキュリティ オプションが提供されます。このオプションにより、SAFE の信頼性保証を備えたまま、コードからデータベース外部のリソースにアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="3b772-246">EXTERNAL_ACCESS provides an intermediate security option, allowing code to access resources external to the database but still having the reliability guarantees of SAFE.</span></span>  
  
 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] <span data-ttu-id="3b772-247">では、ホストレベルの CAS ポリシー層を使用して、[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] カタログに格納されている権限セットに基づいて上記の 3 つの権限セットのうちのいずれかを許可するホスト ポリシーを構成します。</span><span class="sxs-lookup"><span data-stu-id="3b772-247">uses the host-level CAS policy layer to set up a host policy that grants one of the three sets of permissions based on the permission set stored in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] catalogs.</span></span> <span data-ttu-id="3b772-248">データベース内部で実行するマネージド コードには、これらのコード アクセス権限セットのうちのいずれかが必ず許可されます。</span><span class="sxs-lookup"><span data-stu-id="3b772-248">Managed code running inside the database always gets one of these code access permission sets.</span></span>  
  
### <a name="programming-model-restrictions"></a><span data-ttu-id="3b772-249">プログラミング モデルの制限</span><span class="sxs-lookup"><span data-stu-id="3b772-249">Programming Model Restrictions</span></span>  
 <span data-ttu-id="3b772-250">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] のマネージド コードのプログラミング モデルでは、通常、複数の呼び出し間で保持される状態の使用や複数のユーザー セッション間での状態の共有を必要としない関数、プロシージャ、および型の記述が必要になります。</span><span class="sxs-lookup"><span data-stu-id="3b772-250">The programming model for managed code in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] involves writing functions, procedures, and types which typically do not require the use of state held across multiple invocations or the sharing of state across multiple user sessions.</span></span> <span data-ttu-id="3b772-251">さらに、既に説明したように、共有状態が存在すると、アプリケーションのスケーラビリティや信頼性に影響を与える重大な例外が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="3b772-251">Further, as described earlier, the presence of shared state can cause critical exceptions that impact the scalability and the reliability of the application.</span></span>  
  
 <span data-ttu-id="3b772-252">このような考慮事項を考えると、[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] で使用するクラスの静的変数や静的なデータ メンバーを使用することはお勧めしません。</span><span class="sxs-lookup"><span data-stu-id="3b772-252">Given these considerations, we discourage the use of static variables and static data members of classes used in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="3b772-253">SAFE アセンブリと EXTERNAL_ACCESS アセンブリの場合、CREATE ASSEMBLY を使用するときに [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] でアセンブリのメタデータが調べられ、静的なデータ メンバーや変数の使用が検出された場合はこのようなアセンブリを作成できません。</span><span class="sxs-lookup"><span data-stu-id="3b772-253">For SAFE and EXTERNAL_ACCESS assemblies, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] examines the metadata of the assembly at CREATE ASSEMBLY time and fails the creation of such assemblies if it finds the use of static data members and variables.</span></span>  
  
 <span data-ttu-id="3b772-254">また、[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] では、`SharedState`、`Synchronization`、および `ExternalProcessMgmt` などのホスト保護属性で注釈が付けられている .NET Framework API の呼び出しが禁止されます。</span><span class="sxs-lookup"><span data-stu-id="3b772-254">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] also disallows calls to .NET Framework APIs that are annotated with the `SharedState`, `Synchronization` and `ExternalProcessMgmt` host protection attributes.</span></span> <span data-ttu-id="3b772-255">これにより、SAFE アセンブリと EXTERNAL_ACCESS アセンブリで、状態の共有、同期の実行、および [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] プロセスの整合性に影響を与える可能性のあるすべての API が呼び出されなくなります。</span><span class="sxs-lookup"><span data-stu-id="3b772-255">This prevents SAFE and EXTERNAL_ACCESS assemblies from calling any APIs that enable sharing state, performing synchronization, and affecting the integrity of the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] process.</span></span> <span data-ttu-id="3b772-256">詳細については、「 [CLR 統合プログラミングモデルの制限](database-objects/clr-integration-programming-model-restrictions.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="3b772-256">For more information, see [CLR Integration Programming Model Restrictions](database-objects/clr-integration-programming-model-restrictions.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="3b772-257">参照</span><span class="sxs-lookup"><span data-stu-id="3b772-257">See Also</span></span>  
 <span data-ttu-id="3b772-258">[CLR 統合のセキュリティ](security/clr-integration-security.md) </span><span class="sxs-lookup"><span data-stu-id="3b772-258">[CLR Integration Security](security/clr-integration-security.md) </span></span>  
 [<span data-ttu-id="3b772-259">CLR 統合のパフォーマンス</span><span class="sxs-lookup"><span data-stu-id="3b772-259">Performance of CLR Integration</span></span>](clr-integration-architecture-performance.md)  
  
  
