---
title: CLR 統合のパフォーマンス |Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: clr
ms.topic: reference
helpviewer_keywords:
- common language runtime [SQL Server], performance
- common language runtime [SQL Server], compilation process
- performance [CLR integration]
ms.assetid: 7ce2dfc0-4b1f-4dcb-a979-2c4f95b4cb15
author: rothja
ms.author: jroth
ms.openlocfilehash: 33e45039ed98ea3df607df1714b3c6108ec17c35
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/04/2020
ms.locfileid: "87720019"
---
# <a name="performance-of-clr-integration"></a><span data-ttu-id="ac7a2-102">CLR 統合のパフォーマンス</span><span class="sxs-lookup"><span data-stu-id="ac7a2-102">Performance of CLR Integration</span></span>
  <span data-ttu-id="ac7a2-103">このトピックでは、 [!INCLUDE[msCoName](../../../includes/msconame-md.md)] [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] [!INCLUDE[msCoName](../../../includes/msconame-md.md)] .NET Framework 共通言語ランタイム (CLR) との統合のパフォーマンスを向上させる、いくつかの設計上の選択肢について説明します。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-103">This topic discusses some of the design choices that enhance the performance of [!INCLUDE[msCoName](../../../includes/msconame-md.md)] [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] integration with the [!INCLUDE[msCoName](../../../includes/msconame-md.md)] .NET Framework common language runtime (CLR).</span></span>  
  
## <a name="the-compilation-process"></a><span data-ttu-id="ac7a2-104">コンパイル処理</span><span class="sxs-lookup"><span data-stu-id="ac7a2-104">The Compilation Process</span></span>  
 <span data-ttu-id="ac7a2-105">SQL 式のコンパイル時に、マネージド ルーチンへの参照が検出されると、MSIL ([!INCLUDE[msCoName](../../../includes/msconame-md.md)] Intermediate Language) スタブが生成されます。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-105">During compilation of SQL expressions, when a reference to a managed routine is encountered, a [!INCLUDE[msCoName](../../../includes/msconame-md.md)] intermediate language (MSIL) stub is generated.</span></span> <span data-ttu-id="ac7a2-106">このスタブには、ルーチン パラメーターを [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] から CLR にマーシャリングして関数を呼び出し、結果を返すコードが含まれています。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-106">This stub includes code to marshal the routine parameters from [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] to the CLR, invoke the function, and return the result.</span></span> <span data-ttu-id="ac7a2-107">この "グルー" (接着剤) コードは、パラメーターの型とパラメーターの方向 (入力、出力、または参照) に基づいています。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-107">This "glue" code is based on the type of parameter and on parameter direction (in, out, or reference).</span></span>  
  
 <span data-ttu-id="ac7a2-108">グルー コードを使用することで、型固有の最適化を行い、NULL 値の許容、制約ファセット、値渡し、標準の例外処理などの [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] セマンティクスを効率的に適用できます。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-108">The glue code enables type-specific optimizations and ensures efficient enforcement of [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] semantics, such as nullability, constraining facets, by-value, and standard exception handling.</span></span> <span data-ttu-id="ac7a2-109">引数に真数型を使用するコードを生成することで、複数の呼び出しにまたがる型の強制またはラッパー オブジェクト作成によるコストを回避 ("ボックス化") できます。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-109">By generating code for the exact types of the arguments, you avoid type coercion or wrapper object creation costs (called "boxing") across the invocation boundary.</span></span>  
  
 <span data-ttu-id="ac7a2-110">生成されたスタブは、CLR の JIT (just-in-time) コンパイル サービスによって、ネイティブ コードへのコンパイル、および [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] を実行している特定のハードウェア アーキテクチャに合わせた最適化が行われます。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-110">The generated stub is then compiled to native code and optimized for the particular hardware architecture on which [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] executes, using the JIT (just-in-time) compilation services of the CLR.</span></span> <span data-ttu-id="ac7a2-111">JIT サービスはメソッド レベルで呼び出され、[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] と CLR 両方を実行するための単一のコンパイル単位を [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] ホスティング環境で作成できます。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-111">The JIT services are invoked at the method level and allow the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] hosting environment to create a single compilation unit that spans both [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] and CLR execution.</span></span> <span data-ttu-id="ac7a2-112">スタブをコンパイルすると、コンパイルされた関数のポインターが関数の実行時の実装になります。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-112">Once the stub is compiled, the resulting function pointer becomes the run-time implementation of the function.</span></span> <span data-ttu-id="ac7a2-113">このコード生成方式によって、実行時にリフレクションやメタデータのアクセスのために追加の呼び出しを行うコストを回避することができます。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-113">This code generation approach ensures that there are no additional invocation costs related to reflection or metadata access at run time.</span></span>  
  
### <a name="fast-transitions-between-sql-server-and-clr"></a><span data-ttu-id="ac7a2-114">SQL Server と CLR の高速切り替え</span><span class="sxs-lookup"><span data-stu-id="ac7a2-114">Fast Transitions Between SQL Server and CLR</span></span>  
 <span data-ttu-id="ac7a2-115">コンパイル処理の結果、実行時にネイティブ コードから呼び出すことのできる関数ポインターが生成されます。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-115">The compilation process yields a function pointer that can be called at run time from native code.</span></span> <span data-ttu-id="ac7a2-116">ユーザー定義スカラー値関数の場合、関数が行ごとに呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-116">In the case of scalar-valued user-defined functions, this function invocation happens on a per-row basis.</span></span> <span data-ttu-id="ac7a2-117">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] と CLR の切り替えコストを最小限にするために、マネージド呼び出しを行うステートメントには対象になるアプリケーション ドメインを識別する起動処理があります。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-117">To minimize the cost of transitioning between [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] and the CLR, statements that contain any managed invocation have a startup step to identify the target application domain.</span></span> <span data-ttu-id="ac7a2-118">この識別処理により、行ごとの切り替えコストを抑えます。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-118">This identification step reduces the cost of transitioning for each row.</span></span>  
  
## <a name="performance-considerations"></a><span data-ttu-id="ac7a2-119">パフォーマンスに関する考慮事項</span><span class="sxs-lookup"><span data-stu-id="ac7a2-119">Performance Considerations</span></span>  
 <span data-ttu-id="ac7a2-120">次に、[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] の CLR 統合固有のパフォーマンスに関する考慮事項を要約します。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-120">The following summarizes performance considerations specific to CLR integration in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="ac7a2-121">詳細については、MSDN Web サイトの「[SQL Server 2005 での CLR 統合の使用](https://go.microsoft.com/fwlink/?LinkId=50332)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-121">More detailed information can be found in "[Using CLR Integration in SQL Server 2005](https://go.microsoft.com/fwlink/?LinkId=50332)" on the MSDN Web site.</span></span> <span data-ttu-id="ac7a2-122">マネージコードのパフォーマンスに関する一般情報については、MSDN Web サイトの「[.Net アプリケーションのパフォーマンスとスケーラビリティの向上](https://go.microsoft.com/fwlink/?LinkId=50333)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-122">General information regarding managed code performance can be found in "[Improving .NET Application Performance and Scalability](https://go.microsoft.com/fwlink/?LinkId=50333)" on the MSDN Web site.</span></span>  
  
### <a name="user-defined-functions"></a><span data-ttu-id="ac7a2-123">ユーザー定義関数</span><span class="sxs-lookup"><span data-stu-id="ac7a2-123">User-Defined Functions</span></span>  
 <span data-ttu-id="ac7a2-124">CLR 関数は、[!INCLUDE[tsql](../../../includes/tsql-md.md)] のユーザー定義関数に比べて呼び出し手順が速いという利点があります。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-124">CLR functions benefit from a quicker invocation path than that of [!INCLUDE[tsql](../../../includes/tsql-md.md)] user-defined functions.</span></span> <span data-ttu-id="ac7a2-125">また、マネージド コードはプロシージャ コード、計算、および文字列操作のパフォーマンスが [!INCLUDE[tsql](../../../includes/tsql-md.md)] に比べて決定的に優れています。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-125">Additionally, managed code has a decisive performance advantage over [!INCLUDE[tsql](../../../includes/tsql-md.md)] in terms of procedural code, computation, and string manipulation.</span></span> <span data-ttu-id="ac7a2-126">計算中心の CLR 関数およびデータ アクセスを行わない CLR 関数は、マネージド コードで記述する方が適切です。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-126">CLR functions that are computing-intensive and that do not perform data access are better written in managed code.</span></span> <span data-ttu-id="ac7a2-127">ただし、データ アクセスは [!INCLUDE[tsql](../../../includes/tsql-md.md)] 関数の方が CLR 統合に比べて効率的です。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-127">[!INCLUDE[tsql](../../../includes/tsql-md.md)] functions do, however, perform data access more efficiently than CLR integration.</span></span>  
  
### <a name="user-defined-aggregates"></a><span data-ttu-id="ac7a2-128">ユーザー定義集計</span><span class="sxs-lookup"><span data-stu-id="ac7a2-128">User-Defined Aggregates</span></span>  
 <span data-ttu-id="ac7a2-129">マネージド コードを使用すると、カーソル ベースの集計よりも大幅に優れたパフォーマンスを発揮できます。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-129">Managed code can significantly outperform cursor-based aggregation.</span></span> <span data-ttu-id="ac7a2-130">一般的には、組み込みの [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 集計関数に比べてマネージド コードはわずかに低速です。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-130">Managed code generally performs slightly slower than built-in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] aggregate functions.</span></span> <span data-ttu-id="ac7a2-131">ネイティブの組み込み集計関数が存在する場合は、その関数を使用することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-131">We recommend that if a native built-in aggregate function exists, you should use it.</span></span> <span data-ttu-id="ac7a2-132">必要な集計がネイティブにサポートされていない場合、パフォーマンス上の理由からカーソル ベースの実装よりも CLR ユーザー定義集計の使用を検討してください。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-132">In cases in which the needed aggregation is not natively supported, consider a CLR user-defined aggregate over a cursor-based implementation for performance reasons.</span></span>  
  
### <a name="streaming-table-valued-functions"></a><span data-ttu-id="ac7a2-133">テーブル値関数のストリーミング</span><span class="sxs-lookup"><span data-stu-id="ac7a2-133">Streaming Table-Valued Functions</span></span>  
 <span data-ttu-id="ac7a2-134">関数を呼び出した結果として、テーブルを返す必要性が生じる場合がよくあります。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-134">Applications often need to return a table as a result of invoking a function.</span></span> <span data-ttu-id="ac7a2-135">たとえば、インポート操作の一環としてファイルから表形式のデータを読み取る場合や、コンマ区切りの値をリレーショナル表現に変換する場合などです。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-135">Examples include reading tabular data from a file as part of an import operation, and converting comma-separated-values to a relational representation.</span></span> <span data-ttu-id="ac7a2-136">一般的に、このような作業を実現するには、テーブルを呼び出し元で使用する前に、結果テーブルを具体化して値を格納する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-136">Typically, you can accomplish this by materializing and populating the result table before it can be consumed by the caller.</span></span> <span data-ttu-id="ac7a2-137">CLR を [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] に統合することで、STVF (ストリーミング テーブル値関数) という新しい拡張方式を使用できます。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-137">The integration of the CLR into [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] introduces a new extensibility mechanism called a streaming table-valued function (STVF).</span></span> <span data-ttu-id="ac7a2-138">マネージド STVF は、同様の拡張ストアド プロシージャを実装した場合に比べて、優れたパフォーマンスを発揮します。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-138">Managed STVFs perform better than comparable extended stored procedure implementations.</span></span>  
  
 <span data-ttu-id="ac7a2-139">STVF は、`IEnumerable` インターフェイスを返すマネージド関数です。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-139">STVFs are managed functions that return an `IEnumerable` interface.</span></span> <span data-ttu-id="ac7a2-140">`IEnumerable` には STVF が返した結果セットの中を移動するメソッドがあります。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-140">`IEnumerable` has methods to navigate the result set returned by the STVF.</span></span> <span data-ttu-id="ac7a2-141">STVF を呼び出して返される `IEnumerable` は、クエリ プランに直接接続されます。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-141">When the STVF is invoked, the returned `IEnumerable` is directly connected to the query plan.</span></span> <span data-ttu-id="ac7a2-142">クエリ プランで行のフェッチが必要になると、`IEnumerable` のメソッドが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-142">The query plan calls `IEnumerable` methods when it needs to fetch rows.</span></span> <span data-ttu-id="ac7a2-143">このような反復的なモデルにより、テーブル全体に値が格納されるまで待たなくても、最初の行が生成された直後から結果を使用できます。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-143">This iteration model allows results to be consumed immediately after the first row is produced, instead of waiting until the entire table is populated.</span></span> <span data-ttu-id="ac7a2-144">関数の呼び出しに伴うメモリの消費を大幅に抑えることもできます。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-144">It also significantly reduces the memory consumed by invoking the function.</span></span>  
  
### <a name="arrays-vs-cursors"></a><span data-ttu-id="ac7a2-145">配列とカーソル</span><span class="sxs-lookup"><span data-stu-id="ac7a2-145">Arrays vs. Cursors</span></span>  
 <span data-ttu-id="ac7a2-146">配列として簡単に表現できるデータを [!INCLUDE[tsql](../../../includes/tsql-md.md)] カーソルでスキャンする必要がある場合、マネージド コードを使用するとパフォーマンスが大幅に向上します。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-146">When [!INCLUDE[tsql](../../../includes/tsql-md.md)] cursors must traverse data that is more easily expressed as an array, managed code can be used with significant performance gains.</span></span>  
  
### <a name="string-data"></a><span data-ttu-id="ac7a2-147">文字列データ</span><span class="sxs-lookup"><span data-stu-id="ac7a2-147">String Data</span></span>  
 <span data-ttu-id="ac7a2-148">`varchar` などの [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 文字データは、マネージド関数では SqlString 型または SqlChars 型にすることができます。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-148">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] character data, such as `varchar`, can be of the type SqlString or SqlChars in managed functions.</span></span> <span data-ttu-id="ac7a2-149">SqlString 変数は値全体のインスタンスをメモリに作成します。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-149">SqlString variables create an instance of the entire value into memory.</span></span> <span data-ttu-id="ac7a2-150">SqlChars 変数には、ストリーミング インターフェイスが用意されており、これを使用すると、値全体のインスタンスをメモリに作成しないことでパフォーマンスおよびスケーラビリティを高めることができます。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-150">SqlChars variables provide a streaming interface that can be used to achieve better performance and scalability by not creating an instance of the entire value into memory.</span></span> <span data-ttu-id="ac7a2-151">このことは、特に LOB (ラージ オブジェクト) データにとって重要です。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-151">This becomes particularly important for large object (LOB) data.</span></span> <span data-ttu-id="ac7a2-152">また、`SqlXml.CreateReader()` が返すストリーミング インターフェイスを経由すると、サーバーの XML データにアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-152">Additionally, server XML data can be accessed through a streaming interface returned by `SqlXml.CreateReader()`.</span></span>  
  
### <a name="clr-vs-extended-stored-procedures"></a><span data-ttu-id="ac7a2-153">CLR と拡張ストアド プロシージャ</span><span class="sxs-lookup"><span data-stu-id="ac7a2-153">CLR vs. Extended Stored Procedures</span></span>  
 <span data-ttu-id="ac7a2-154">マネージド プロシージャから結果セットをクライアントに返す Microsoft.SqlServer.Server API (アプリケーション プログラミング インターフェイス) は、拡張ストアド プロシージャにより使用される ODS (オープン データ サービス) API に比べパフォーマンスに優れています。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-154">The Microsoft.SqlServer.Server application programming interfaces (APIs) that allow managed procedures to send result sets back to the client perform better than the Open Data Services (ODS) APIs used by extended stored procedures.</span></span> <span data-ttu-id="ac7a2-155">また、System.Data.SqlServer API は [!INCLUDE[ssVersion2005](../../../includes/ssversion2005-md.md)] で導入された `xml`、`varchar(max)`、`nvarchar(max)`、`varbinary(max)` などのデータ型をサポートしていますが、ODS API ではこれらの新しいデータ型をサポートするための拡張が行われていません。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-155">Furthermore, the System.Data.SqlServer APIs support data types such as `xml`, `varchar(max)`, `nvarchar(max)`, and `varbinary(max)`, introduced in [!INCLUDE[ssVersion2005](../../../includes/ssversion2005-md.md)], while the ODS APIs have not been extended to support the new data types.</span></span>  
  
 <span data-ttu-id="ac7a2-156">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] ではマネージド コードによってメモリ、スレッド、同期などのリソースの使用状況が管理されます。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-156">With managed code, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] manages use of resources such as memory, threads, and synchronization.</span></span> <span data-ttu-id="ac7a2-157">これらのリソースを公開するマネージド API が、[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] リソース マネージャーの上位に実装されるためです。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-157">This is because the managed APIs that expose these resources are implemented on top of the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] resource manager.</span></span> <span data-ttu-id="ac7a2-158">逆に、拡張ストアド プロシージャは [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] によってリソースの使用状況が監視または制御されることがありません。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-158">Conversely, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] has no view or control over the resource usage of the extended stored procedure.</span></span> <span data-ttu-id="ac7a2-159">たとえば、拡張ストアド プロシージャで大量の CPU リソースまたはメモリ リソースが消費されていても、それを [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] で検出したり制御することはできません。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-159">For example, if an extended stored procedure consumes too much CPU or memory resources, there is no way to detect or control this with [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="ac7a2-160">一方、マネージド コードでは、特定のスレッドが長期間リソースを占有していることを [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] で検出して、タスクからリソースを解放し、他の作業のスケジュールを設定できるようになります。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-160">With managed code, however, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] can detect that a given thread has not yielded for a long period of time, and then force the task to yield so that other work can be scheduled.</span></span> <span data-ttu-id="ac7a2-161">つまり、マネージド コードを使用すると、スケーラビリティやシステム リソースの使用状況が改善されます。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-161">Consequently, using managed code provides for better scalability and system resource usage.</span></span>  
  
 <span data-ttu-id="ac7a2-162">マネージド コードを使用すると、実行環境の保持およびセキュリティ チェックの実施に必要なオーバーヘッドが発生することがあります。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-162">Managed code may incur additional overhead necessary to maintain the execution environment and perform security checks.</span></span> <span data-ttu-id="ac7a2-163">たとえば、([!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] はネイティブ コードと行き来する際にスレッド固有の設定を保つ必要があるので、) [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 内でコードを実行し、マネージド コードとネイティブ コードの切り替えを何度も行う必要がある場合などにオーバーヘッドが生じます。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-163">This is the case, for example, when running inside [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] and numerous transitions from managed to native code are required (because [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] needs to do additional maintenance on thread-specific settings when moving out to native code and back).</span></span> <span data-ttu-id="ac7a2-164">つまり、マネージド コードとネイティブ コードの切り替えが頻発する場合は、[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 内で実行されるマネージド コードに比べて、拡張ストアド プロシージャの方が高いパフォーマンスを発揮できます。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-164">Consequently, extended stored procedures can significantly outperform managed code running inside [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] for cases in which there are frequent transitions between managed and native code.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="ac7a2-165">この機能の使用は非推奨とされるため、拡張ストアド プロシージャを新規作成しないことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-165">It is recommended that you do not develop new extended stored procedures, because this feature has been deprecated.</span></span>  
  
### <a name="native-serialization-for-user-defined-types"></a><span data-ttu-id="ac7a2-166">ユーザー定義型のネイティブ シリアル化</span><span class="sxs-lookup"><span data-stu-id="ac7a2-166">Native Serialization for User-Defined Types</span></span>  
 <span data-ttu-id="ac7a2-167">UDT (ユーザー定義型) は、スカラー型システムの拡張方式として設計されています。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-167">User-defined types (UDTs) are designed as an extensibility mechanism for the scalar type system.</span></span> [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] <span data-ttu-id="ac7a2-168">には `Format.Native` という UDT のシリアル化形式が実装されています。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-168">implements a serialization format for UDTs called `Format.Native`.</span></span> <span data-ttu-id="ac7a2-169">コンパイルのとき、型の定義に合わせてカスタマイズされた MSIL を生成するために型の構造を検査します。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-169">During compilation, the structure of the type is examined to generate MSIL that is customized for that particular type definition.</span></span>  
  
 <span data-ttu-id="ac7a2-170">ネイティブ シリアル化は [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] の既定の実装です。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-170">Native serialization is the default implementation for [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="ac7a2-171">ユーザー定義のシリアル化を行うと、型の作成者がシリアル化のために定義したメソッドが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-171">User-defined serialization invokes a method defined by the type author to do the serialization.</span></span> <span data-ttu-id="ac7a2-172">最高のパフォーマンスを得るには、`Format.Native` シリアル化をできる限り使用してください。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-172">`Format.Native` serialization should be used when possible for best performance.</span></span>  
  
### <a name="normalization-of-comparable-udts"></a><span data-ttu-id="ac7a2-173">同等の UDT の正規化</span><span class="sxs-lookup"><span data-stu-id="ac7a2-173">Normalization of Comparable UDTs</span></span>  
 <span data-ttu-id="ac7a2-174">UDT の並べ替え、比較などのリレーショナル操作で、値のバイナリ表現を直接操作します。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-174">Relational operations, such as sorting and comparing UDTs, operate directly on the binary representation of the value.</span></span> <span data-ttu-id="ac7a2-175">これを行うには、ディスクに UDT の状態を正規化した (バイナリ順にした) 表現を格納します。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-175">This is accomplished by storing a normalized (binary ordered) representation of the state of the UDT on disk.</span></span>  
  
 <span data-ttu-id="ac7a2-176">正規化には 2 つの利点があります。1 つは、型のインスタンスの作成やメソッド呼び出しのオーバヘッドが発生しないようにすることで比較操作のコストが大幅に抑えられることです。もう 1 つは、UDT のバイナリ領域が作成され、ヒストグラム、インデックス、およびその型の値のヒストグラムが作成できるようになることです。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-176">Normalization has two benefits: it makes the comparison operation considerably less expensive by avoiding the construction of the type instance and the method invocation overhead; and it creates a binary domain for the UDT, enabling the construction of histograms, indexes, and histograms for values of the type.</span></span> <span data-ttu-id="ac7a2-177">つまり、メソッド呼び出しを伴わない操作では、正規化した UDT はネイティブの組み込み型と変わらないパフォーマンスを発揮します。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-177">Consequently, normalized UDTs have a very similar performance profile to the native built-in types for operations that do not involve method invocation.</span></span>  
  
### <a name="scalable-memory-usage"></a><span data-ttu-id="ac7a2-178">スケーラビリティを確保するメモリの使用方法</span><span class="sxs-lookup"><span data-stu-id="ac7a2-178">Scalable Memory Usage</span></span>  
 <span data-ttu-id="ac7a2-179">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] のマネージド ガベージ コレクションのパフォーマンスやスケーラビリティを高めるには、大量のメモリを 1 単位として割り当てないようにしてください。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-179">In order for managed garbage collection to perform and scale well in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)], avoid large, single allocation.</span></span> <span data-ttu-id="ac7a2-180">88 KB を超える割り当てはラージ オブジェクト ヒープに配置されます。その結果、小規模の割り当てをいくつも行った場合に比べて、ガベージ コレクションのパフォーマンスやスケーラビリティが低下します。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-180">Allocations greater than 88 kilobytes (KB) in size will be placed on the Large Object Heap, which will cause garbage collection to perform and scale much worse than many smaller allocations.</span></span> <span data-ttu-id="ac7a2-181">たとえば、大きな多次元配列を割り当てる場合、ジャグ (散在した) 配列を割り当てることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="ac7a2-181">For example, if you need to allocate a large multi-dimensional array, it is better to allocate a jagged (scattered) array.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="ac7a2-182">参照</span><span class="sxs-lookup"><span data-stu-id="ac7a2-182">See Also</span></span>  
 [<span data-ttu-id="ac7a2-183">CLR ユーザー定義型</span><span class="sxs-lookup"><span data-stu-id="ac7a2-183">CLR User-Defined Types</span></span>](../clr-integration-database-objects-user-defined-types/clr-user-defined-types.md)  
  
  
