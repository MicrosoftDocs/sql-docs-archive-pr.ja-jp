---
title: メモリ最適化テーブルの持続性 | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: d304c94d-3ab4-47b0-905d-3c8c2aba9db6
author: CarlRabeler
ms.author: carlrab
ms.openlocfilehash: 1d48d671b23d7b7b17557e7829d6f2522c375acd
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/04/2020
ms.locfileid: "87738406"
---
# <a name="durability-for-memory-optimized-tables"></a><span data-ttu-id="1f88b-102">メモリ最適化テーブルの持続性</span><span class="sxs-lookup"><span data-stu-id="1f88b-102">Durability for Memory-Optimized Tables</span></span>
  [!INCLUDE[hek_2](../../../includes/hek-2-md.md)] <span data-ttu-id="1f88b-103">により、メモリ最適化テーブルには完全な持続性が提供されます。</span><span class="sxs-lookup"><span data-stu-id="1f88b-103">provides full durability for memory-optimized tables.</span></span> <span data-ttu-id="1f88b-104">メモリ最適化テーブルを変更したトランザクションがコミットされると、基になるストレージが使用可能な場合、 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] では、(ディスク ベース テーブルの場合と同様に) この変更が永続的である (データベースの再起動後も保持される) ことが保証されます。</span><span class="sxs-lookup"><span data-stu-id="1f88b-104">When a transaction that changed a memory-optimized table commits, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] (as it does for disk-based tables), guarantees that the changes are permanent (will survive a database restart), provided the underlying storage is available.</span></span> <span data-ttu-id="1f88b-105">持続性には、トランザクション ログとディスク上ストレージでのデータ変更の保持という、2 つの主なコンポーネントがあります。</span><span class="sxs-lookup"><span data-stu-id="1f88b-105">There are two key components of durability: transaction logging and persisting data changes to on-disk storage.</span></span>

## <a name="transaction-log"></a><span data-ttu-id="1f88b-106">トランザクション ログ</span><span class="sxs-lookup"><span data-stu-id="1f88b-106">Transaction Log</span></span>
 <span data-ttu-id="1f88b-107">ディスク ベース テーブルまたは持続性のあるメモリ最適化テーブルに対するすべての変更は、1 つ以上のトランザクション ログ レコードにキャプチャされます。</span><span class="sxs-lookup"><span data-stu-id="1f88b-107">All changes made to disk-based tables or durable memory-optimized tables are captured in one or more transaction log records.</span></span> <span data-ttu-id="1f88b-108">トランザクションのコミット時に、 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] は、トランザクションに関連付けられているログ レコードをディスクに書き込んだ後、トランザクションによってコミットされたアプリケーションまたはユーザー セッションと通信します。</span><span class="sxs-lookup"><span data-stu-id="1f88b-108">When a transaction commits, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] writes the log records associated with the transaction to disk before communicating to the application or user session that the transaction has committed.</span></span> <span data-ttu-id="1f88b-109">これにより、トランザクションによる変更が持続可能であることが保証されます。</span><span class="sxs-lookup"><span data-stu-id="1f88b-109">This guarantees that changes made by the transaction are durable.</span></span> <span data-ttu-id="1f88b-110">メモリ最適化テーブルのトランザクション ログは、ディスク ベース テーブルで使用されている同じログ ストリームと完全に統合されています。</span><span class="sxs-lookup"><span data-stu-id="1f88b-110">The transaction log for memory-optimized tables is fully integrated with the same log stream used by disk-based tables.</span></span> <span data-ttu-id="1f88b-111">この統合によって、既存のトランザクション ログ バックアップ、復旧、および復元操作は引き続き機能し、追加の手順は必要ありません。</span><span class="sxs-lookup"><span data-stu-id="1f88b-111">This integration allows existing transaction log backup, recover, and restore operations to continue to work without requiring any additional steps.</span></span> <span data-ttu-id="1f88b-112">ただし、[!INCLUDE[hek_2](../../../includes/hek-2-md.md)] によりワークロードのトランザクションのスループットを大幅に向上できるため、トランザクション ログ ストレージが高くなった IO 要件を処理するよう正しく構成されていることを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1f88b-112">However, since [!INCLUDE[hek_2](../../../includes/hek-2-md.md)] can increase transaction throughput of your workload significantly, you need to make sure that transaction log storage is configured appropriately to handle the increased IO requirements.</span></span>

## <a name="data-and-delta-files"></a><span data-ttu-id="1f88b-113">データ ファイルとデルタ ファイル</span><span class="sxs-lookup"><span data-stu-id="1f88b-113">Data and Delta Files</span></span>
 <span data-ttu-id="1f88b-114">メモリ最適化テーブルのデータは、1 つ以上のメモリ内インデックスでリンクされる自由形式のデータ行としてメモリに格納されます。</span><span class="sxs-lookup"><span data-stu-id="1f88b-114">The data in memory-optimized tables is stored as free-form data rows that are linked through one or more in-memory indexes, in memory.</span></span> <span data-ttu-id="1f88b-115">ディスク ベース テーブルで使用されるような、データ行のページ構造はありません。</span><span class="sxs-lookup"><span data-stu-id="1f88b-115">There are no page structures for data rows, such as those used for disk-based tables.</span></span> <span data-ttu-id="1f88b-116">アプリケーションがトランザクションをコミットできる状態になったら、[!INCLUDE[hek_2](../../../includes/hek-2-md.md)] によってトランザクションのログ レコードが生成されます。</span><span class="sxs-lookup"><span data-stu-id="1f88b-116">When the application is ready to commit the transaction, the [!INCLUDE[hek_2](../../../includes/hek-2-md.md)] generates the log records for the transaction.</span></span> <span data-ttu-id="1f88b-117">メモリ最適化テーブルの永続化は、バックグラウンド スレッドを使用して一連のデータ ファイルおよびデルタ ファイルで実行されます。</span><span class="sxs-lookup"><span data-stu-id="1f88b-117">The persistence of memory-optimized tables is done with a set of data and delta files using a background thread.</span></span> <span data-ttu-id="1f88b-118">データ ファイルとデルタ ファイルは 1 つ以上のコンテナーにあります (FILESTREAM データで使用される同様のメカニズムを使用しています)。</span><span class="sxs-lookup"><span data-stu-id="1f88b-118">The data and delta files are located in one or more containers (using the same mechanism used for FILESTREAM data).</span></span> <span data-ttu-id="1f88b-119">これらのコンテナーは、メモリ最適化ファイル グループと呼ばれる、新しい種類のファイル グループにマップされます。</span><span class="sxs-lookup"><span data-stu-id="1f88b-119">These containers are mapped to a new type of filegroup, called a memory-optimized filegroup.</span></span>

 <span data-ttu-id="1f88b-120">データはこれらのファイルに厳密な順次形式で書き込まれるため、スピン メディアの場合のディスク待機時間が最小限に抑えられます。</span><span class="sxs-lookup"><span data-stu-id="1f88b-120">Data is written to these files in a strictly sequential fashion, which minimizes disk latency for spinning media.</span></span> <span data-ttu-id="1f88b-121">異なるディスクにある複数のコンテナーを使用して、I/O 動作を分散することもできます。</span><span class="sxs-lookup"><span data-stu-id="1f88b-121">You can use multiple containers on different disks to distribute the I/O activity.</span></span> <span data-ttu-id="1f88b-122">異なるディスクにある複数のコンテナーにデータ ファイルとデルタ ファイルを配置すると、復旧時に、ディスク上のデータ ファイルとデルタ ファイルからメモリにデータが読み込まれるときのパフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="1f88b-122">Data and delta files in multiple containers on different disks will increase recovery performance when data is read from the data and delta files on disk, into memory.</span></span>

 <span data-ttu-id="1f88b-123">アプリケーションは、直接データ ファイルとデルタ ファイルにアクセスしません。</span><span class="sxs-lookup"><span data-stu-id="1f88b-123">An application does not directly access data and delta files.</span></span> <span data-ttu-id="1f88b-124">すべてのデータ読み取りと書き込みには、インメモリ データが使用されます。</span><span class="sxs-lookup"><span data-stu-id="1f88b-124">All data reads and writes use in-memory data.</span></span>

### <a name="the-data-file"></a><span data-ttu-id="1f88b-125">データ ファイル</span><span class="sxs-lookup"><span data-stu-id="1f88b-125">The Data File</span></span>
 <span data-ttu-id="1f88b-126">データ ファイルには、1 つ以上のメモリ最適化テーブルからの行が格納されます。これらの行は、INSERT 操作や UPDATE 操作の一部である複数のトランザクションによって挿入されたものです。</span><span class="sxs-lookup"><span data-stu-id="1f88b-126">A data file contains rows from one or more memory-optimized tables that were inserted by multiple transactions as part of INSERT or UPDATE operations.</span></span> <span data-ttu-id="1f88b-127">たとえば、ある行はメモリ最適化テーブル T1 から挿入され、次の行はメモリ最適化テーブル T2 から挿入されることがあります。</span><span class="sxs-lookup"><span data-stu-id="1f88b-127">For example, one row can be from memory-optimized table T1 and the next row can be from memory-optimized table T2.</span></span> <span data-ttu-id="1f88b-128">これらの行は、データ アクセスが順次的になるように、トランザクション ログ内のトランザクションの順序でデータ ファイルに追加されます。</span><span class="sxs-lookup"><span data-stu-id="1f88b-128">The rows are appended to the data file in the order of transactions in the transaction log, making data access sequential.</span></span> <span data-ttu-id="1f88b-129">これにより、ランダム I/O と比較した場合、I/O スループットが大幅に向上します。</span><span class="sxs-lookup"><span data-stu-id="1f88b-129">This enables an order of magnitude better I/O throughput compared to random I/O.</span></span> <span data-ttu-id="1f88b-130">各データ ファイルのサイズは、16 GB を超えるメモリを搭載するコンピューターでは約 128 MB、16 GB 以下のメモリを搭載するコンピューターでは約 16 MB になります。</span><span class="sxs-lookup"><span data-stu-id="1f88b-130">Each data file is sized approximately to 128MB for computers with memory greater than 16GB, and 16MB for computers with less than or equal to 16GB.</span></span> <span data-ttu-id="1f88b-131">データ ファイルがいっぱいになると、新しいトランザクションによって挿入される行は別のデータ ファイルに格納されます。</span><span class="sxs-lookup"><span data-stu-id="1f88b-131">Once the data file is full, the rows inserted by new transactions are stored in another data file.</span></span> <span data-ttu-id="1f88b-132">時間が経つにつれて、持続性のあるメモリ最適化テーブルの行を格納するデータ ファイルは増えていきます。データ ファイル間では、時間的に離れたトランザクションからの行が含まれることになりますが、1 つのデータ ファイル内のトランザクション範囲は連続しています。</span><span class="sxs-lookup"><span data-stu-id="1f88b-132">Over time, the rows from durable memory-optimized tables are stored in one of more data files and each data file containing rows from a disjoint but contiguous range of transactions.</span></span> <span data-ttu-id="1f88b-133">たとえば、トランザクションのコミット タイムスタンプの範囲が (100, 200) であるデータ ファイルには、コミット タイムスタンプが 100 より大きく 200 以下のトランザクションによって挿入されたすべての行が含まれています。</span><span class="sxs-lookup"><span data-stu-id="1f88b-133">For example a data file with transaction commit timestamp in the range of (100, 200) has all the rows inserted by transactions that have commit timestamp greater than 100 and less than or equal to 200.</span></span> <span data-ttu-id="1f88b-134">コミット タイムスタンプとは、コミットの準備ができたトランザクションに割り当てられる、単調に増加する数値です。</span><span class="sxs-lookup"><span data-stu-id="1f88b-134">The commit timestamp is a monotonically increasing number assigned to a transaction when it is ready to commit.</span></span> <span data-ttu-id="1f88b-135">各トランザクションには、一意のコミット タイムスタンプが設定されます。</span><span class="sxs-lookup"><span data-stu-id="1f88b-135">Each transaction has a unique commit timestamp.</span></span>

 <span data-ttu-id="1f88b-136">行が削除または変更されるときは、その行がデータ ファイル内で実際に削除または変更されるのではなく、デルタ ファイルという別の種類のファイルによって、削除された行の追跡が行われます。</span><span class="sxs-lookup"><span data-stu-id="1f88b-136">When a row is deleted or updated, the row is not removed or changed in-place in the data file but the deleted rows are tracked in another type of file: the delta file.</span></span> <span data-ttu-id="1f88b-137">更新操作は、それぞれの行の削除操作と挿入操作の組み合わせとして処理されます。</span><span class="sxs-lookup"><span data-stu-id="1f88b-137">Update operations are processed as a tuple of delete and insert operations for each row.</span></span> <span data-ttu-id="1f88b-138">これにより、データ ファイルでランダム IO が発生しないようになっています。</span><span class="sxs-lookup"><span data-stu-id="1f88b-138">This eliminates random IO on the data file.</span></span>

### <a name="the-delta-file"></a><span data-ttu-id="1f88b-139">デルタ ファイル</span><span class="sxs-lookup"><span data-stu-id="1f88b-139">The Delta File</span></span>
 <span data-ttu-id="1f88b-140">各データ ファイルには、同じトランザクション範囲を持つデルタ ファイルが対応付けられています。デルタ ファイルは、そのトランザクション範囲のトランザクションによって挿入された削除済みの行を追跡します。</span><span class="sxs-lookup"><span data-stu-id="1f88b-140">Each data file is paired with a delta file that has the same transaction range and tracks the deleted rows inserted by transactions in the transaction range.</span></span> <span data-ttu-id="1f88b-141">このデータ ファイルとデルタ ファイルはチェックポイント ファイル ペア (CFP) と呼ばれます。これは Merge 操作の単位であるとともに、割り当てと割り当て解除の単位でもあります。</span><span class="sxs-lookup"><span data-stu-id="1f88b-141">This data and delta file is referred to as a Checkpoint File Pair (CFP) and it is the unit of allocation and deallocation as well as the unit for Merge operations.</span></span> <span data-ttu-id="1f88b-142">たとえば、トランザクション範囲 (100、200) に対応するデルタ ファイルには、範囲 (100、200) のトランザクションによって挿入された削除済みの行が格納されます。</span><span class="sxs-lookup"><span data-stu-id="1f88b-142">For example, a delta file corresponding to transaction range (100, 200) will store deleted rows that were inserted by transactions in the range (100, 200).</span></span> <span data-ttu-id="1f88b-143">データ ファイルと同様に、デルタ ファイルは順次アクセスされます。</span><span class="sxs-lookup"><span data-stu-id="1f88b-143">Like data files, the delta file is accessed sequentially.</span></span>

 <span data-ttu-id="1f88b-144">行の削除時には、データ ファイルから行が削除されるのではなく、その行への参照が、このデータ行が挿入されたトランザクション範囲に関連付けられているデルタ ファイルに追加されます。</span><span class="sxs-lookup"><span data-stu-id="1f88b-144">When a row is deleted, the row is not removed from the data file but a reference to the row is appended to the delta file associated with the transaction range where this data row was inserted.</span></span> <span data-ttu-id="1f88b-145">削除対象のデータ行は既にデータ ファイルに存在するため、デルタ ファイルには参照情報 ( `{inserting_tx_id, row_id, deleting_tx_id }` ) が格納されるだけです。格納順序は、元の削除操作または更新操作のトランザクション ログの順序に従います。</span><span class="sxs-lookup"><span data-stu-id="1f88b-145">Since the row to be deleted already exists in the data file, the delta file only stores the reference information `{inserting_tx_id, row_id, deleting_tx_id }` and it follows the transactional log order of the originating delete or update operations.</span></span>

## <a name="populating-data-and-delta-files"></a><span data-ttu-id="1f88b-146">データ ファイルとデルタ ファイルの取り込み</span><span class="sxs-lookup"><span data-stu-id="1f88b-146">Populating Data and Delta Files</span></span>
 <span data-ttu-id="1f88b-147">オフライン チェックポイントと呼ばれるバックグラウンド スレッドにより、データ ファイルとデルタ ファイルが取り込まれます。</span><span class="sxs-lookup"><span data-stu-id="1f88b-147">Data and delta file are populated by a background thread called offline checkpoint.</span></span> <span data-ttu-id="1f88b-148">このスレッドは、メモリ最適化テーブルに対するコミットされたトランザクションが生成したトランザクション ログ レコードを読み取り、挿入および削除された行に関する情報を適切なデータ ファイルとデルタ ファイルに追加します。</span><span class="sxs-lookup"><span data-stu-id="1f88b-148">This thread reads the transaction log records generated by committed transactions on memory-optimized tables and appends information about the inserted and deleted rows into appropriate data and delta files.</span></span> <span data-ttu-id="1f88b-149">ディスク ベース テーブルでは、チェックポイントの完了時にデータやインデックス ページがランダム I/O でフラッシュされますが、これとは異なり、メモリ最適化テーブルの永続化は連続的なバックグラウンド操作によって行われます。</span><span class="sxs-lookup"><span data-stu-id="1f88b-149">Unlike disk-based tables where data/index pages are flushed with random I/O when checkpoint is done, the persistence of memory-optimized table is continuous background operation.</span></span> <span data-ttu-id="1f88b-150">トランザクションでは、それ以前のいずれかのトランザクションによって挿入された任意の行が削除または更新されることがあるため、複数のデルタ ファイルへのアクセスが発生します。</span><span class="sxs-lookup"><span data-stu-id="1f88b-150">Multiple delta files are accessed because a transaction can delete or update any row that was inserted by any previous transaction.</span></span> <span data-ttu-id="1f88b-151">削除情報は常にデルタ ファイルの末尾に追加されます。</span><span class="sxs-lookup"><span data-stu-id="1f88b-151">Deletion information is always appended at the end of the delta file.</span></span> <span data-ttu-id="1f88b-152">たとえば、下に示す図では、コミット タイムスタンプが 600 のトランザクションでは、1 つの新しい行が挿入され、コミット タイムスタンプが 150、250、および 450 のトランザクションによって挿入された行が削除されます。</span><span class="sxs-lookup"><span data-stu-id="1f88b-152">For example, a transaction with a commit timestamp of 600 inserts one new row and deletes rows inserted by transactions with a commit timestamp of 150, 250 and 450 as shown in the picture below.</span></span> <span data-ttu-id="1f88b-153">4 つのファイル I/O 操作 (3 つは削除された行が対象で、1 つは新しく挿入された行が対象) はすべて、対応するデルタ ファイルとデータ ファイルに対する追加専用の操作です。</span><span class="sxs-lookup"><span data-stu-id="1f88b-153">All 4 file I/O operations (three for deleted rows and 1 for the newly inserted rows), are append-only operations to the corresponding delta and data files.</span></span>

 <span data-ttu-id="1f88b-154">![メモリ最適化テーブルのログ レコードの読み取り](../../database-engine/media/read-logs-hekaton.gif "メモリ最適化テーブルのログ レコードの読み取り")</span><span class="sxs-lookup"><span data-stu-id="1f88b-154">![Read log records for memory-optimized tables.](../../database-engine/media/read-logs-hekaton.gif "Read log records for memory-optimized tables.")</span></span>

## <a name="accessing-data-and-delta-files"></a><span data-ttu-id="1f88b-155">データ ファイルとデルタ ファイルへのアクセス</span><span class="sxs-lookup"><span data-stu-id="1f88b-155">Accessing Data and Delta Files</span></span>
 <span data-ttu-id="1f88b-156">データ ファイルとデルタ ファイルのペアにアクセスするのは次のような場合です。</span><span class="sxs-lookup"><span data-stu-id="1f88b-156">Data and delta file pairs are accessed when the following occurs.</span></span>

 <span data-ttu-id="1f88b-157">オフラインチェックポイントスレッドこのスレッドは、メモリ最適化データ行に挿入と削除を、対応するデータファイルとデルタファイルのペアに追加します。</span><span class="sxs-lookup"><span data-stu-id="1f88b-157">Offline checkpoint thread This thread appends inserts and deletes to memory-optimized data rows, to the corresponding data and delta file pairs.</span></span>

 <span data-ttu-id="1f88b-158">Merge 操作は、1つ以上のデータファイルとデルタファイルのペアをマージし、新しいデータとデルタファイルのペアを作成します。</span><span class="sxs-lookup"><span data-stu-id="1f88b-158">Merge operation The operation merges one or more data and delta file pairs and creates a new data and delta file pair.</span></span>

 <span data-ttu-id="1f88b-159">が再起動されたとき、またはデータベースがオンラインに戻ったときのクラッシュ復旧中に [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 、データファイルとデルタファイルのペアを使用してメモリ最適化データが設定されます。</span><span class="sxs-lookup"><span data-stu-id="1f88b-159">During crash recovery When [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] is restarted or the database is brought back online, the memory-optimized data is populated using the data and delta file pairs.</span></span> <span data-ttu-id="1f88b-160">デルタ ファイルは、対応するデータ ファイルから行を読み取るときに、削除された行のフィルターとして機能します。</span><span class="sxs-lookup"><span data-stu-id="1f88b-160">The delta file acts as a filter for the deleted rows when reading the rows from the corresponding data file.</span></span> <span data-ttu-id="1f88b-161">データ ファイルとデルタ ファイルのペアは独立しているため、データをメモリに取り込む時間を削減するために、これらのファイルは並列処理で読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="1f88b-161">Because each data and delta file pair is independent, these files are loaded in parallel to reduce the time taken to populate data into memory.</span></span> <span data-ttu-id="1f88b-162">データがメモリに読み込まれると、インメモリ OLTP エンジンは、メモリ最適化データが完全になるように、まだチェックポイント ファイルで扱われていないアクティブなトランザクション ログ レコードを適用します。</span><span class="sxs-lookup"><span data-stu-id="1f88b-162">Once the data has been loaded into memory, the In-Memory OLTP engine applies the active transaction log records not yet covered by the checkpoint files so that the memory-optimized data is complete.</span></span>

 <span data-ttu-id="1f88b-163">復元操作中に、インメモリ OLTP チェックポイントファイルがデータベースバックアップから作成され、1つまたは複数のトランザクションログバックアップが適用されます。</span><span class="sxs-lookup"><span data-stu-id="1f88b-163">During restore operation The In-Memory OLTP checkpoint files are created from the database backup, and then one or more transaction log backups are applied.</span></span> <span data-ttu-id="1f88b-164">クラッシュ後の復旧の場合と同様に、インメモリ OLTP エンジンはデータを並列処理でメモリに読み込むので、復旧時間への影響を最小限に抑えることができます。</span><span class="sxs-lookup"><span data-stu-id="1f88b-164">As with crash recovery, the In-Memory OLTP engine loads data into memory in parallel, to minimize the impact on recovery time.</span></span>

## <a name="merging-data-and-delta-files"></a><span data-ttu-id="1f88b-165">データ ファイルとデルタ ファイルのマージ</span><span class="sxs-lookup"><span data-stu-id="1f88b-165">Merging Data and Delta Files</span></span>
 <span data-ttu-id="1f88b-166">メモリ最適化テーブルのデータは、1 つ以上のデータ ファイルとデルタ ファイルのペア (チェックポイント ファイル ペアまたは CFP とも呼ばれます) に格納されます。</span><span class="sxs-lookup"><span data-stu-id="1f88b-166">The data for memory optimized tables is stored in one or more data and delta file pairs (also called a checkpoint file pair, or CFP).</span></span> <span data-ttu-id="1f88b-167">データ ファイルは挿入された行を格納し、デルタ ファイルは削除された行を参照します。</span><span class="sxs-lookup"><span data-stu-id="1f88b-167">Data files store inserted rows and delta files reference deleted rows.</span></span> <span data-ttu-id="1f88b-168">OLTP ワークロードの実行中、DML 操作によって行が更新、挿入、および削除されると、新しい行を保存するために新しい CFP が作成され、削除された行への参照がデルタ ファイルに追加されます。</span><span class="sxs-lookup"><span data-stu-id="1f88b-168">During the execution of an OLTP workload, as the DML operations update, insert, and delete rows, new CFPs are created to persist the new rows, and the reference to the deleted rows is appended to delta files.</span></span>

 <span data-ttu-id="1f88b-169">以前に閉じられたすべての CFP と現在アクティブな CFP のメタデータは、ストレージ配列と呼ばれる内部の配列構造に格納されます。</span><span class="sxs-lookup"><span data-stu-id="1f88b-169">The metadata of all previously-closed and currently active CFPs is stored in an internal array structure referred to as the storage array.</span></span> <span data-ttu-id="1f88b-170">これはサイズが 8,192 エントリに制限された CFP の配列です。</span><span class="sxs-lookup"><span data-stu-id="1f88b-170">It is a finitely sized (8,192 entries) array of CFPs.</span></span> <span data-ttu-id="1f88b-171">ストレージ配列内のエントリの順序は、トランザクション範囲に従います。</span><span class="sxs-lookup"><span data-stu-id="1f88b-171">The entries in the storage array are ordered by transaction range.</span></span> <span data-ttu-id="1f88b-172">ストレージ配列内の CFP (およびログの末尾) は、メモリ最適化テーブルを持つデータベースの復旧に必要となるディスク上の状態を表します。</span><span class="sxs-lookup"><span data-stu-id="1f88b-172">The CFPs in the storage array (along with the tail of the log) represent all the on-disk state required to recover a database with memory-optimized tables.</span></span>

 <span data-ttu-id="1f88b-173">DML 操作を行うと、時間と共に、CFP の数が増加し、ストレージ配列が上限に近づくため、次の問題が発生します。</span><span class="sxs-lookup"><span data-stu-id="1f88b-173">Over time, with DML operations, the number of CFPs grow causing the storage array to reach capacity, which introduces the following challenges:</span></span>

-   <span data-ttu-id="1f88b-174">削除された行。</span><span class="sxs-lookup"><span data-stu-id="1f88b-174">Deleted rows.</span></span>  <span data-ttu-id="1f88b-175">削除された行はデータ ファイルに残りますが、対応するデルタ ファイルで削除済みとしてマークされます。</span><span class="sxs-lookup"><span data-stu-id="1f88b-175">Deleted rows remain in the data file but are marked as deleted in the corresponding delta file.</span></span> <span data-ttu-id="1f88b-176">これらの行は不要なため、ストレージから削除されます。</span><span class="sxs-lookup"><span data-stu-id="1f88b-176">These rows are no longer needed and will be removed from the storage.</span></span> <span data-ttu-id="1f88b-177">削除された行が CFP から除去されていない場合は、領域が不必要に使用され、復旧時間が長くなります。</span><span class="sxs-lookup"><span data-stu-id="1f88b-177">If deleted rows were not removed from CFPs, they would use space unnecessarily and make recovery time slower.</span></span>

-   <span data-ttu-id="1f88b-178">ストレージ配列がいっぱいになる。</span><span class="sxs-lookup"><span data-stu-id="1f88b-178">Storage array full.</span></span> <span data-ttu-id="1f88b-179">ストレージ配列に 8,000 個のエントリが割り当てられると (既存のマージを完了するため、またはマージを手動で実行できるように、配列には 192 個のエントリが予約されています)、持続性のあるメモリ最適化テーブルに対して新しい DML トランザクションを実行することはできなくなります。</span><span class="sxs-lookup"><span data-stu-id="1f88b-179">When there 8,000 entries in the storage array are allocated (192 entries in the array are reserved for existing merges to compete or to allow you to do manual merges), no new DML transactions can be executed on durable memory-optimized tables.</span></span> <span data-ttu-id="1f88b-180">残りのエントリは、チェックポイント操作とマージ操作にしか使用できません。</span><span class="sxs-lookup"><span data-stu-id="1f88b-180">Only checkpoint and merge operations are allowed to consume the remaining entries.</span></span> <span data-ttu-id="1f88b-181">これにより、DML トランザクションで配列がいっぱいになるのを防ぎ、既存のファイルのマージと配列内の領域の再利用に備えて一部のエントリが確保されます。</span><span class="sxs-lookup"><span data-stu-id="1f88b-181">This ensures that DML transactions do not fill the array and that some entries in the array are reserved to merge existing files and to reclaim space in the array.</span></span>

-   <span data-ttu-id="1f88b-182">ストレージ配列操作のオーバーヘッド。</span><span class="sxs-lookup"><span data-stu-id="1f88b-182">Storage array manipulation overhead.</span></span> <span data-ttu-id="1f88b-183">内部プロセスでは、削除された行に関する情報を追加するためにデルタ ファイルを見つける必要がある場合などに、ストレージ配列を検索します。</span><span class="sxs-lookup"><span data-stu-id="1f88b-183">Internal processes search the storage array for operations such as finding the delta file to append information about a deleted row.</span></span> <span data-ttu-id="1f88b-184">このような操作のコストは、エントリ数が増えるにつれて増加します。</span><span class="sxs-lookup"><span data-stu-id="1f88b-184">The cost of these operations increases with the number of entries.</span></span>

 <span data-ttu-id="1f88b-185">効率の低下を防ぐために、閉じている古い CFP は、後で説明するマージ ポリシーに基づいてマージされます。結果のストレージ配列は圧縮され、CFP の数が少なくなりますが、データ セットは変わりません。</span><span class="sxs-lookup"><span data-stu-id="1f88b-185">To help prevent these inefficiencies, the older closed CFPs are merged, based on a merge policy described below, so the storage array is compacted to represent the same set of data, with a reduced number of CFPs.</span></span>

 <span data-ttu-id="1f88b-186">データベース内の持続性のあるすべてのテーブルのメモリ内サイズの合計は 250 GB を超えないようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="1f88b-186">The total in-memory size of all durable tables in a database should not exceed 250 GB.</span></span> <span data-ttu-id="1f88b-187">最大 250 GB のメモリを使用する持続性のあるテーブルでは、挿入操作、削除操作、および更新操作が想定されており、平均 500 GB のストレージ領域が必要となります。</span><span class="sxs-lookup"><span data-stu-id="1f88b-187">Durable tables that use up to 250 GB of memory will, assuming insert, delete, and update operations, require on average 500 GB of storage space.</span></span> <span data-ttu-id="1f88b-188">500 GB のストレージ領域をサポートするには、メモリ最適化ファイル グループ内の 4,000 組のデータ ファイルとデルタ ファイルのペアが必要です。</span><span class="sxs-lookup"><span data-stu-id="1f88b-188">4,000 data and delta file pairs in the memory-optimized file group are required to support the 500 GB of storage space.</span></span>

 <span data-ttu-id="1f88b-189">データベース操作が短期間に集中すると、チェックポイント操作とマージ操作のラグが発生し、必要なデータ ファイルとデルタ ファイルのペアの数が増加します。</span><span class="sxs-lookup"><span data-stu-id="1f88b-189">Short-term surges in database activity may cause checkpoint and merge operations lag, which will increase the number of required data and delta file pairs.</span></span> <span data-ttu-id="1f88b-190">短期間に急増するデータベース操作に対応するために、ストレージ システムでは、最大 8,000 組のデータ ファイルとデルタ ファイルのペアを合計 1 TB までのストレージに割り当てることができます。</span><span class="sxs-lookup"><span data-stu-id="1f88b-190">To accommodate short-term surges spikes in database activity, the storage system can allocate up to 8,000 data and delta file pairs up to a total of 1TB of storage.</span></span> <span data-ttu-id="1f88b-191">この制限に達すると、チェックポイント操作の遅延が解消されるまで、データベースでは新しいトランザクションが許可されません。</span><span class="sxs-lookup"><span data-stu-id="1f88b-191">When that limit is reached, there will be no new transactions allowed on the database until checkpoint operations catch up.</span></span> <span data-ttu-id="1f88b-192">メモリ内の持続性のあるテーブルのサイズが長期間にわたって 250 GB を超える場合、8,000 組のファイル ペアの制限に達することがあります。</span><span class="sxs-lookup"><span data-stu-id="1f88b-192">If the size of durable tables in memory exceeds 250GB for long periods of time, there is a chance of reaching the 8,000 file pair limit.</span></span>

 <span data-ttu-id="1f88b-193">マージ操作は、内部で定義されているマージ ポリシーに基づいて、1 つ以上の閉じている隣接 CFP (マージ ソースと呼ばれます) を入力として受け取り、1 つの結果 CFP (マージ ターゲットと呼ばれます) を生成します。</span><span class="sxs-lookup"><span data-stu-id="1f88b-193">The merge operation takes as input one or more adjacent closed CFPs (called merge source) based on an internally defined merge policy, and produces one resultant CFP, called the merge target.</span></span> <span data-ttu-id="1f88b-194">ソース CFP の各デルタ ファイル内のエントリは、対応するデータ ファイルから行をフィルター選択して、不要なデータ行を削除するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="1f88b-194">The entries in each delta file of the source CFPs are used to filter rows from the corresponding data file to remove the data rows that are not needed.</span></span> <span data-ttu-id="1f88b-195">ソース CFP の残りの行は、1 つのターゲット CPF に統合されます。</span><span class="sxs-lookup"><span data-stu-id="1f88b-195">The remaining rows in the source CFPs are consolidated into one target CFP.</span></span> <span data-ttu-id="1f88b-196">マージが完了すると、結果の CFP でソース CFP (マージ ソース) が置き換えられます。</span><span class="sxs-lookup"><span data-stu-id="1f88b-196">After the merge is complete, the resultant merge-target CFP replaces the source CFPs (merge sources).</span></span> <span data-ttu-id="1f88b-197">マージ ソースの CFP は、移行フェーズを経た後でストレージから削除されます。</span><span class="sxs-lookup"><span data-stu-id="1f88b-197">The merge-source CFPs go through a transition phase before they are removed from storage.</span></span>

 <span data-ttu-id="1f88b-198">次の例では、メモリ最適化テーブルのファイル グループに、タイムスタンプが 500 の時点でデータ ファイルとデルタ ファイルのペアが 4 組あり、以前のトランザクションからのデータが含まれています。</span><span class="sxs-lookup"><span data-stu-id="1f88b-198">In the example below, the memory-optimized table file group has four data and delta file pairs at timestamp 500 containing data from previous transactions.</span></span> <span data-ttu-id="1f88b-199">たとえば、最初のデータ ファイルの行は、100 より大きく 200 以下のタイムスタンプを持つトランザクションに対応します。この範囲は (100, 200] と表すこともできます。</span><span class="sxs-lookup"><span data-stu-id="1f88b-199">For example, the rows in the first data file correspond to transactions with timestamp greater than 100 and less than or equal to 200; alternatively represented as (100, 200].</span></span> <span data-ttu-id="1f88b-200">2 番目と 3 番目のデータ ファイルは、削除済みとしてマークされている行を考慮すると、入力率が 50% 未満になっています。</span><span class="sxs-lookup"><span data-stu-id="1f88b-200">The second and third data files are shown to be less than 50 percent full after accounting for the rows marked as deleted.</span></span> <span data-ttu-id="1f88b-201">これらの 2 つの CFP をマージ操作で結合し、タイムスタンプが 200 より大きく 400 以下 (2 つのファイルの結合範囲) のトランザクションを含む新しい CFP を作成します。</span><span class="sxs-lookup"><span data-stu-id="1f88b-201">The merge operation combines these two CFPs and creates a new CFP containing transactions with timestamp greater than 200 and less than or equal to 400, which is the combined range of these two CFPs.</span></span> <span data-ttu-id="1f88b-202">すると、範囲が (500, 600] のもう 1 つの CFP と、トランザクション範囲が (200, 400] の空でないデルタ ファイルが現れます。これは、マージ操作と同時に、ソース CFP から他の行を削除するといったトランザクション アクティビティを実行できることを示しています。</span><span class="sxs-lookup"><span data-stu-id="1f88b-202">You see another CFP with range (500, 600] and non-empty delta file for transaction range (200, 400] shows that merge operation can be done concurrently with transactional activity including deleting more rows from the source CFPs.</span></span>

 <span data-ttu-id="1f88b-203">![メモリ最適化テーブルのファイル グループを示す図](../../database-engine/media/storagediagram-hekaton.png "メモリ最適化テーブルのファイル グループを示す図")</span><span class="sxs-lookup"><span data-stu-id="1f88b-203">![Diagram shows memory optimized table file group](../../database-engine/media/storagediagram-hekaton.png "Diagram shows memory optimized table file group")</span></span>

 <span data-ttu-id="1f88b-204">バックグラウンド スレッドでは、閉じているすべての CFP がマージ ポリシーを使用して評価され、該当する CFP に対して 1 つ以上のマージ要求が開始されます。</span><span class="sxs-lookup"><span data-stu-id="1f88b-204">A background thread evaluates all closed CFPs using a merge policy and then initiates one or more merge requests for the qualifying CFPs.</span></span> <span data-ttu-id="1f88b-205">これらのマージ要求は、オフライン チェックポイント スレッドによって処理されます。</span><span class="sxs-lookup"><span data-stu-id="1f88b-205">These merge requests are processed by the offline checkpoint thread.</span></span> <span data-ttu-id="1f88b-206">マージ ポリシーの評価は定期的に実行され、チェックポイントが閉じられるときにも行われます。</span><span class="sxs-lookup"><span data-stu-id="1f88b-206">The evaluation of merge policy is done periodically and also when a checkpoint is closed.</span></span>

### <a name="sssql14-merge-policy"></a>[!INCLUDE[ssSQL14](../../../includes/sssql14-md.md)] <span data-ttu-id="1f88b-207">マージ ポリシー</span><span class="sxs-lookup"><span data-stu-id="1f88b-207">Merge Policy</span></span>
 [!INCLUDE[ssSQL14](../../../includes/sssql14-md.md)] <span data-ttu-id="1f88b-208">には、次のマージ ポリシーが実装されています。</span><span class="sxs-lookup"><span data-stu-id="1f88b-208">implements the following merge policy:</span></span>

-   <span data-ttu-id="1f88b-209">削除済みの行を考慮したうえで 2 つ以上の連続する CFP が統合可能であり、結果の行が適切なサイズの 1 つの CFP に収まる場合、マージがスケジュールされます。</span><span class="sxs-lookup"><span data-stu-id="1f88b-209">A merge is scheduled if 2 or more consecutive CFPs can be consolidated, after accounting for deleted rows, such that the resultant rows can fit into 1 CFP of ideal size.</span></span> <span data-ttu-id="1f88b-210">CFP の適切なサイズは次のように決定されます。</span><span class="sxs-lookup"><span data-stu-id="1f88b-210">The ideal size of CFP is determined as follows:</span></span>

    -   <span data-ttu-id="1f88b-211">コンピューターのメモリが 16G B 以下の場合は、データ ファイルは 16 MB で、デルタ ファイルは 1 MB です。</span><span class="sxs-lookup"><span data-stu-id="1f88b-211">If a computer has less than or equal to 16GB of memory, the data file is 16MB and delta file is 1MB.</span></span>

    -   <span data-ttu-id="1f88b-212">コンピューターのメモリが 16 GB を上回る場合は、データ ファイルは 128 MB で、デルタ ファイルは 16 MB です。</span><span class="sxs-lookup"><span data-stu-id="1f88b-212">If a computer has greater than 16GB of memory, the data file is 128MB and delta file is 16MB.</span></span>

-   <span data-ttu-id="1f88b-213">データ ファイルが 256 MB を上回っており、半分以上の行が削除済みの場合は、単一の CFP を自己マージすることができます。</span><span class="sxs-lookup"><span data-stu-id="1f88b-213">A single CFP can be self-merged if the data file exceeds 256 MB and more than half of the rows are deleted.</span></span> <span data-ttu-id="1f88b-214">データ ファイルは 128 MB を上回る可能性があります。たとえば、1 つのトランザクションまたは複数の同時実行トランザクションが大量の INSERT や UPDATE を実行する場合、1 つのトランザクションが複数の CFP にまたがることはできないため、適切なサイズを上回ってデータ ファイルを拡張することが強制されます。</span><span class="sxs-lookup"><span data-stu-id="1f88b-214">A data file can grow larger than 128MB if, for example, a single transaction or multiple concurrent transactions inserts or updates large amount of data, forcing the data file to grow beyond its ideal size because a transaction cannot span multiple CFPs.</span></span>

 <span data-ttu-id="1f88b-215">次に、マージ ポリシーに従った CFP のマージの例をいくつか示します。</span><span class="sxs-lookup"><span data-stu-id="1f88b-215">Here are some examples that show the CFPs that will be merged under the merge policy:</span></span>

|<span data-ttu-id="1f88b-216">隣接する CFP ソース ファイル (入力 %)</span><span class="sxs-lookup"><span data-stu-id="1f88b-216">Adjacent CFPs Source Files (% full)</span></span>|<span data-ttu-id="1f88b-217">マージ対象</span><span class="sxs-lookup"><span data-stu-id="1f88b-217">Merge Selection</span></span>|
|-------------------------------------------|---------------------|
|<span data-ttu-id="1f88b-218">CFP0 (30%)、CFP1 (50%)、CFP2 (50%)、CFP3 (90%)</span><span class="sxs-lookup"><span data-stu-id="1f88b-218">CFP0 (30%), CFP1 (50%), CFP2 (50%), CFP3 (90%)</span></span>|<span data-ttu-id="1f88b-219">(CFP0、CFP1)</span><span class="sxs-lookup"><span data-stu-id="1f88b-219">(CFP0, CFP1)</span></span><br /><br /> <span data-ttu-id="1f88b-220">CFP2 は選択されません。これを含めると、結果のデータ ファイルが適切なサイズの 100% を超えることになります。</span><span class="sxs-lookup"><span data-stu-id="1f88b-220">CFP2 is not chosen as it will make resultant data file greater than 100% of the ideal size.</span></span>|
|<span data-ttu-id="1f88b-221">CFP0 (30%)、CFP1 (20%)、CFP2 (50%)、CFP3 (10%)</span><span class="sxs-lookup"><span data-stu-id="1f88b-221">CFP0 (30%), CFP1 (20%), CFP2 (50%), CFP3 (10%)</span></span>|<span data-ttu-id="1f88b-222">(CFP0、CFP1、CFP2)。</span><span class="sxs-lookup"><span data-stu-id="1f88b-222">(CFP0, CFP1, CFP2).</span></span> <span data-ttu-id="1f88b-223">ファイルは左から選択されます。</span><span class="sxs-lookup"><span data-stu-id="1f88b-223">Files are chosen starting from left.</span></span><br /><br /> <span data-ttu-id="1f88b-224">CTP3 は選択されません。これを含めると、結果のデータ ファイルが適切なサイズの 100% を超えることになります。</span><span class="sxs-lookup"><span data-stu-id="1f88b-224">CTP3 is not chosen as it will make resultant data file greater than 100% of the ideal size.</span></span>|
|<span data-ttu-id="1f88b-225">CFP0 (80%)、CFP1 (30%)、CFP2 (10%)、CFP3 (40%)</span><span class="sxs-lookup"><span data-stu-id="1f88b-225">CFP0 (80%), CFP1 (30%), CFP2 (10%), CFP3 (40%)</span></span>|<span data-ttu-id="1f88b-226">(CFP1、CFP2、CFP3)。</span><span class="sxs-lookup"><span data-stu-id="1f88b-226">(CFP1, CFP2, CFP3).</span></span> <span data-ttu-id="1f88b-227">ファイルは左から選択されます。</span><span class="sxs-lookup"><span data-stu-id="1f88b-227">Files are chosen starting from left.</span></span><br /><br /> <span data-ttu-id="1f88b-228">CFP0 はスキップされます。これを CFP1 と結合すると、結果のデータ ファイルが適切なサイズの 100% を超えることになるためです。</span><span class="sxs-lookup"><span data-stu-id="1f88b-228">CFP0 is skipped because if combined with CFP1, the resultant data file will be greater than 100% of the ideal size.</span></span>|

 <span data-ttu-id="1f88b-229">空き領域のある CFP がすべてマージに適合するとは限りません。</span><span class="sxs-lookup"><span data-stu-id="1f88b-229">Not all CFPs with available space qualify for merge.</span></span> <span data-ttu-id="1f88b-230">たとえば、2 つの隣接する CFP の入力率が 60% の場合、これらはマージの対象にならないため、各 CFP の 40% のストレージは未使用になります。</span><span class="sxs-lookup"><span data-stu-id="1f88b-230">For example, if two adjacent CFPs are 60% full, they will not qualify for merge and each of these CFPs will have 40% storage unused.</span></span> <span data-ttu-id="1f88b-231">最悪のケースは、すべての CFP の入力率が 50% になり、ストレージが 50% しか使用されない場合です。</span><span class="sxs-lookup"><span data-stu-id="1f88b-231">In the worst case, all CFPs will be 50% full, a storage utilization of only 50%.</span></span> <span data-ttu-id="1f88b-232">CFP がマージ対象にならず、削除済みの行がストレージに存在していても、それらの削除済みの行は、インメモリ ガベージ コレクションによって既にメモリからは削除されている場合があります。</span><span class="sxs-lookup"><span data-stu-id="1f88b-232">While the deleted rows may exist in storage because the CFPs don't qualify for merge, the deleted rows may have already been removed from memory by in-memory garbage collection.</span></span> <span data-ttu-id="1f88b-233">ストレージとメモリの管理は、ガベージ コレクションから独立しています。</span><span class="sxs-lookup"><span data-stu-id="1f88b-233">The management of storage and the memory is independent from garbage collection.</span></span> <span data-ttu-id="1f88b-234">アクティブな CFP (すべての CFP が更新されるわけではありません) から取得されたストレージは、最大でメモリ内の持続性のあるテーブルのサイズの 2 倍になる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="1f88b-234">Storage taken by active CFPs (not all CFPs are being updated) can be up to 2 times larger than the size of durable tables in memory.</span></span>

 <span data-ttu-id="1f88b-235">必要に応じて、手動マージは、 [sp_xtp_merge_checkpoint_files &#40;transact-sql&#41;](/sql/relational-databases/system-stored-procedures/sys-sp-xtp-merge-checkpoint-files-transact-sql)を呼び出すことによって明示的に実行できます。</span><span class="sxs-lookup"><span data-stu-id="1f88b-235">If needed, a manual merge can be explicitly performed by calling [sys.sp_xtp_merge_checkpoint_files &#40;Transact-SQL&#41;](/sql/relational-databases/system-stored-procedures/sys-sp-xtp-merge-checkpoint-files-transact-sql).</span></span>

### <a name="life-cycle-of-a-cfp"></a><span data-ttu-id="1f88b-236">CFP のライフ サイクル</span><span class="sxs-lookup"><span data-stu-id="1f88b-236">Life Cycle of a CFP</span></span>
 <span data-ttu-id="1f88b-237">CPF は、割り当てが解除されるまでにいくつかの状態を遷移します。</span><span class="sxs-lookup"><span data-stu-id="1f88b-237">CPFs transition through several states before they can be deallocated.</span></span> <span data-ttu-id="1f88b-238">どの時点でも、CFP は次のフェーズのいずれかにあります。PRECREATED、UNDER CONSTRUCTION、ACTIVE、MERGE TARGET、MERGED SOURCE、REQUIRED FOR BACKUP/HA、IN TRANSITION TO TOMBSTONE、および TOMBSTONE。</span><span class="sxs-lookup"><span data-stu-id="1f88b-238">At any given time, the CFPs are in one of the following phases: PRECREATED, UNDER CONSTRUCTION, ACTIVE, MERGE TARGET, MERGED SOURCE, REQUIRED FOR BACKUP/HA, IN TRANSITION TO TOMBSTONE, and TOMBSTONE.</span></span> <span data-ttu-id="1f88b-239">これらのフェーズの説明については、「[sys.dm_db_xtp_checkpoint_files &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-xtp-checkpoint-files-transact-sql)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1f88b-239">For a description of these phases, see [sys.dm_db_xtp_checkpoint_files &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-xtp-checkpoint-files-transact-sql).</span></span>

 <span data-ttu-id="1f88b-240">さまざまな状態にある CFP によって取得されるストレージを考慮に入れると、持続性のあるメモリ最適化テーブルによって取得されるストレージ全体のサイズは、メモリ内のテーブルのサイズの 2 倍を大きく超える可能性があります。</span><span class="sxs-lookup"><span data-stu-id="1f88b-240">After accounting for the storage taken by CFPs in various states, the overall storage taken by durable memory-optimized tables can be much larger than 2 times the size of the tables in memory.</span></span> <span data-ttu-id="1f88b-241">[&#40;transact-sql&#41;DM_DB_XTP_CHECKPOINT_FILES](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-xtp-checkpoint-files-transact-sql) DMV を照会して、メモリ最適化ファイルグループ内のすべての cfps (フェーズを含む) を一覧表示することができます。</span><span class="sxs-lookup"><span data-stu-id="1f88b-241">The DMV [sys.dm_db_xtp_checkpoint_files &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-xtp-checkpoint-files-transact-sql) can be queried to list all the CFPs in the memory-optimized filegroup, including their phase.</span></span> <span data-ttu-id="1f88b-242">CFP を MERGE SOURCE 状態から TOMBSTONE に移行すると、ガベージ コレクションが最終的に 5 個のチェックポイントを使用する可能性があり、データベースが完全復旧モデルまたは一括ログ復旧モデルを使用するように構成されている場合は、各チェックポイントの後にトランザクション ログ バックアップが続きます。</span><span class="sxs-lookup"><span data-stu-id="1f88b-242">Transitioning CFPs from MERGE SOURCE state to TOMBSTONE and ultimately garbage collection can take up five checkpoints, with each checkpoint followed by a transaction log backup, if the database is configured for full or bulk-logged recovery model.</span></span>

 <span data-ttu-id="1f88b-243">手動でチェックポイントとログのバックアップを強制してガベージ コレクションを早めることもできますが、その場合は 5 つの空の CFP (データ ファイルとデルタ ファイルのペアが 5 つ、各データ ファイルのサイズは 128 MB) が追加されます。</span><span class="sxs-lookup"><span data-stu-id="1f88b-243">You can manually force the checkpoint followed by log backup to expedite the garbage collection but then this will add 5 empty CFPs (5 data/delta file pairs with data file of size 128MB each).</span></span> <span data-ttu-id="1f88b-244">実稼動環境のシナリオでは、バックアップ方法の一環として実行される自動チェックポイントとログ バックアップにより、CFP はこれらのフェーズをシームレスに移行し、手動による操作は必要ありません。</span><span class="sxs-lookup"><span data-stu-id="1f88b-244">In production scenarios, the automatic checkpoints and log backups taken as part of backup strategy will seamlessly transition CFPs through these phases without requiring any manual intervention.</span></span> <span data-ttu-id="1f88b-245">ガベージ コレクション プロセスが実行されると、その影響として、メモリ最適化テーブルのあるデータベースのストレージ サイズがメモリ内のサイズに比べて大きくなる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="1f88b-245">The impact of the garbage collection process is that databases with memory-optimized tables may have a larger storage size compared to its size in memory.</span></span> <span data-ttu-id="1f88b-246">CFP にとって、持続性のあるメモリ最適化テーブルのサイズがメモリ内サイズの 4 倍までになるのは珍しいことではありません。</span><span class="sxs-lookup"><span data-stu-id="1f88b-246">It is not uncommon for CFPs to be up to four times the size of the durable memory-optimized tables in memory.</span></span>

## <a name="see-also"></a><span data-ttu-id="1f88b-247">参照</span><span class="sxs-lookup"><span data-stu-id="1f88b-247">See Also</span></span>
 [<span data-ttu-id="1f88b-248">メモリ最適化オブジェクト用ストレージの作成と管理</span><span class="sxs-lookup"><span data-stu-id="1f88b-248">Creating and Managing Storage for Memory-Optimized Objects</span></span>](creating-and-managing-storage-for-memory-optimized-objects.md)


