---
title: メモリ最適化テーブルの復元と復旧 | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: 294975b7-e7d1-491b-b66a-fdb1100d2acc
author: CarlRabeler
ms.author: carlrab
ms.openlocfilehash: 5e702798ea68745a038407fb65af7726a5c5d50e
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/04/2020
ms.locfileid: "87643336"
---
# <a name="restore-and-recovery-of-memory-optimized-tables"></a><span data-ttu-id="12313-102">メモリ最適化テーブルの復元と復旧</span><span class="sxs-lookup"><span data-stu-id="12313-102">Restore and Recovery of Memory-Optimized Tables</span></span>
  <span data-ttu-id="12313-103">メモリ最適化テーブルを含むデータベースを回復または復元する基本的なメカニズムは、ディスク ベース テーブルのみを含むデータベースのメカニズムに似ています。</span><span class="sxs-lookup"><span data-stu-id="12313-103">The basic mechanism to recover or restore a database with memory-optimized tables is similar to databases with only disk-based tables.</span></span> <span data-ttu-id="12313-104">ただし、ディスク ベース テーブルとは異なり、メモリ最適化テーブルは、データベースがユーザー アクセスに使用できるようになる前にメモリに読み込まれる必要があります。</span><span class="sxs-lookup"><span data-stu-id="12313-104">But unlike disk-based tables, memory-optimized tables must be loaded into memory before database is available for user access.</span></span> <span data-ttu-id="12313-105">データベース復旧の新しい手順が追加されます。</span><span class="sxs-lookup"><span data-stu-id="12313-105">This adds a new step in the database recovery.</span></span> <span data-ttu-id="12313-106">データベース復旧の手順は次のように変更されます:</span><span class="sxs-lookup"><span data-stu-id="12313-106">The modified steps in database recovery are changed as follows:</span></span>

 <span data-ttu-id="12313-107">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] が再起動すると、各データベースは次の 3 つのフェーズで構成される復旧フェーズを経由します:</span><span class="sxs-lookup"><span data-stu-id="12313-107">When the [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] restarts, each database goes through a recovery phase that consists of the following three phases:</span></span>

1.  <span data-ttu-id="12313-108">分析フェーズ。</span><span class="sxs-lookup"><span data-stu-id="12313-108">The analysis phase.</span></span> <span data-ttu-id="12313-109">このフェーズでは、コミットされたトランザクションとコミットされていないトランザクションを検出するために、アクティブなトランザクション ログにパスが行われます。</span><span class="sxs-lookup"><span data-stu-id="12313-109">During this phase, a pass is made on the active transaction logs to detect committed and uncommitted transactions.</span></span> <span data-ttu-id="12313-110">インメモリ OLTP エンジンは読み込むチェックポイントを識別し、システム テーブルのログ エントリを再度読み込みます。</span><span class="sxs-lookup"><span data-stu-id="12313-110">The In-Memory OLTP engine identifies the checkpoint to load and preloads its system table log entries.</span></span> <span data-ttu-id="12313-111">また、ファイル割り当てログ レコードの一部を処理します。</span><span class="sxs-lookup"><span data-stu-id="12313-111">It will also process some file allocation log records.</span></span>

2.  <span data-ttu-id="12313-112">再実行フェーズ。</span><span class="sxs-lookup"><span data-stu-id="12313-112">The redo phase.</span></span> <span data-ttu-id="12313-113">このフェーズは、ディスク ベース テーブルおよびメモリ最適化テーブルで同時に実行されます。</span><span class="sxs-lookup"><span data-stu-id="12313-113">This phase is run concurrently on both disk-based and memory-optimized tables.</span></span>

     <span data-ttu-id="12313-114">ディスク ベース テーブルの場合、データベースが現在の状態に移動され、コミットされていないトランザクションに使用されたロックを取得します。</span><span class="sxs-lookup"><span data-stu-id="12313-114">For disk-based tables, the database is moved to the current point in time and acquires locks taken by uncommitted transactions.</span></span>

     <span data-ttu-id="12313-115">メモリ最適化テーブルの場合、データ ファイルとデルタ ファイルのペアからのデータがメモリに読み込まれ、次に、持続性を備えた最後のチェックポイントに基づいてアクティブなトランザクション ログを含むデータが更新されます。</span><span class="sxs-lookup"><span data-stu-id="12313-115">For memory-optimized tables, data from the data and delta file pairs are loaded into memory and then update the data with the active transaction log based on the last durable checkpoint.</span></span>

     <span data-ttu-id="12313-116">上のディスク ベース テーブルおよびメモリ最適化テーブルでの操作が完了すると、データベースにアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="12313-116">When the above operations on disk-based and memory-optimized tables are complete, the database is available for access.</span></span>

3.  <span data-ttu-id="12313-117">元に戻すフェーズ。</span><span class="sxs-lookup"><span data-stu-id="12313-117">The undo phase.</span></span> <span data-ttu-id="12313-118">このフェーズでは、コミットされていないトランザクションはロールバックされます。</span><span class="sxs-lookup"><span data-stu-id="12313-118">In this phase, the uncommitted transactions are rolled back.</span></span>

 <span data-ttu-id="12313-119">メモリ最適化テーブルをメモリに読み込むと、目標復旧時間 (RTO) のパフォーマンスに影響する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="12313-119">Loading memory-optimized tables into memory can affect performance of the recovery time objective (RTO).</span></span> <span data-ttu-id="12313-120">データ ファイルおよびデルタ ファイルからメモリ最適化データを読み込む時間を短縮するために、インメモリ OLTP エンジンは次のように並行してデータ ファイルおよびデルタ ファイルを読み込みます。</span><span class="sxs-lookup"><span data-stu-id="12313-120">To improve the load time of memory-optimized data from data and delta files, the In-Memory OLTP engine loads the data/delta files in parallel as follows:</span></span>

-   <span data-ttu-id="12313-121">デルタ マップ フィルターの作成。</span><span class="sxs-lookup"><span data-stu-id="12313-121">Creating a Delta Map Filter.</span></span> <span data-ttu-id="12313-122">デルタ ファイル ストアは、削除された行を参照します。</span><span class="sxs-lookup"><span data-stu-id="12313-122">Delta files store references to the deleted rows.</span></span> <span data-ttu-id="12313-123">コンテナーごとに 1 行のスレッドがデルタ ファイルを読み取り、デルタ マップ フィルターを作成します。</span><span class="sxs-lookup"><span data-stu-id="12313-123">One thread per container reads the delta files and creates a delta map filter.</span></span> <span data-ttu-id="12313-124">(メモリ最適化データ ファイル グループには、1 つ以上のコンテナーを保持できます。)</span><span class="sxs-lookup"><span data-stu-id="12313-124">(A memory optimized data filegroup can have one or more containers.)</span></span>

-   <span data-ttu-id="12313-125">データ ファイルのストリーミング。</span><span class="sxs-lookup"><span data-stu-id="12313-125">Streaming the data files.</span></span>  <span data-ttu-id="12313-126">デルタマップ フィルターが作成されると、データ ファイルは論理 CPU と同数のスレッドを使用して読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="12313-126">Once the delta-map filter is created, data files are read using as many threads as there are logical CPUs.</span></span> <span data-ttu-id="12313-127">データ ファイルを読み込む各スレッドはデータ行を読み込み、関連付けられたデルタ マップを確認し、この行が削除済みとしてマークされていない場合は行の挿入のみを行います。</span><span class="sxs-lookup"><span data-stu-id="12313-127">Each thread reading the data file reads the data rows, checks the associated delta map and only inserts the row into table if this row has not been marked deleted.</span></span> <span data-ttu-id="12313-128">復旧のこの部分は、以下で説明するように CPU バインドとなる場合があります。</span><span class="sxs-lookup"><span data-stu-id="12313-128">This part of recovery can be CPU bound in some cases as noted below.</span></span>

 <span data-ttu-id="12313-129">![メモリ最適化テーブル。](../../database-engine/media/memory-optimized-tables.gif "メモリが最適化されたテーブル。")</span><span class="sxs-lookup"><span data-stu-id="12313-129">![Memory-optimized tables.](../../database-engine/media/memory-optimized-tables.gif "Memory-optimized tables.")</span></span>

 <span data-ttu-id="12313-130">通常、メモリ最適化テーブルは I/O の速度でメモリに読み込むことができますが、データ行をメモリに読み込むときは時間がかかる場合があります。</span><span class="sxs-lookup"><span data-stu-id="12313-130">Memory-optimized tables can generally be loaded into memory at the speed of I/O but there are cases when loading data rows into memory will be slower.</span></span> <span data-ttu-id="12313-131">特定の場合を次に示します:</span><span class="sxs-lookup"><span data-stu-id="12313-131">Specific cases are:</span></span>

-   <span data-ttu-id="12313-132">ハッシュ インデックスのバケット数が少ない場合は、過剰な競合が発生してデータ行の挿入に時間がかかる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="12313-132">Low bucket count for hash index can lead to excessive collision causing data row inserts to be slower.</span></span> <span data-ttu-id="12313-133">通常、これは、特に復旧の最後にかけて、常に高い CPU 使用率において発生します。</span><span class="sxs-lookup"><span data-stu-id="12313-133">This generally results in very high CPU utilization throughout, and especially towards the end of recovery.</span></span> <span data-ttu-id="12313-134">ハッシュ インデックスを正しく構成していれば、復旧時間に影響することはありません。</span><span class="sxs-lookup"><span data-stu-id="12313-134">If you configured the hash index correctly, it should not impact the recovery time.</span></span>

-   <span data-ttu-id="12313-135">作成時にバケット数がサイズ調整されるハッシュ インデックスとは異なり、1 つ以上の非クラスター化インデックスを含む大きなメモリ最適化テーブルは、非クラスター化インデックスが動的に拡張し、結果として CPU の使用率が高くなります。</span><span class="sxs-lookup"><span data-stu-id="12313-135">Large memory-optimized tables with one or more nonclustered indexes, unlike a hash index whose bucket count is sized at create time, the nonclustered indexes grow dynamically, resulting in high CPU utilization.</span></span>

## <a name="restoring-a-database-with-memory-optimized-tables"></a><span data-ttu-id="12313-136">メモリ最適化テーブルを使用したデータベースの復元</span><span class="sxs-lookup"><span data-stu-id="12313-136">Restoring a Database with Memory-optimized tables</span></span>
 <span data-ttu-id="12313-137">データベースを復元するのに十分なメモリがサーバーにある場合でも、データベースで必要とされるメモリは既存のリソース プールの一部として見なされます。</span><span class="sxs-lookup"><span data-stu-id="12313-137">You know that you have sufficient memory on the server to restore a database, but there's a requirement  that the memory needed by the database is accounted for as part of an existing Resource Pool.</span></span>  <span data-ttu-id="12313-138">データベースが存在する前にリソース プールへのバインドを作成することはできません。そこで、RESTORE WITH NORECOVERY を実行します。</span><span class="sxs-lookup"><span data-stu-id="12313-138">You know that you cannot create the binding to the resource pool before the database exists, so you perform the restore WITH NORECOVERY.</span></span>  <span data-ttu-id="12313-139">これにより、データベースのディスク イメージが復元され、データベースが作成されますが、データベースがオンラインになっていないため、インメモリ OLTP メモリは使用されません。</span><span class="sxs-lookup"><span data-stu-id="12313-139">This causes the disk image of the database to be restored and the database to be created, but no In-Memory OLTP memory is consumed because the database is not brought online.</span></span>

 <span data-ttu-id="12313-140">この時点で、リソース プールとデータベースのバインドを作成し、RESTORE WITH RECOVERY を使用して復元されたデータベースをオンラインにできます。</span><span class="sxs-lookup"><span data-stu-id="12313-140">At this point, you can create the Resource Pool to Database binding, and then use RESTORE WITH RECOVERY to bring the restored database online.</span></span>  <span data-ttu-id="12313-141">データベースがオンラインに設定される前にバインドが設定されたため、インメモリ OLTP メモリの使用が正しく反映されます。</span><span class="sxs-lookup"><span data-stu-id="12313-141">Since the binding is in place before the database is brought online, its In-Memory OLTP memory consumption is properly accounted for.</span></span> <span data-ttu-id="12313-142">これには、1 回だけデータベースを復元する必要があります。</span><span class="sxs-lookup"><span data-stu-id="12313-142">This requires restoring the database only once.</span></span> <span data-ttu-id="12313-143">最初の RESTORE コマンドは、バックアップ ヘッダーのみを読み取る情報取得コマンドです。最後のコマンドは、復元を実行しない、単に回復をトリガーするコマンドです。</span><span class="sxs-lookup"><span data-stu-id="12313-143">The first RESTORE command is an informational command that only reads the backup header, and the last command simply triggers recovery without actually restoring any bits.</span></span>

## <a name="see-also"></a><span data-ttu-id="12313-144">参照</span><span class="sxs-lookup"><span data-stu-id="12313-144">See Also</span></span>
 [<span data-ttu-id="12313-145">メモリ最適化テーブルのバックアップ、復元、復旧</span><span class="sxs-lookup"><span data-stu-id="12313-145">Backup, Restore, and Recovery of Memory-Optimized Tables</span></span>](memory-optimized-tables.md)


