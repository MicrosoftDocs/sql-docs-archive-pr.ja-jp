---
title: メモリ最適化テーブルの概要 | Microsoft Docs
ms.custom: ''
ms.date: 07/14/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: ef1cc7de-63be-4fa3-a622-6d93b440e3ac
author: rothja
ms.author: jroth
ms.openlocfilehash: edcdea9d266cf0ef231b1e16be4da7009372dcd6
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/04/2020
ms.locfileid: "87742102"
---
# <a name="introduction-to-memory-optimized-tables"></a><span data-ttu-id="cd8df-102">メモリ最適化テーブルの概要</span><span class="sxs-lookup"><span data-stu-id="cd8df-102">Introduction to Memory-Optimized Tables</span></span>
  <span data-ttu-id="cd8df-103">メモリ最適化テーブルは、[CREATE TABLE &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-table-transact-sql) を使用して作成されるテーブルです。</span><span class="sxs-lookup"><span data-stu-id="cd8df-103">Memory-optimized tables are tables, created using [CREATE TABLE &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-table-transact-sql).</span></span>  
  
 <span data-ttu-id="cd8df-104">メモリ最適化テーブルはメモリ内に存在します。</span><span class="sxs-lookup"><span data-stu-id="cd8df-104">Memory-optimized tables reside in memory.</span></span> <span data-ttu-id="cd8df-105">テーブルの行は、メモリから読み込まれ、メモリに書き込まれます。</span><span class="sxs-lookup"><span data-stu-id="cd8df-105">Rows in the table are read from and written to memory.</span></span> <span data-ttu-id="cd8df-106">テーブル全体もメモリに存在します。</span><span class="sxs-lookup"><span data-stu-id="cd8df-106">The entire table resides in memory.</span></span> <span data-ttu-id="cd8df-107">ディスク上にはテーブル データの 2 番目のコピーが保持されますが、持続性を実現するためのものにすぎません。</span><span class="sxs-lookup"><span data-stu-id="cd8df-107">A second copy of the table data is maintained on disk, but only for durability purposes.</span></span>  
  
 <span data-ttu-id="cd8df-108">インメモリ OLTP は、開発、配置、管理、サポートなど、すべての領域においてシームレスな使用環境を提供するために、 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] と統合されています。</span><span class="sxs-lookup"><span data-stu-id="cd8df-108">In-Memory OLTP is integrated with [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] to provide a seamless experience in all areas such as development, deployment, manageability, and supportability.</span></span> <span data-ttu-id="cd8df-109">データベースには、ディスク ベースのオブジェクトと同様にインメモリのオブジェクトを含めることができます。</span><span class="sxs-lookup"><span data-stu-id="cd8df-109">A database can contain in-memory as well as disk-based objects.</span></span>  
  
 <span data-ttu-id="cd8df-110">メモリ最適化テーブル内の行には、バージョンが付いています。</span><span class="sxs-lookup"><span data-stu-id="cd8df-110">Rows in memory-optimized tables are versioned.</span></span> <span data-ttu-id="cd8df-111">これは、テーブルの各行に複数のバージョンが存在する可能性があることを意味します。</span><span class="sxs-lookup"><span data-stu-id="cd8df-111">This means that each row in the table potentially has multiple versions.</span></span> <span data-ttu-id="cd8df-112">行バージョンはいずれも、同じテーブル データ構造で保持されます。</span><span class="sxs-lookup"><span data-stu-id="cd8df-112">All row versions are maintained in the same table data structure.</span></span> <span data-ttu-id="cd8df-113">行のバージョン管理は、同じ行に対して読み取りと書き込みを同時に実行できるようにするために使用します。</span><span class="sxs-lookup"><span data-stu-id="cd8df-113">Row versioning is used to allow concurrent reads and writes on the same row.</span></span> <span data-ttu-id="cd8df-114">同じ行での同時読み取りと書き込みの詳細については、「[メモリ最適化テーブルのトランザクション](memory-optimized-tables.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="cd8df-114">For more information about concurrent reads and writes on the same row, see [Transactions in Memory-Optimized Tables](memory-optimized-tables.md).</span></span>  
  
 <span data-ttu-id="cd8df-115">次の図は、複数バージョン管理について説明したものです。</span><span class="sxs-lookup"><span data-stu-id="cd8df-115">The following figure illustrates multi-versioning.</span></span> <span data-ttu-id="cd8df-116">この図では、行が 3 つあるテーブルを示しています。行のそれぞれに、バージョンが複数存在します。</span><span class="sxs-lookup"><span data-stu-id="cd8df-116">The figure shows a table with three rows and each row has different versions.</span></span>  
  
 <span data-ttu-id="cd8df-117">![複数バージョン管理](../../database-engine/media/hekaton-tables-1.gif "複数バージョン管理")</span><span class="sxs-lookup"><span data-stu-id="cd8df-117">![Multi-versioning.](../../database-engine/media/hekaton-tables-1.gif "Multi-versioning.")</span></span>  
  
 <span data-ttu-id="cd8df-118">テーブルには、r1、r2、および r3 の 3 行があります。</span><span class="sxs-lookup"><span data-stu-id="cd8df-118">The table has three rows: r1, r2, and r3.</span></span> <span data-ttu-id="cd8df-119">r1 には 3 つ、r2 には 2 つ、r3 には 4 つのバージョンがあります。</span><span class="sxs-lookup"><span data-stu-id="cd8df-119">r1 has three versions, r2 has two versions, and r3 has four versions.</span></span> <span data-ttu-id="cd8df-120">同じ行に複数のバージョンがある場合にも、メモリ上の場所が連続しているとは限らないことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="cd8df-120">Note that different versions of the same row do not necessarily occupy consecutive memory locations.</span></span> <span data-ttu-id="cd8df-121">バージョンの異なる行がテーブル データ構造のさまざまな場所に分散して配置されていることもあります。</span><span class="sxs-lookup"><span data-stu-id="cd8df-121">The different row versions can be dispersed throughout the table data structure.</span></span>  
  
 <span data-ttu-id="cd8df-122">メモリ最適化テーブルのデータ構造は、行バージョンのコレクションと考えることができます。</span><span class="sxs-lookup"><span data-stu-id="cd8df-122">The memory-optimized table data structure can be seen as a collection of row versions.</span></span> <span data-ttu-id="cd8df-123">ディスク ベース テーブルの行がページとエクステントによって整理され、個々の行がページ番号とページ オフセットでアドレス指定されているのに対して、メモリ最適化テーブルの行バージョンは、8 バイトのメモリ ポインターを使用してアドレスが指定されています。</span><span class="sxs-lookup"><span data-stu-id="cd8df-123">Rows in disk-based tables are organized in pages and extents, and individual rows addressed using page number and page offset, row versions in memory-optimized tables are addressed using 8-byte memory pointers.</span></span>  
  
## <a name="durability"></a><span data-ttu-id="cd8df-124">Durability</span><span class="sxs-lookup"><span data-stu-id="cd8df-124">Durability</span></span>  
 <span data-ttu-id="cd8df-125">メモリ最適化テーブルには既定で完全持続性があり、メモリ最適化テーブルに対する完全持続性トランザクションは、(従来の) ディスクベース テーブルのトランザクションと同様に、完全なアトミック性、一貫性、分離性、持続性 (ACID) を備えています。</span><span class="sxs-lookup"><span data-stu-id="cd8df-125">Memory-optimized tables are fully durable by default, and, like transactions on (traditional) disk-based tables, fully durable transactions on memory-optimized tables are fully atomic, consistent, isolated, and durable (ACID).</span></span> <span data-ttu-id="cd8df-126">メモリ最適化テーブルおよびネイティブ コンパイル ストアド プロシージャは [!INCLUDE[tsql](../../../includes/tsql-md.md)]のサブセットをサポートします。</span><span class="sxs-lookup"><span data-stu-id="cd8df-126">Memory-optimized tables and natively compiled stored procedures support a subset of [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span></span>  
  
 <span data-ttu-id="cd8df-127">インメモリ OLTP ではトランザクションの持続性が遅延している状態の持続性テーブルがサポートされます。</span><span class="sxs-lookup"><span data-stu-id="cd8df-127">In-Memory OLTP supports durable tables with transaction durability delayed.</span></span> <span data-ttu-id="cd8df-128">遅延持続性トランザクションは、トランザクションがコミットした後すぐにディスクに保存されます。</span><span class="sxs-lookup"><span data-stu-id="cd8df-128">Delayed durable transactions are saved to disk soon after the transaction has committed.</span></span> <span data-ttu-id="cd8df-129">ディスクに保存せずにコミットされたトランザクションは、パフォーマンスは向上しますが、サーバー クラッシュまたはフェールオーバー時に失われてしまいます。</span><span class="sxs-lookup"><span data-stu-id="cd8df-129">In exchange for the increased performance, committed transactions that have not saved to disk are lost in a server crash or failover.</span></span>  
  
 <span data-ttu-id="cd8df-130">既定の持続性を持つメモリ最適化テーブルだけでなく、 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] は、記録やディスクへのデータ保存が行われない持続性のないメモリ最適化テーブルをサポートします。</span><span class="sxs-lookup"><span data-stu-id="cd8df-130">Besides the default durable memory-optimized tables, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] also supports non-durable memory-optimized tables, which are not logged and their data is not persisted on disk.</span></span> <span data-ttu-id="cd8df-131">つまり、これらのテーブルのトランザクションはディスク IO を必要としませんが、サーバーのクラッシュまたはフェールオーバーが発生した場合、データを復旧できません。</span><span class="sxs-lookup"><span data-stu-id="cd8df-131">This means that transactions on these tables do not require any disk IO, but the data will not be recovered if there is a server crash or failover.</span></span>  
  
## <a name="accessing-data-in-memory-optimized-tables"></a><span data-ttu-id="cd8df-132">メモリ最適化テーブルのデータへのアクセス</span><span class="sxs-lookup"><span data-stu-id="cd8df-132">Accessing Data in Memory-Optimized Tables</span></span>  
 <span data-ttu-id="cd8df-133">メモリ最適化テーブルのデータには、次の 2 つの方法でアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="cd8df-133">Data in memory-optimized tables is accessed in two ways:</span></span>  
  
-   <span data-ttu-id="cd8df-134">[!INCLUDE[tsql](../../../includes/tsql-md.md)](ネイティブコンパイルストアドプロシージャの外部で) 解釈されます。</span><span class="sxs-lookup"><span data-stu-id="cd8df-134">Through interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] (outside of a natively-compiled stored procedure).</span></span> <span data-ttu-id="cd8df-135">これらの [!INCLUDE[tsql](../../../includes/tsql-md.md)] ステートメントは、解釈されたストアド プロシージャ内にあっても、アドホック [!INCLUDE[tsql](../../../includes/tsql-md.md)] ステートメントであってもかまいません。</span><span class="sxs-lookup"><span data-stu-id="cd8df-135">These [!INCLUDE[tsql](../../../includes/tsql-md.md)] statements may be either inside interpreted stored procedures or they may be ad-hoc [!INCLUDE[tsql](../../../includes/tsql-md.md)] statements.</span></span>  
  
-   <span data-ttu-id="cd8df-136">ネイティブ コンパイル ストアド プロシージャを経由してアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="cd8df-136">Through natively compiled stored procedures.</span></span>  
  
 <span data-ttu-id="cd8df-137">メモリ最適化テーブルには、ネイティブ コンパイル ストアド プロシージャ (「[ネイティブ コンパイル ストアド プロシージャ](natively-compiled-stored-procedures.md)」) からアクセスするのが最も効率的です。</span><span class="sxs-lookup"><span data-stu-id="cd8df-137">Memory-optimized tables can be accessed most efficiently from natively compiled stored procedures ([Natively Compiled Stored Procedures](natively-compiled-stored-procedures.md)).</span></span> <span data-ttu-id="cd8df-138">メモリ最適化テーブルのデータには、(従来の) 解釈された [!INCLUDE[tsql](../../../includes/tsql-md.md)]でもアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="cd8df-138">Memory-optimized tables can also be accessed with (traditional) interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span></span> <span data-ttu-id="cd8df-139">解釈された [!INCLUDE[tsql](../../../includes/tsql-md.md)] とは、ネイティブ コンパイル ストアド プロシージャを使用せずにメモリ最適化テーブルにアクセスすることを表します。</span><span class="sxs-lookup"><span data-stu-id="cd8df-139">Interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] refers to accessing memory-optimized tables without a natively compiled stored procedure.</span></span> <span data-ttu-id="cd8df-140">解釈された [!INCLUDE[tsql](../../../includes/tsql-md.md)] アクセスの例として、DML トリガー、アドホック [!INCLUDE[tsql](../../../includes/tsql-md.md)] バッチ、ビュー、およびテーブル値関数からのメモリ最適化テーブルへのアクセスがあります。</span><span class="sxs-lookup"><span data-stu-id="cd8df-140">Some examples of interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] access include accessing a memory-optimized table from a DML trigger, ad hoc [!INCLUDE[tsql](../../../includes/tsql-md.md)] batch, view, and table-valued function.</span></span>  
  
 <span data-ttu-id="cd8df-141">次の表に、さまざまなオブジェクトへのネイティブ アクセスおよび解釈された [!INCLUDE[tsql](../../../includes/tsql-md.md)] アクセスを示します。</span><span class="sxs-lookup"><span data-stu-id="cd8df-141">The following table summarizes native and interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] access for various objects.</span></span>  
  
|<span data-ttu-id="cd8df-142">特徴量</span><span class="sxs-lookup"><span data-stu-id="cd8df-142">Feature</span></span>|<span data-ttu-id="cd8df-143">ネイティブ コンパイル ストアド プロシージャを使用したアクセス</span><span class="sxs-lookup"><span data-stu-id="cd8df-143">Access Using a Natively Compiled Stored Procedure</span></span>|<span data-ttu-id="cd8df-144">解釈された [!INCLUDE[tsql](../../../includes/tsql-md.md)] アクセス</span><span class="sxs-lookup"><span data-stu-id="cd8df-144">Interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] Access</span></span>|<span data-ttu-id="cd8df-145">CLR アクセス</span><span class="sxs-lookup"><span data-stu-id="cd8df-145">CLR Access</span></span>|  
|-------------|-------------------------------------------------------|-------------------------------------------|----------------|  
|<span data-ttu-id="cd8df-146">メモリ最適化テーブル</span><span class="sxs-lookup"><span data-stu-id="cd8df-146">Memory-optimized tables</span></span>|<span data-ttu-id="cd8df-147">はい</span><span class="sxs-lookup"><span data-stu-id="cd8df-147">Yes</span></span>|<span data-ttu-id="cd8df-148">[はい]</span><span class="sxs-lookup"><span data-stu-id="cd8df-148">Yes</span></span>|<span data-ttu-id="cd8df-149">いいえ <sup>1</sup></span><span class="sxs-lookup"><span data-stu-id="cd8df-149">No <sup>1</sup></span></span>|  
|[<span data-ttu-id="cd8df-150">メモリ最適化テーブル変数</span><span class="sxs-lookup"><span data-stu-id="cd8df-150">Memory-Optimized Table Variables</span></span>](../../database-engine/memory-optimized-table-variables.md)|<span data-ttu-id="cd8df-151">はい</span><span class="sxs-lookup"><span data-stu-id="cd8df-151">Yes</span></span>|<span data-ttu-id="cd8df-152">[はい]</span><span class="sxs-lookup"><span data-stu-id="cd8df-152">Yes</span></span>|<span data-ttu-id="cd8df-153">いいえ</span><span class="sxs-lookup"><span data-stu-id="cd8df-153">No</span></span>|  
|[<span data-ttu-id="cd8df-154">ネイティブ コンパイル ストアド プロシージャ</span><span class="sxs-lookup"><span data-stu-id="cd8df-154">Natively Compiled Stored Procedures</span></span>](https://msdn.microsoft.com/library/dn133184.aspx)|<span data-ttu-id="cd8df-155">EXECUTE ステートメントを使用してネイティブ コンパイル ストアド プロシージャからストアド プロシージャを実行することはできません。</span><span class="sxs-lookup"><span data-stu-id="cd8df-155">You cannot use the EXECUTE statement to execute any stored procedure from a natively compiled stored procedure.</span></span>|<span data-ttu-id="cd8df-156">はい</span><span class="sxs-lookup"><span data-stu-id="cd8df-156">Yes</span></span>|<span data-ttu-id="cd8df-157">いいえ <sup>1</sup></span><span class="sxs-lookup"><span data-stu-id="cd8df-157">No <sup>1</sup></span></span>|  
  
 <span data-ttu-id="cd8df-158"><sup>1</sup>コンテキスト接続 ( [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] CLR モジュールを実行するときのからの接続) からメモリ最適化テーブルまたはネイティブコンパイルストアドプロシージャにアクセスすることはできません。</span><span class="sxs-lookup"><span data-stu-id="cd8df-158"><sup>1</sup> You cannot access a memory-optimized table or natively compiled stored procedure from the context connection (the connection from [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] when executing a CLR module).</span></span> <span data-ttu-id="cd8df-159">ただし、別の接続を作成して開き、そこからメモリ最適化テーブルおよびネイティブ コンパイル ストアド プロシージャにアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="cd8df-159">You can, however, create and open another connection from which you can access memory-optimized tables and natively compiled stored procedures.</span></span> <span data-ttu-id="cd8df-160">詳細については、「[標準接続とコンテキスト接続](../clr-integration/data-access/context-connections-vs-regular-connections.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="cd8df-160">For more information, see [Regular vs. Context Connections](../clr-integration/data-access/context-connections-vs-regular-connections.md).</span></span>  
  
## <a name="performance-and-scalability"></a><span data-ttu-id="cd8df-161">パフォーマンスとスケーラビリティ</span><span class="sxs-lookup"><span data-stu-id="cd8df-161">Performance and Scalability</span></span>  
 <span data-ttu-id="cd8df-162">インメモリ OLTP を使用することで実現できるパフォーマンスの向上には、次の要素が影響します。</span><span class="sxs-lookup"><span data-stu-id="cd8df-162">The following factors will affect the performance gains that can be achieved with In-Memory OLTP:</span></span>  
  
 <span data-ttu-id="cd8df-163">Communication</span><span class="sxs-lookup"><span data-stu-id="cd8df-163">Communication</span></span>  
 <span data-ttu-id="cd8df-164">短いストアド プロシージャに対する多数の呼び出しを実行するアプリケーションは、各ストアド プロシージャにより多くの機能が実装されて呼び出しが少なくて済むアプリケーションと比較した場合、パフォーマンス向上の点で劣る場合があります。</span><span class="sxs-lookup"><span data-stu-id="cd8df-164">An application with many calls to short stored procedures may see a smaller performance gain compared to an application with fewer calls and more functionality implemented in each stored procedure.</span></span>  
  
 [!INCLUDE[tsql](../../../includes/tsql-md.md)] <span data-ttu-id="cd8df-165">実行</span><span class="sxs-lookup"><span data-stu-id="cd8df-165">Execution</span></span>  
 <span data-ttu-id="cd8df-166">インメモリ OLTP は、解釈されたストアド プロシージャやクエリ実行ではなく、ネイティブ コンパイル ストアド プロシージャを使用する場合に、最高のパフォーマンスを発揮します。</span><span class="sxs-lookup"><span data-stu-id="cd8df-166">In-Memory OLTP achieves the best performance when using natively compiled stored procedures rather than interpreted stored procedures or query execution.</span></span> <span data-ttu-id="cd8df-167">他のストアド プロシージャを実行するストアド プロシージャをネイティブでコンパイルすることはできませんが、そのようなストアド プロシージャからメモリ最適化テーブルにアクセスすると有利な場合もあります。</span><span class="sxs-lookup"><span data-stu-id="cd8df-167">Stored procedures that execute other stored procedures cannot be natively compiled, but there can be a benefit to accessing memory-optimized tables from such stored procedures.</span></span>  
  
 <span data-ttu-id="cd8df-168">範囲スキャンとポイント参照</span><span class="sxs-lookup"><span data-stu-id="cd8df-168">Range Scan vs Point Lookup</span></span>  
 <span data-ttu-id="cd8df-169">メモリ最適化された非クラスター化インデックスでは、範囲スキャンと並べ替えられたスキャンがサポートされています。</span><span class="sxs-lookup"><span data-stu-id="cd8df-169">Memory-optimized nonclustered indexes support range scans and ordered scans.</span></span> <span data-ttu-id="cd8df-170">ポイント参照については、メモリ最適化された非クラスター化インデックスよりもメモリ最適化されたハッシュ インデックスの方がパフォーマンスが優れています。</span><span class="sxs-lookup"><span data-stu-id="cd8df-170">For point lookups, memory-optimized hash indexes have better performance than memory-optimized nonclustered indexes.</span></span> <span data-ttu-id="cd8df-171">メモリ最適化された非クラスター化インデックスはディスク ベース インデックスよりもパフォーマンスが優れています。</span><span class="sxs-lookup"><span data-stu-id="cd8df-171">Memory-optimized nonclustered indexes have better performance than disk-based indexes.</span></span>  
  
 <span data-ttu-id="cd8df-172">インデックス操作はログに記録されず、メモリ内にのみ存在します。</span><span class="sxs-lookup"><span data-stu-id="cd8df-172">Index operations are not logged and they exist only in memory.</span></span>  
  
 <span data-ttu-id="cd8df-173">コンカレンシー</span><span class="sxs-lookup"><span data-stu-id="cd8df-173">Concurrency</span></span>  
 <span data-ttu-id="cd8df-174">ラッチの競合やブロックなど、エンジンレベルのコンカレンシーがパフォーマンスに影響するアプリケーションの場合、アプリケーションをインメモリ OLTP に移行するとパフォーマンスが大幅に向上します。</span><span class="sxs-lookup"><span data-stu-id="cd8df-174">Applications whose performance is affected by engine-level concurrency, such as latch contention or blocking, improves significantly when the application moves to In-Memory OLTP.</span></span>  
  
 <span data-ttu-id="cd8df-175">次の表は、リレーショナル データベースで一般的に生じるパフォーマンスとスケーラビリティの問題、およびインメモリ OLTP によってどのようにパフォーマンスが向上するかを示しています。</span><span class="sxs-lookup"><span data-stu-id="cd8df-175">The following table lists the performance and scalability issues that are commonly found in relational databases and how In-Memory OLTP can improve performance.</span></span>  
  
|<span data-ttu-id="cd8df-176">問題</span><span class="sxs-lookup"><span data-stu-id="cd8df-176">Issue</span></span>|<span data-ttu-id="cd8df-177">インメモリ OLTP の影響</span><span class="sxs-lookup"><span data-stu-id="cd8df-177">In-Memory OLTP Impact</span></span>|  
|-----------|----------------------------|  
|<span data-ttu-id="cd8df-178">パフォーマンス</span><span class="sxs-lookup"><span data-stu-id="cd8df-178">Performance</span></span><br /><br /> <span data-ttu-id="cd8df-179">リソース (CPU、I/O、ネットワーク、またはメモリ) の使用率が高い。</span><span class="sxs-lookup"><span data-stu-id="cd8df-179">High resource (CPU, I/O, network or memory) usage.</span></span>|<span data-ttu-id="cd8df-180">CPU</span><span class="sxs-lookup"><span data-stu-id="cd8df-180">CPU</span></span><br /> <span data-ttu-id="cd8df-181">ネイティブ コンパイル ストアド プロシージャは、解釈されたストアド プロシージャに比較すると [!INCLUDE[tsql](../../../includes/tsql-md.md)] ステートメントを実行するために必要な命令数が少ないため、CPU の使用率を大幅に下げることができます。</span><span class="sxs-lookup"><span data-stu-id="cd8df-181">Natively compiled stored procedures can lower CPU usage significantly because they require significantly fewer instructions to execute a [!INCLUDE[tsql](../../../includes/tsql-md.md)] statement compared to interpreted stored procedures.</span></span><br /><br /> <span data-ttu-id="cd8df-182">インメモリ OLTP では、1 台のサーバーで 5 ～ 10 台のサーバーのスループットに対応できる可能性があるため、スケールアウトしたワークロード環境でのハードウェア投資を削減できます。</span><span class="sxs-lookup"><span data-stu-id="cd8df-182">In-Memory OLTP can help reduce the hardware investment in scaled-out workloads because one server can potentially deliver the throughput of five to ten servers.</span></span><br /><br /> <span data-ttu-id="cd8df-183">I/O</span><span class="sxs-lookup"><span data-stu-id="cd8df-183">I/O</span></span><br /> <span data-ttu-id="cd8df-184">データやインデックス ページに対する処理に起因する I/O のボトルネックが発生する場合、インメモリ OLTP ではボトルネックを低減できます。</span><span class="sxs-lookup"><span data-stu-id="cd8df-184">If you encounter an I/O bottleneck from processing to data or index pages, In-Memory OLTP may reduce the bottleneck.</span></span> <span data-ttu-id="cd8df-185">また、インメモリ OLTP オブジェクトのチェックポイント処理は連続的であり、I/O 操作の突然の増加を招くことはありません。</span><span class="sxs-lookup"><span data-stu-id="cd8df-185">Additionally, the checkpointing of In-Memory OLTP objects is continuous and does not lead to sudden increases in I/O operations.</span></span> <span data-ttu-id="cd8df-186">ただし、パフォーマンス クリティカルなテーブルのワーキング セットがメモリに収まらない場合、インメモリ OLTP では、データがメモリ常駐型であることが必要であるため、パフォーマンスは向上しません。</span><span class="sxs-lookup"><span data-stu-id="cd8df-186">However, if the working set of the performance critical tables does not fit in memory, In-Memory OLTP will not improve performance because it requires data to be memory resident.</span></span> <span data-ttu-id="cd8df-187">ログ記録で I/O のボトルネックが発生する場合、インメモリ OLTP はログ記録が少ないためボトルネックを軽減できます。</span><span class="sxs-lookup"><span data-stu-id="cd8df-187">If you encounter an I/O bottleneck in logging, In-Memory OLTP can reduce the bottleneck because it does less logging.</span></span> <span data-ttu-id="cd8df-188">1 つ以上のメモリ最適化テーブルが持続性のないテーブルとして構成されている場合は、データのログ記録を無効にできます。</span><span class="sxs-lookup"><span data-stu-id="cd8df-188">If one or more memory-optimized tables are configured as non-durable tables, you can eliminate logging for data.</span></span><br /><br /> <span data-ttu-id="cd8df-189">メモリ</span><span class="sxs-lookup"><span data-stu-id="cd8df-189">Memory</span></span><br /> <span data-ttu-id="cd8df-190">インメモリ OLTP では、パフォーマンス上の利点は得られません。</span><span class="sxs-lookup"><span data-stu-id="cd8df-190">In-Memory OLTP does not offer any performance benefit.</span></span> <span data-ttu-id="cd8df-191">インメモリ OLTP では、オブジェクトがメモリ常駐型であることが必要になるため、メモリの負荷が増加する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="cd8df-191">In-Memory OLTP can put extra pressure on memory as the objects need to be memory resident.</span></span><br /><br /> <span data-ttu-id="cd8df-192">ネットワーク</span><span class="sxs-lookup"><span data-stu-id="cd8df-192">Network</span></span><br /> <span data-ttu-id="cd8df-193">インメモリ OLTP では、パフォーマンス上の利点は得られません。</span><span class="sxs-lookup"><span data-stu-id="cd8df-193">In-Memory OLTP does not offer any performance benefit.</span></span> <span data-ttu-id="cd8df-194">データは、データ層からアプリケーション層に渡す必要があります。</span><span class="sxs-lookup"><span data-stu-id="cd8df-194">The data needs to be communicated from data tier to application tier.</span></span>|  
|<span data-ttu-id="cd8df-195">スケーラビリティ</span><span class="sxs-lookup"><span data-stu-id="cd8df-195">Scalability</span></span><br /><br /> <span data-ttu-id="cd8df-196">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] アプリケーションでのスケーリングの問題のほとんどは、ロック、ラッチ、スピンロックの競合など、同時実行の問題が原因です。</span><span class="sxs-lookup"><span data-stu-id="cd8df-196">Most scaling issues in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] applications are caused by concurrency issues such as contention in locks, latches, and spinlocks.</span></span>|<span data-ttu-id="cd8df-197">ラッチの競合</span><span class="sxs-lookup"><span data-stu-id="cd8df-197">Latch Contention</span></span><br /> <span data-ttu-id="cd8df-198">一般的なシナリオとして、キー順に行を同時に挿入した場合の、インデックスの最終ページでの競合を挙げることができます。</span><span class="sxs-lookup"><span data-stu-id="cd8df-198">A typical scenario is contention on the last page of an index when inserting rows concurrently in key order.</span></span> <span data-ttu-id="cd8df-199">インメモリ OLTP では、データへのアクセス時にラッチを使用しないため、ラッチの競合に関連するスケーラビリティの問題は完全になくなります。</span><span class="sxs-lookup"><span data-stu-id="cd8df-199">Because In-Memory OLTP does not take latches when accessing data, the scalability issues related to latch contentions are fully removed.</span></span><br /><br /> <span data-ttu-id="cd8df-200">スピンロックの競合</span><span class="sxs-lookup"><span data-stu-id="cd8df-200">Spinlock Contention</span></span><br /> <span data-ttu-id="cd8df-201">インメモリ OLTP では、データへのアクセス時にラッチを使用しないため、スピンロックの競合に関連するスケーラビリティの問題は完全になくなります。</span><span class="sxs-lookup"><span data-stu-id="cd8df-201">Because In-Memory OLTP does not take latches when accessing data, the scalability issues related to spinlock contentions are fully removed.</span></span><br /><br /> <span data-ttu-id="cd8df-202">ロックに関連する競合</span><span class="sxs-lookup"><span data-stu-id="cd8df-202">Locking Related Contention</span></span><br /> <span data-ttu-id="cd8df-203">データベース アプリケーションで読み取り操作と書き込み操作の間にブロックの問題が発生した場合、インメモリ OLTP では、新しい形式のオプティミスティック コンカレンシーを使用してすべてのトランザクション分離レベルを実装するため、ブロックの問題は排除されます。</span><span class="sxs-lookup"><span data-stu-id="cd8df-203">If your database application encounters blocking issues between read and write operations, In-Memory OLTP removes the blocking issues because it uses a new form of optimistic concurrency control to implement all transaction isolation levels.</span></span> <span data-ttu-id="cd8df-204">インメモリ OLTP では行バージョンを格納するために TempDB は使用されません。</span><span class="sxs-lookup"><span data-stu-id="cd8df-204">In-Memory OLTP does not use TempDB to store row versions.</span></span><br /><br /> <span data-ttu-id="cd8df-205">2 つの同時実行トランザクションで同じ行を更新しようとした場合など、2 つの書き込み操作間の競合によってスケーリングの問題が発生した場合、インメモリ OLTP では、一方のトランザクションが成功し、他方のトランザクションは失敗するようになります。</span><span class="sxs-lookup"><span data-stu-id="cd8df-205">If the scaling issue is caused by conflict between two write operations, such as two concurrent transactions trying to update the same row, In-Memory OLTP lets one transaction succeed and fails the other transaction.</span></span> <span data-ttu-id="cd8df-206">失敗したトランザクションは明示的または暗黙的に再送信して、トランザクションを再試行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="cd8df-206">The failed transaction must be re-submitted either explicitly or implicitly, re-trying the transaction.</span></span> <span data-ttu-id="cd8df-207">いずれの場合も、アプリケーションに変更を加える必要があります。</span><span class="sxs-lookup"><span data-stu-id="cd8df-207">In either case, you need to make changes to the application.</span></span><br /><br /> <span data-ttu-id="cd8df-208">アプリケーションで 2 つの書き込み操作間の競合が頻繁に発生する場合、オプティミスティック ロックの価値は減少します。</span><span class="sxs-lookup"><span data-stu-id="cd8df-208">If your application experiences frequent conflicts between two write operations, the value of optimistic locking is diminished.</span></span> <span data-ttu-id="cd8df-209">このアプリケーションはインメモリ OLTP に適していません。</span><span class="sxs-lookup"><span data-stu-id="cd8df-209">The application is not suitable for In-Memory OLTP.</span></span> <span data-ttu-id="cd8df-210">ほとんどの OLTP アプリケーションでは、競合がロックのエスカレーションによって引き起こされない限り、書き込みの競合はありません。</span><span class="sxs-lookup"><span data-stu-id="cd8df-210">Most OLTP applications don't have a write conflicts unless the conflict is induced by lock escalation.</span></span>|  
  
## <a name="see-also"></a><span data-ttu-id="cd8df-211">参照</span><span class="sxs-lookup"><span data-stu-id="cd8df-211">See Also</span></span>  
 [<span data-ttu-id="cd8df-212">インメモリ OLTP &#40;インメモリ最適化&#41;</span><span class="sxs-lookup"><span data-stu-id="cd8df-212">In-Memory OLTP &#40;In-Memory Optimization&#41;</span></span>](in-memory-oltp-in-memory-optimization.md)  
  
  
