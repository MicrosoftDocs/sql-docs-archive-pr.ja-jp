---
title: フルテキスト インデックスのパフォーマンスの向上 | Microsoft Docs
ms.custom: ''
ms.date: 04/26/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: search
ms.topic: conceptual
helpviewer_keywords:
- performance [SQL Server], full-text search
- full-text queries [SQL Server], performance
- crawls [full-text search]
- full-text indexes [SQL Server], performance
- full-text search [SQL Server], performance
- batches [SQL Server], full-text search
ms.assetid: ef39ef1f-f0b7-4582-8e9c-31d4bd0ad35d
author: MikeRayMSFT
ms.author: mikeray
ms.openlocfilehash: 51b5913e9c3ce65faa5a1fddc5846cc7c94d149f
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/04/2020
ms.locfileid: "87717744"
---
# <a name="improve-the-performance-of-full-text-indexes"></a><span data-ttu-id="ae118-102">フルテキスト インデックスのパフォーマンスの向上</span><span class="sxs-lookup"><span data-stu-id="ae118-102">Improve the Performance of Full-Text Indexes</span></span>
  <span data-ttu-id="ae118-103">フルテキスト インデックス作成とフルテキスト クエリのパフォーマンスは、メモリ、ディスク速度、CPU 速度、コンピューターのアーキテクチャなどのハードウェア リソースの影響を受けます。</span><span class="sxs-lookup"><span data-stu-id="ae118-103">Performance for full-text indexing and full-text queries is influenced by hardware resources, such as memory, disk speed, CPU speed, and machine architecture.</span></span>  
  
##  <a name="common-causes-of-performance-issues"></a><a name="causes"></a><span data-ttu-id="ae118-104">パフォーマンスの問題の一般的な原因</span><span class="sxs-lookup"><span data-stu-id="ae118-104">Common Causes of Performance Issues</span></span>  
 <span data-ttu-id="ae118-105">フルテキスト インデックス作成のパフォーマンス低下の主な原因となるのは、ハードウェア リソースの制限です。</span><span class="sxs-lookup"><span data-stu-id="ae118-105">The main cause for reduced full-text indexing performance is hardware-resource limits:</span></span>  
  
-   <span data-ttu-id="ae118-106">フィルター デーモン ホスト プロセス (fdhost.exe) または [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] プロセス (sqlservr.exe) の CPU 使用率が 100% に近くなっている場合は、CPU がボトルネックになっています。</span><span class="sxs-lookup"><span data-stu-id="ae118-106">If CPU usage by the filter daemon host process (fdhost.exe) or the [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] process (sqlservr.exe) is close to 100 percent, the CPU is the bottleneck.</span></span>  
  
-   <span data-ttu-id="ae118-107">ディスク待ちのキューの長さが平均でディスク ヘッド数の 2 倍を超えている場合は、ディスクがボトルネックになっています。</span><span class="sxs-lookup"><span data-stu-id="ae118-107">If the average disk-waiting queue length is more than two times the number of disk heads, there is a bottleneck on the disk.</span></span> <span data-ttu-id="ae118-108">この場合の主な回避策は、作成するフルテキスト カタログを [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] のデータベース ファイルやログから切り離し、</span><span class="sxs-lookup"><span data-stu-id="ae118-108">The primary workaround is to create full-text catalogs that are separate from the [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] database files and logs.</span></span> <span data-ttu-id="ae118-109">ログ、データベース ファイル、およびフルテキスト カタログを別々のディスクに配置することです。</span><span class="sxs-lookup"><span data-stu-id="ae118-109">Put the logs, database files, and full-text catalogs on separate disks.</span></span> <span data-ttu-id="ae118-110">その他、高速なディスクを購入したり RAID を使用することも、インデックス作成のパフォーマンス向上に役立ちます。</span><span class="sxs-lookup"><span data-stu-id="ae118-110">Buying faster disks and using RAID can also help improve indexing performance.</span></span>  
  
-   <span data-ttu-id="ae118-111">物理メモリが不足している場合 (3 GB 以下) は、メモリがボトルネックになっている可能性があります。</span><span class="sxs-lookup"><span data-stu-id="ae118-111">If there is a shortage of physical memory (3-GB limit), memory might be the bottleneck.</span></span> <span data-ttu-id="ae118-112">物理メモリ上の制限は、すべてのシステムで発生する可能性があります。32 ビット システムでは、仮想メモリの不足が原因でフルテキスト インデックス作成に時間がかかることがあります。</span><span class="sxs-lookup"><span data-stu-id="ae118-112">Physical memory limitations are possible on all systems, and on 32-bit systems, virtual memory pressure can slow down full-text indexing.</span></span>  
  
    > [!NOTE]  
    >  <span data-ttu-id="ae118-113">[!INCLUDE[ssKatmai](../../includes/sskatmai-md.md)]以降の Full-Text Engine は sqlservr.exe の一部となったため、AWE メモリを使用できます。</span><span class="sxs-lookup"><span data-stu-id="ae118-113">Beginning in [!INCLUDE[ssKatmai](../../includes/sskatmai-md.md)], the Full-Text Engine can use AWE memory because the Full-Text Engine is part of the sqlservr.exe.</span></span>  
  
 <span data-ttu-id="ae118-114">システムにハードウェアのボトルネックがない場合、フルテキスト検索のインデックス作成パフォーマンスは、主に以下の条件に左右されます。</span><span class="sxs-lookup"><span data-stu-id="ae118-114">If the system has no hardware bottlenecks, the indexing performance of full-text search mostly depends on the following:</span></span>  
  
-   <span data-ttu-id="ae118-115">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] によるフルテキスト バッチの作成にかかる時間</span><span class="sxs-lookup"><span data-stu-id="ae118-115">How long it takes [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] to create full-text batches.</span></span>  
  
-   <span data-ttu-id="ae118-116">フィルター デーモンがバッチを処理する速度</span><span class="sxs-lookup"><span data-stu-id="ae118-116">How quickly the filter daemon can consume those batches.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="ae118-117">増分、手動、および自動の変更追跡による作成は、完全作成とは違って、ハードウェア リソースを最大限に活用して処理を高速化するようには作られていません。</span><span class="sxs-lookup"><span data-stu-id="ae118-117">Unlike full population, incremental, manual, and auto change tracking population are not designed to maximize hardware resources to achieve faster speed.</span></span> <span data-ttu-id="ae118-118">このため、これらのチューニングのヒントでは、フルテキスト インデックス作成のパフォーマンスを強化できない場合があります。</span><span class="sxs-lookup"><span data-stu-id="ae118-118">Therefore, these tuning suggestions may not enhance performance for full-text indexing.</span></span>  
  
 <span data-ttu-id="ae118-119">作成が完了すると、最終的なマージ プロセスが起動され、インデックス フラグメントが 1 つのマスター フルテキスト インデックスにマージされます。</span><span class="sxs-lookup"><span data-stu-id="ae118-119">When a population has completed, a final merge process is triggered that merges the index fragments together into one master full-text index.</span></span> <span data-ttu-id="ae118-120">これにより、多数のインデックス フラグメントではなく、1 つのマスター インデックスのみをクエリすれば済むため、クエリのパフォーマンスが向上し、関連順位付けにもより的確なスコア (評価) 統計を適用できます。</span><span class="sxs-lookup"><span data-stu-id="ae118-120">This results in improved query performance since only the master index needs to be queried rather than a number of index fragments, and better scoring statistics may be used for relevance ranking.</span></span> <span data-ttu-id="ae118-121">マスターのマージ処理では、インデックス フラグメントをマージする際に大量のデータを読み書きする必要があるため、大量の I/O が発生しますが、クエリの着信がブロックされることはありません。</span><span class="sxs-lookup"><span data-stu-id="ae118-121">Note that the master merge can be I/O intensive, because large amounts of data must be written and read when index fragments are merged, though it does not block incoming queries.</span></span>  
  
> [!IMPORTANT]  
>  <span data-ttu-id="ae118-122">マスター マージで大量のデータを処理すると、実行時間が長いトランザクションが発生し、チェックポイント時のログの切り捨てが遅れる場合があります。</span><span class="sxs-lookup"><span data-stu-id="ae118-122">Master merging a large amount of data can create a long running transaction, delaying truncation of the transaction log during checkpoint.</span></span> <span data-ttu-id="ae118-123">この場合、完全復旧モデルでは、トランザクション ログが非常に大きくなることがあります。</span><span class="sxs-lookup"><span data-stu-id="ae118-123">In this case, under the full recovery model, the transaction log might grow significantly.</span></span> <span data-ttu-id="ae118-124">完全復旧モデルを使用するデータベースで大きなフルテキスト インデックスを再編成する前に、実行時間が長いトランザクションのための十分な領域をトランザクション ログに割り当てることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="ae118-124">As a best practice, before reorganizing a large full-text index in a database that uses the full recovery model, ensure that your transaction log contains sufficient space for a long-running transaction.</span></span> <span data-ttu-id="ae118-125">詳細については、「 [トランザクション ログ ファイルのサイズの管理](../logs/manage-the-size-of-the-transaction-log-file.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="ae118-125">For more information, see [Manage the Size of the Transaction Log File](../logs/manage-the-size-of-the-transaction-log-file.md).</span></span>  
  
  
  
##  <a name="tuning-the-performance-of-full-text-indexes"></a><a name="tuning"></a><span data-ttu-id="ae118-126">フルテキストインデックスのパフォーマンスのチューニング</span><span class="sxs-lookup"><span data-stu-id="ae118-126">Tuning the Performance of Full-Text Indexes</span></span>  
 <span data-ttu-id="ae118-127">フルテキスト インデックスのパフォーマンスを最大化するには、次に示すベスト プラクティスを実装します。</span><span class="sxs-lookup"><span data-stu-id="ae118-127">To maximize the performance of your full-text indexes, implement the following best practices:</span></span>  
  
-   <span data-ttu-id="ae118-128">すべてのプロセッサまたはコアを最大限に使用するには、 [sp_configure](/sql/relational-databases/system-stored-procedures/sp-configure-transact-sql)' `max full-text crawl ranges` ' をシステム上の cpu の数に設定します。</span><span class="sxs-lookup"><span data-stu-id="ae118-128">To use all processors or cores to the maximum, set [sp_configure](/sql/relational-databases/system-stored-procedures/sp-configure-transact-sql)'`max full-text crawl ranges`' to the number of CPUs on the system.</span></span> <span data-ttu-id="ae118-129">構成オプションの詳細については、「 [max full-text crawl range サーバー構成オプション](../../database-engine/configure-windows/max-full-text-crawl-range-server-configuration-option.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="ae118-129">For information about this configuration option, see [max full-text crawl range Server Configuration Option](../../database-engine/configure-windows/max-full-text-crawl-range-server-configuration-option.md).</span></span>  
  
-   <span data-ttu-id="ae118-130">ベース テーブルにクラスター化インデックスがあることを確認します。</span><span class="sxs-lookup"><span data-stu-id="ae118-130">Make sure that the base table has a clustered index.</span></span> <span data-ttu-id="ae118-131">クラスター化インデックスの最初の列には整数データ型を使用します。</span><span class="sxs-lookup"><span data-stu-id="ae118-131">Use an integer data type for the first column of the clustered index.</span></span> <span data-ttu-id="ae118-132">GUID は使用しないようにしてください。</span><span class="sxs-lookup"><span data-stu-id="ae118-132">Avoid using GUIDs in the first column of the clustered index.</span></span> <span data-ttu-id="ae118-133">クラスター化インデックスで複数の範囲の作成を使用すると、作成速度を最大限に高めることができます。</span><span class="sxs-lookup"><span data-stu-id="ae118-133">A multi-range population on a clustered index can produce the highest population speed.</span></span> <span data-ttu-id="ae118-134">フルテキスト キーとして機能する列は整数データ型にすることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="ae118-134">We recommend that the column serving as the full-text key be an integer data type.</span></span>  
  
-   <span data-ttu-id="ae118-135">[UPDATE STATISTICS](/sql/t-sql/statements/update-statistics-transact-sql) ステートメントを使用してベース テーブルの統計を更新します。</span><span class="sxs-lookup"><span data-stu-id="ae118-135">Update the statistics of the base table by using the [UPDATE STATISTICS](/sql/t-sql/statements/update-statistics-transact-sql) statement.</span></span> <span data-ttu-id="ae118-136">さらに重要な点は、クラスター化インデックスの統計や完全作成のフルテキスト キーを更新することです。</span><span class="sxs-lookup"><span data-stu-id="ae118-136">More important, update the statistics on the clustered index or the full-text key for a full population.</span></span> <span data-ttu-id="ae118-137">これにより、複数の範囲の作成によってテーブルに適切なパーティションが生成されるようになります。</span><span class="sxs-lookup"><span data-stu-id="ae118-137">This helps a multi-range population to generate good partitions on the table.</span></span>  
  
-   <span data-ttu-id="ae118-138">増分作成のパフォーマンスを強化するには、`timestamp` 列のセカンダリ インデックスを作成します。</span><span class="sxs-lookup"><span data-stu-id="ae118-138">Build a secondary index on a `timestamp` column if you want to improve the performance of incremental population.</span></span>  
  
-   <span data-ttu-id="ae118-139">大型のマルチ CPU コンピューター上で完全作成を実行する前に、fdhost.exe プロセスおよびオペレーティング システムが使用するメモリを十分に確保するために、`max server memory` 値を設定してバッファー プールのサイズを一時的に制限することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="ae118-139">Before you perform a full population on a large multi-CPU computer, we recommend that you temporarily limit the size of the buffer pool by setting the `max server memory` value to leave enough memory for the fdhost.exe process and operating system use.</span></span> <span data-ttu-id="ae118-140">詳細については、このトピックの「フィルター デーモン ホスト プロセス (fdhost.exe) のメモリ要件の推定」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="ae118-140">For more information, see "Estimating the Memory Requirements of the Filter Daemon Host Process (fdhost.exe)," later in this topic.</span></span>  
  
  
  
##  <a name="troubleshooting-the-performance-of-full-populations"></a><a name="full"></a><span data-ttu-id="ae118-141">完全作成のパフォーマンスのトラブルシューティング</span><span class="sxs-lookup"><span data-stu-id="ae118-141">Troubleshooting the Performance of Full Populations</span></span>  
 <span data-ttu-id="ae118-142">パフォーマンスの問題を診断するには、フルテキスト クロール ログを調べます。</span><span class="sxs-lookup"><span data-stu-id="ae118-142">To diagnose performance problems, look at the full-text crawl logs.</span></span> <span data-ttu-id="ae118-143">クロール ログの詳細については、「 [フルテキスト インデックスの作成](../indexes/indexes.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="ae118-143">For information about crawl logs, see [Populate Full-Text Indexes](../indexes/indexes.md).</span></span>  
  
 <span data-ttu-id="ae118-144">完全作成のパフォーマンスが不十分な場合は、次の順序でトラブルシューティングを行うことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="ae118-144">It is recommended that the following order of troubleshooting be followed if the performance of full populations is not satisfactory.</span></span>  
  
### <a name="physical-memory-usage"></a><span data-ttu-id="ae118-145">物理メモリの使用量</span><span class="sxs-lookup"><span data-stu-id="ae118-145">Physical Memory Usage</span></span>  
 <span data-ttu-id="ae118-146">フルテキスト作成時は、fdhost.exe または sqlservr.exe がメモリ不足またはメモリ枯渇の状態で実行される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="ae118-146">During a full-text population, it is possible for fdhost.exe or sqlservr.exe to run low on memory or to run out of memory.</span></span> <span data-ttu-id="ae118-147">フルテキスト クロールのログを確認した結果、fdhost.exe が頻繁に再起動されているか、エラー コード 8007008 が返されていることが判明した場合は、これらのプロセスのいずれかでメモリ不足が生じています。</span><span class="sxs-lookup"><span data-stu-id="ae118-147">If the full-text crawl log shows that fdhost.exe is being restarted often or that error code 8007008 is being returned it means one of these processes is running out of memory.</span></span> <span data-ttu-id="ae118-148">特に大型のマルチ CPU コンピューター上で fdhost.exe がダンプを生成している場合、メモリが不足してきている可能性があります。</span><span class="sxs-lookup"><span data-stu-id="ae118-148">If fdhost.exe is producing dumps, particularly on large, multi-CPU computers, it might be running out of memory.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="ae118-149">フルテキスト クロールで使用されるメモリ バッファーに関する情報を取得する方法については、「[sys.dm_fts_memory_buffers &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-fts-memory-buffers-transact-sql)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="ae118-149">To obtain information about memory buffers used by a full-text crawl, see [sys.dm_fts_memory_buffers &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-fts-memory-buffers-transact-sql).</span></span>  
  
 <span data-ttu-id="ae118-150">次のような原因が考えられます。</span><span class="sxs-lookup"><span data-stu-id="ae118-150">The possible causes are as follows:</span></span>  
  
-   <span data-ttu-id="ae118-151">完全作成時に使用可能な物理メモリの量がゼロの場合、システム上の物理メモリのほとんどを [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] バッファー プールが消費している可能性があります。</span><span class="sxs-lookup"><span data-stu-id="ae118-151">If amount of physical memory that is available during a full population is zero, the [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] buffer pool might be consuming most of the physical memory on the system.</span></span>  
  
     <span data-ttu-id="ae118-152">sqlservr.exe プロセスは、構成されている最大サーバー メモリ量に達するまで、バッファー プールで使用できるすべてのメモリを獲得しようとします。</span><span class="sxs-lookup"><span data-stu-id="ae118-152">The sqlservr.exe process tries to grab all available memory for the buffer pool, up to the configured maximum server memory.</span></span> <span data-ttu-id="ae118-153">`max server memory` の割り当てが大きすぎる場合は、fdhost.exe プロセスのメモリ不足や共有メモリの割り当ての失敗が発生することがあります。</span><span class="sxs-lookup"><span data-stu-id="ae118-153">If the `max server memory` allocation is too large, out-of-memory conditions and failure to allocate shared memory can occur for the fdhost.exe process.</span></span>  
  
    > [!NOTE]  
    >  <span data-ttu-id="ae118-154">マルチ CPU コンピューター上でのフルテキスト作成時、fdhost.exe または sqlservr.exe との間でバッファー プール メモリの競合が発生する場合があります。</span><span class="sxs-lookup"><span data-stu-id="ae118-154">During a full-text population on a multi-CPU computer, contention for the buffer pool memory can occur between fdhost.exe or sqlservr.exe.</span></span> <span data-ttu-id="ae118-155">その結果、共有メモリが不足すると、バッチの再試行、メモリ スラッシング、および fdhost.exe プロセスによるダンプが発生します。</span><span class="sxs-lookup"><span data-stu-id="ae118-155">The resulting lack of shared memory causes batch retries, memory thrashing, and dumps by the fdhost.exe process.</span></span>  
  
     <span data-ttu-id="ae118-156">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] バッファー プールの `max server memory` 値を適切に設定することにより、この問題を解決できます。</span><span class="sxs-lookup"><span data-stu-id="ae118-156">You can solve this problem by setting the `max server memory` value of the [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] buffer pool appropriately.</span></span> <span data-ttu-id="ae118-157">詳細については、このトピックの「フィルター デーモン ホスト プロセス (fdhost.exe) のメモリ要件の推定」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="ae118-157">For more information, see "Estimating the Memory Requirements of the Filter Daemon Host Process (fdhost.exe)," later in this topic.</span></span> <span data-ttu-id="ae118-158">フルテキスト インデックスの作成に使用されるバッチのサイズを小さくすると、有効な場合があります。</span><span class="sxs-lookup"><span data-stu-id="ae118-158">Reducing the batch size used for full-text indexing may also help.</span></span>  
  
-   <span data-ttu-id="ae118-159">ページングの問題</span><span class="sxs-lookup"><span data-stu-id="ae118-159">A paging issue</span></span>  
  
     <span data-ttu-id="ae118-160">拡張が制限された小さなページ ファイルが使用されているシステムにおいてページ ファイルのサイズが不足した場合、fdhost.exe または sqlservr.exe でメモリ不足が発生します。</span><span class="sxs-lookup"><span data-stu-id="ae118-160">Insufficient page-file size, such as on a system that has a small page file with restricted growth, can also cause the fdhost.exe or sqlservr.exe to run out of memory.</span></span>  
  
     <span data-ttu-id="ae118-161">クロール ログにメモリ関連の障害が見当たらない場合、過剰なページングが原因でパフォーマンスが低下していることが考えられます。</span><span class="sxs-lookup"><span data-stu-id="ae118-161">If the crawl logs do not indicate any memory-related failures, it is likely that performance is slow due to excessive paging.</span></span>  
  
  
  
### <a name="estimating-the-memory-requirements-of-the-filter-daemon-host-process-fdhostexe"></a><span data-ttu-id="ae118-162">フィルター デーモン ホスト プロセス (fdhost.exe) のメモリ要件の推定</span><span class="sxs-lookup"><span data-stu-id="ae118-162">Estimating the Memory Requirements of the Filter Daemon Host Process (fdhost.exe)</span></span>  
 <span data-ttu-id="ae118-163">fdhost.exe プロセスが作成のために必要とするメモリ量は、主に、プロセスが使用するフルテキスト クロール範囲の数、受信共有メモリ (ISM) のサイズ、および ISM インスタンスの最大数に依存します。</span><span class="sxs-lookup"><span data-stu-id="ae118-163">The amount of memory required by the fdhost.exe process for a population depends mainly on the number of full-text crawl ranges it uses, the size of inbound shared memory (ISM), and the maximum number of ISM instances.</span></span>  
  
 <span data-ttu-id="ae118-164">フィルター デーモン ホストによって使用されるメモリ量 (バイト単位) は、次の式を使用して概算できます。</span><span class="sxs-lookup"><span data-stu-id="ae118-164">The amount of memory (in bytes) consumed by the filter daemon host can be roughly estimated by using the following formula:</span></span>  
  
 <span data-ttu-id="ae118-165">*number_of_crawl_ranges* \`ism_size '*max_outstanding_isms* \* 2</span><span class="sxs-lookup"><span data-stu-id="ae118-165">*number_of_crawl_ranges* \`ism_size\`*max_outstanding_isms*\* 2</span></span>  
  
 <span data-ttu-id="ae118-166">この式の変数の既定値は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="ae118-166">The default values of the variables in the preceding formula are as follows:</span></span>  
  
|<span data-ttu-id="ae118-167">**変数**</span><span class="sxs-lookup"><span data-stu-id="ae118-167">**Variable**</span></span>|<span data-ttu-id="ae118-168">**既定値**</span><span class="sxs-lookup"><span data-stu-id="ae118-168">**Default value**</span></span>|  
|------------------|-----------------------|  
|<span data-ttu-id="ae118-169">*number_of_crawl_ranges*</span><span class="sxs-lookup"><span data-stu-id="ae118-169">*number_of_crawl_ranges*</span></span>|<span data-ttu-id="ae118-170">CPU の数</span><span class="sxs-lookup"><span data-stu-id="ae118-170">The number of CPUs</span></span>|  
|<span data-ttu-id="ae118-171">*ism_size*</span><span class="sxs-lookup"><span data-stu-id="ae118-171">*ism_size*</span></span>|<span data-ttu-id="ae118-172">1 MB (x86 コンピューターの場合)</span><span class="sxs-lookup"><span data-stu-id="ae118-172">1 MB for x86 computers</span></span><br /><br /> <span data-ttu-id="ae118-173">合計物理メモリにより、4 MB、8 MB、または 16 MB (x64 コンピューターの場合)</span><span class="sxs-lookup"><span data-stu-id="ae118-173">4 MB, 8 MB, or 16MB for x64 computers, depending on the total physical memory</span></span>|  
|<span data-ttu-id="ae118-174">*max_outstanding_isms*</span><span class="sxs-lookup"><span data-stu-id="ae118-174">*max_outstanding_isms*</span></span>|<span data-ttu-id="ae118-175">25 (x86 コンピューターの場合)</span><span class="sxs-lookup"><span data-stu-id="ae118-175">25 for x86 computers</span></span><br /><br /> <span data-ttu-id="ae118-176">5 (x64 コンピューターの場合)</span><span class="sxs-lookup"><span data-stu-id="ae118-176">5 for x64 computers</span></span>|  
  
 <span data-ttu-id="ae118-177">fdhost.exe のメモリ要件の推定方法に関するガイドラインを、以下の表に示します。</span><span class="sxs-lookup"><span data-stu-id="ae118-177">The following table presents guidelines about how to estimate the memory requirements of fdhost.exe.</span></span> <span data-ttu-id="ae118-178">この表の数式では次の値を使用します。</span><span class="sxs-lookup"><span data-stu-id="ae118-178">The formulas in this table use the following values:</span></span>  
  
-   <span data-ttu-id="ae118-179">*F*: fdhost.exe に必要なメモリの推定値 (MB 単位)。</span><span class="sxs-lookup"><span data-stu-id="ae118-179">*F*, which is an estimate of memory needed by fdhost.exe (in MB).</span></span>  
  
-   <span data-ttu-id="ae118-180">*T*: システムで使用できる合計物理メモリ (MB 単位)。</span><span class="sxs-lookup"><span data-stu-id="ae118-180">*T*, which is the total physical memory available on the system (in MB).</span></span>  
  
-   <span data-ttu-id="ae118-181">*M*。これは最適な `max server memory` 設定です。</span><span class="sxs-lookup"><span data-stu-id="ae118-181">*M*, which is the optimal `max server memory` setting.</span></span>  
  
> [!IMPORTANT]  
>  <span data-ttu-id="ae118-182">数式に関する基本的な情報については、以下の「 <sup>1</sup>、 <sup>2</sup>、および<sup>3</sup>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="ae118-182">For essential information about the formulas, see <sup>1</sup>, <sup>2</sup>, and <sup>3</sup>, below.</span></span>  
  
|<span data-ttu-id="ae118-183">プラットフォーム</span><span class="sxs-lookup"><span data-stu-id="ae118-183">Platform</span></span>|<span data-ttu-id="ae118-184">fdhost.exe メモリ要件の推定 (MB)-*F*<sup>1</sup></span><span class="sxs-lookup"><span data-stu-id="ae118-184">Estimating fdhost.exe memory requirements in MB-*F*<sup>1</sup></span></span>|<span data-ttu-id="ae118-185">最大サーバーメモリを計算するための式-*M*<sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="ae118-185">Formula for calculating max server memory-*M*<sup>2</sup></span></span>|  
|--------------|---------------------------------------------------------------------|---------------------------------------------------------------|  
|<span data-ttu-id="ae118-186">x86</span><span class="sxs-lookup"><span data-stu-id="ae118-186">x86</span></span>|<span data-ttu-id="ae118-187">_F_ **=** _クロール範囲の数_ **&#42;** 50</span><span class="sxs-lookup"><span data-stu-id="ae118-187">_F_ **=** _Number of crawl ranges_ **&#42;** 50</span></span>|<span data-ttu-id="ae118-188">_M_ **= 最小 (** _T_ **,** 2000 \*\*)- *`F`* - \*\* 500</span><span class="sxs-lookup"><span data-stu-id="ae118-188">_M_ **=minimum(** _T_ **,** 2000 **)-*`F`*-** 500</span></span>|  
|<span data-ttu-id="ae118-189">X64</span><span class="sxs-lookup"><span data-stu-id="ae118-189">x64</span></span>|<span data-ttu-id="ae118-190">_F_ **=** _クロール範囲の数_ **&#42;** 10 **&#42;** 8</span><span class="sxs-lookup"><span data-stu-id="ae118-190">_F_ **=** _Number of crawl ranges_ **&#42;** 10 **&#42;** 8</span></span>|<span data-ttu-id="ae118-191">_M_ **=** _T_ **-** _F_ **-** 500</span><span class="sxs-lookup"><span data-stu-id="ae118-191">_M_ **=** _T_ **-** _F_ **-** 500</span></span>|  
  
 <span data-ttu-id="ae118-192"><sup>1</sup>複数の完全作成が進行中の場合は、それぞれの fdhost.exe のメモリ要件を、 *F1*、 *F2*などのように個別に計算します。</span><span class="sxs-lookup"><span data-stu-id="ae118-192"><sup>1</sup> If multiple full populations are in progress, calculate the fdhost.exe memory requirements of each separately, as *F1*, *F2*, and so forth.</span></span> <span data-ttu-id="ae118-193">その後、*M* as _T_ **-** sigma **(** _F_i **)** で計算します。</span><span class="sxs-lookup"><span data-stu-id="ae118-193">Then calculate *M* as _T_**-** sigma **(**_F_i **)**.</span></span>  
  
 <span data-ttu-id="ae118-194"><sup>2</sup> 500 MB は、システム内の他のプロセスが必要とするメモリの推定値です。</span><span class="sxs-lookup"><span data-stu-id="ae118-194"><sup>2</sup> 500 MB is an estimate of the memory required by other processes in the system.</span></span> <span data-ttu-id="ae118-195">システムで追加の作業を実行している場合、適宜この値を大きくします。</span><span class="sxs-lookup"><span data-stu-id="ae118-195">If the system is doing additional work, increase this value accordingly.</span></span>  
  
 <span data-ttu-id="ae118-196"><sup>3</sup> .*ism_size*は、x64 プラットフォームでは 8 MB と見なされます。</span><span class="sxs-lookup"><span data-stu-id="ae118-196"><sup>3</sup> .*ism_size* is assumed to be 8 MB for x64 platforms.</span></span>  
  
 <span data-ttu-id="ae118-197">**例 : fdhost.exe のメモリ要件の推定**</span><span class="sxs-lookup"><span data-stu-id="ae118-197">**Example: Estimating the Memory Requirements of fdhost.exe**</span></span>  
  
 <span data-ttu-id="ae118-198">この例は、8 GM の RAM と 4 つのデュアル コア プロセッサを搭載した AMD64 コンピューターを対象としています。</span><span class="sxs-lookup"><span data-stu-id="ae118-198">This example is for an AMD64 computer that has 8GM of RAM and 4 dual core processors.</span></span> <span data-ttu-id="ae118-199">最初の計算では、fdhost.exe に必要なメモリ (*F*) を推定します。</span><span class="sxs-lookup"><span data-stu-id="ae118-199">The first calculation estimates of memory needed by fdhost.exe-*F*.</span></span> <span data-ttu-id="ae118-200">クロール範囲の数は `8`です。</span><span class="sxs-lookup"><span data-stu-id="ae118-200">The number of crawl ranges is `8`.</span></span>  
  
 `F = 8*10*8=640`  
  
 <span data-ttu-id="ae118-201">次の計算では、M の最適な値を取得し `max server memory` - *M*ます。</span><span class="sxs-lookup"><span data-stu-id="ae118-201">The next calculation obtains the optimal value for `max server memory`-*M*.</span></span> <span data-ttu-id="ae118-202">*T*このシステムで使用可能な合計物理*メモリ (MB*) はです `8192` 。</span><span class="sxs-lookup"><span data-stu-id="ae118-202">*T*he total physical memory available on this system in MB-*T*-is `8192`.</span></span>  
  
 `M = 8192-640-500=7052`  
  
 <span data-ttu-id="ae118-203">**例:max server memory の設定**</span><span class="sxs-lookup"><span data-stu-id="ae118-203">**Example: Setting max server memory**</span></span>  
  
 <span data-ttu-id="ae118-204">この例では、 [sp_configure](/sql/relational-databases/system-stored-procedures/sp-configure-transact-sql)を使用し、前の例の M に対して[RECONFIGURE](/sql/t-sql/language-elements/reconfigure-transact-sql) [!INCLUDE[tsql](../../../includes/tsql-md.md)] 計算さ `max server memory` れた値に*M*設定するようにステートメントを再構成し `7052` ます。</span><span class="sxs-lookup"><span data-stu-id="ae118-204">This example uses the [sp_configure](/sql/relational-databases/system-stored-procedures/sp-configure-transact-sql) and [RECONFIGURE](/sql/t-sql/language-elements/reconfigure-transact-sql)[!INCLUDE[tsql](../../../includes/tsql-md.md)] statements to set `max server memory` to the value calculated for *M* in the preceding example, `7052`:</span></span>  
  
```  
USE master;  
GO  
EXEC sp_configure 'max server memory', 7052;  
GO  
RECONFIGURE;  
GO  
```  
  
 <span data-ttu-id="ae118-205">**max server memory 構成オプションを設定するには**</span><span class="sxs-lookup"><span data-stu-id="ae118-205">**To set the max server memory configuration option**</span></span>  
  
-   [<span data-ttu-id="ae118-206">サーバー メモリに関するサーバー構成オプション</span><span class="sxs-lookup"><span data-stu-id="ae118-206">Server Memory Server Configuration Options</span></span>](../../database-engine/configure-windows/server-memory-server-configuration-options.md)  
  
  
  
### <a name="factors-that-can-reduce-cpu-consumption"></a><span data-ttu-id="ae118-207">CPU 消費率の低下を招く要因</span><span class="sxs-lookup"><span data-stu-id="ae118-207">Factors that Can Reduce CPU Consumption</span></span>  
 <span data-ttu-id="ae118-208">平均 CPU 消費率が約 30% 未満になると、完全作成のパフォーマンスが低下すると考えられます。</span><span class="sxs-lookup"><span data-stu-id="ae118-208">We expect that the performance of full populations is not optimal when the average CPU consumption is lower than about 30 percent.</span></span> <span data-ttu-id="ae118-209">ここでは、CPU 消費率に影響するいくつかの要因について説明します。</span><span class="sxs-lookup"><span data-stu-id="ae118-209">This section discusses some factors that affect CPU consumption.</span></span>  
  
-   <span data-ttu-id="ae118-210">長いページ待機</span><span class="sxs-lookup"><span data-stu-id="ae118-210">High wait for pages</span></span>  
  
     <span data-ttu-id="ae118-211">ページ待機時間が長いかどうかを調べるには、次の [!INCLUDE[tsql](../../../includes/tsql-md.md)] ステートメントを実行します。</span><span class="sxs-lookup"><span data-stu-id="ae118-211">To find out whether a page wait time is high, execute the following [!INCLUDE[tsql](../../../includes/tsql-md.md)] statement:</span></span>  
  
    ```  
    Execute SELECT TOP 10 * FROM sys.dm_os_wait_stats ORDER BY wait_time_ms DESC;  
    ```  
  
     <span data-ttu-id="ae118-212">次の表で、主な待機の種類について説明します。</span><span class="sxs-lookup"><span data-stu-id="ae118-212">The following table describes the wait types of interest here.</span></span>  
  
    |<span data-ttu-id="ae118-213">待機の種類</span><span class="sxs-lookup"><span data-stu-id="ae118-213">Wait type</span></span>|<span data-ttu-id="ae118-214">説明</span><span class="sxs-lookup"><span data-stu-id="ae118-214">Description</span></span>|<span data-ttu-id="ae118-215">解決方法</span><span class="sxs-lookup"><span data-stu-id="ae118-215">Possible resolution</span></span>|  
    |---------------|-----------------|-------------------------|  
    |<span data-ttu-id="ae118-216">PAGEIO_LATCH_SH (_EX または _UP)</span><span class="sxs-lookup"><span data-stu-id="ae118-216">PAGEIO_LATCH_SH (_EX or _UP)</span></span>|<span data-ttu-id="ae118-217">IO がボトルネックとなっている可能性があります。この場合は通常、平均のディスク キューも長くなります。</span><span class="sxs-lookup"><span data-stu-id="ae118-217">This could indicate an IO bottleneck, in which case you would typically also see a high average disk-queue length.</span></span>|<span data-ttu-id="ae118-218">別のディスクの別のファイル グループにフルテキスト インデックスを移動すると、IO のボトルネックを軽減できる場合があります。</span><span class="sxs-lookup"><span data-stu-id="ae118-218">Moving the full-text index to a different filegroup on a different disk could help reduce the IO bottleneck.</span></span>|  
    |<span data-ttu-id="ae118-219">PAGELATCH_EX (または _UP)</span><span class="sxs-lookup"><span data-stu-id="ae118-219">PAGELATCH_EX (or _UP)</span></span>|<span data-ttu-id="ae118-220">複数のスレッドが同じデータベース ファイルへの書き込みを試行し、多数の競合が発生している可能性があります。</span><span class="sxs-lookup"><span data-stu-id="ae118-220">This could indicate a lot of contention among threads that are trying to write to the same database file.</span></span>|<span data-ttu-id="ae118-221">フルテキスト インデックスが格納されているファイル グループにファイルを追加すると、このような競合を軽減できる場合があります。</span><span class="sxs-lookup"><span data-stu-id="ae118-221">Adding files to the filegroup on which the fulltext index resides could help alleviate such contention.</span></span>|  
  
     <span data-ttu-id="ae118-222">詳細については、「[sys.dm_os_wait_stats &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-os-wait-stats-transact-sql)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="ae118-222">For more information, see [sys.dm_os_wait_stats &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-os-wait-stats-transact-sql).</span></span>  
  
-   <span data-ttu-id="ae118-223">非効率的なベース テーブル スキャン</span><span class="sxs-lookup"><span data-stu-id="ae118-223">Inefficiencies in scanning the base table</span></span>  
  
     <span data-ttu-id="ae118-224">完全作成では、バッチを生成するためにベース テーブルをスキャンします。</span><span class="sxs-lookup"><span data-stu-id="ae118-224">A full population scans the base table to produce batches.</span></span> <span data-ttu-id="ae118-225">次のようなシナリオでは、このテーブル スキャンの効率が下がる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="ae118-225">This table scanning could be inefficient in the following scenarios:</span></span>  
  
    -   <span data-ttu-id="ae118-226">フルテキスト インデックスが作成される行外の列がベース テーブルに高い比率で含まれている場合、バッチ生成のためのベース テーブル スキャンがボトルネックとなることがあります。</span><span class="sxs-lookup"><span data-stu-id="ae118-226">If the base table has a high percentage of out-of-row columns that are being full-text indexed, scanning the base table to produce batches might be the bottleneck.</span></span> <span data-ttu-id="ae118-227">その場合、`varchar(max)` または `nvarchar(max)` を使用して、比較的小さなデータを行内に移動すると解決することがあります。</span><span class="sxs-lookup"><span data-stu-id="ae118-227">In this case, moving the smaller data in-row using `varchar(max)` or `nvarchar(max)` might help.</span></span>  
  
    -   <span data-ttu-id="ae118-228">ベース テーブルが過度に断片化されていると、スキャンの効率が下がります。</span><span class="sxs-lookup"><span data-stu-id="ae118-228">If the base table is very fragmented, scanning might be inefficient.</span></span> <span data-ttu-id="ae118-229">行外データの計算とインデックスの断片化の詳細については、「[」sys.dm_db_partition_stats &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-partition-stats-transact-sql)」および「[sys.dm_db_index_physical_stats &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-index-physical-stats-transact-sql)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="ae118-229">For information about computing out-of-row data and index fragmentation, see [sys.dm_db_partition_stats &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-partition-stats-transact-sql) and [sys.dm_db_index_physical_stats &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-index-physical-stats-transact-sql).</span></span>  
  
         <span data-ttu-id="ae118-230">断片化を解消するには、クラスター化インデックスを再構成または再構築します。</span><span class="sxs-lookup"><span data-stu-id="ae118-230">To reduce fragmentation, you can reorganize or rebuild the clustered index.</span></span> <span data-ttu-id="ae118-231">詳細については、「 [インデックスの再編成と再構築](../indexes/reorganize-and-rebuild-indexes.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="ae118-231">For more information, see [Reorganize and Rebuild Indexes](../indexes/reorganize-and-rebuild-indexes.md).</span></span>  
  
  
  
##  <a name="troubleshooting-slow-indexing-performance-due-to-filters"></a><a name="filters"></a><span data-ttu-id="ae118-232">フィルター処理によるインデックス作成のパフォーマンスの低下のトラブルシューティング</span><span class="sxs-lookup"><span data-stu-id="ae118-232">Troubleshooting Slow Indexing Performance Due to Filters</span></span>  
 <span data-ttu-id="ae118-233">Full-Text Engine では、フルテキスト インデックスを作成するときに、マルチスレッド フィルターとシングル スレッド フィルターの 2 種類のフィルターを使用します。</span><span class="sxs-lookup"><span data-stu-id="ae118-233">When populating a full-text index, the Full-Text Engine uses two types of filters: multithreaded and single-threaded.</span></span> <span data-ttu-id="ae118-234">フィルター処理するドキュメントに応じて、マルチスレッド フィルターを使用する場合 ( [!INCLUDE[msCoName](../../includes/msconame-md.md)] Word 文書など) と、</span><span class="sxs-lookup"><span data-stu-id="ae118-234">Some documents, such as [!INCLUDE[msCoName](../../includes/msconame-md.md)] Word documents, are filtered using a multithreaded filter.</span></span> <span data-ttu-id="ae118-235">シングル スレッド フィルターを使用する場合 (Adobe Acrobat Portable Document Format (PDF) ドキュメントなど) があります。</span><span class="sxs-lookup"><span data-stu-id="ae118-235">Other documents, such as Adobe Acrobat Portable Document Format (PDF) documents, are filtered using a single-threaded filter.</span></span>  
  
 <span data-ttu-id="ae118-236">セキュリティ上の理由から、フィルターはフィルター デーモン ホスト プロセスによって読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="ae118-236">For security reasons, filters are loaded by filter daemon host processes.</span></span> <span data-ttu-id="ae118-237">サーバー インスタンスでは、マルチスレッド フィルターに対してはすべてマルチスレッド処理が使用され、シングル スレッド フィルターに対してはすべてシングル スレッド処理が使用されます。</span><span class="sxs-lookup"><span data-stu-id="ae118-237">A server instance uses a multithreaded process for all multithreaded filters and a single-threaded process for all single-threaded filters.</span></span> <span data-ttu-id="ae118-238">マルチスレッド フィルターを使用するドキュメントにシングル スレッド フィルターを使用するドキュメントが埋め込まれていると、Full-Text Engine では埋め込まれたドキュメントに対してシングル スレッド処理を開始します。</span><span class="sxs-lookup"><span data-stu-id="ae118-238">When a document that uses a multithreaded filter contains an embedded document that uses a single-threaded filter, the Full-Text Engine launches a single-threaded process for the embedded document.</span></span> <span data-ttu-id="ae118-239">たとえば、PDF ドキュメントが埋め込まれた Word 文書の場合、Full-Text Engine は、Word コンテンツに対してはマルチスレッド プロセスを使用し、PDF の内容に対してはシングル スレッド プロセスを開始します。</span><span class="sxs-lookup"><span data-stu-id="ae118-239">For example, on encountering a Word document that contains a PDF document, the Full-Text Engine uses the multithreaded process for the Word content and launches a single-threaded process for the PDF content.</span></span> <span data-ttu-id="ae118-240">ただし、このような環境では、シングル スレッド フィルターが適切に機能しない場合があり、フィルター処理が不安定になることがあります。</span><span class="sxs-lookup"><span data-stu-id="ae118-240">A single-threaded filter might not work well in this environment, however, and could destabilize the filtering process.</span></span> <span data-ttu-id="ae118-241">このような埋め込みが通例であるような特定の状況では、不安定になった結果、フィルター処理がクラッシュすることもあります。</span><span class="sxs-lookup"><span data-stu-id="ae118-241">In certain circumstances where such embedding is common, destabilization might lead to filtering-process crashes.</span></span> <span data-ttu-id="ae118-242">クラッシュが発生すると、エラーが発生したドキュメント (たとえば、PDF の内容が埋め込まれた Word 文書) がシングル スレッド フィルター処理に再ルーティングされます。</span><span class="sxs-lookup"><span data-stu-id="ae118-242">When this occurs, the Full-Text Engine re-routes any failed document (for example, a Word document that contains embedded PDF content) to the single-threaded filtering process.</span></span> <span data-ttu-id="ae118-243">再ルーティングが頻繁に起こると、フルテキスト インデックス作成処理のパフォーマンスが低下します。</span><span class="sxs-lookup"><span data-stu-id="ae118-243">If re-routing occurs frequently, it results in performance degradation of the full-text indexing process.</span></span>  
  
 <span data-ttu-id="ae118-244">この問題を回避するには、コンテナー ドキュメント (この場合は Word) に対するフィルターとして、シングル スレッド フィルターを設定します。</span><span class="sxs-lookup"><span data-stu-id="ae118-244">To work around this problem, mark the filter for the container document (Word in this case) as a single-threaded filter.</span></span> <span data-ttu-id="ae118-245">フィルターのレジストリ値を変更して、特定のフィルターをシングル スレッド フィルターとして設定できます。</span><span class="sxs-lookup"><span data-stu-id="ae118-245">You can change the filter registry value to mark a given filter as a single-threaded filter.</span></span> <span data-ttu-id="ae118-246">フィルターをシングルスレッドフィルターとしてマークするには、フィルターの**ThreadingModel**レジストリ値をに設定する必要があり `Apartment Threaded` ます。</span><span class="sxs-lookup"><span data-stu-id="ae118-246">To mark a filter as a single-threaded filter, you need to set the **ThreadingModel** registry value for the filter to `Apartment Threaded`.</span></span> <span data-ttu-id="ae118-247">シングル スレッド アパートメントの詳細については、ホワイト ペーパー「 [COM スレッド モデルの概要と使用方法](https://go.microsoft.com/fwlink/?LinkId=209159)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="ae118-247">For information about single-threaded apartments, see the white paper [Understanding and Using COM Threading Models](https://go.microsoft.com/fwlink/?LinkId=209159).</span></span>  
  
  
  
## <a name="see-also"></a><span data-ttu-id="ae118-248">参照</span><span class="sxs-lookup"><span data-stu-id="ae118-248">See Also</span></span>  
 <span data-ttu-id="ae118-249">[サーバー メモリに関するサーバー構成オプション](../../database-engine/configure-windows/server-memory-server-configuration-options.md) </span><span class="sxs-lookup"><span data-stu-id="ae118-249">[Server Memory Server Configuration Options](../../database-engine/configure-windows/server-memory-server-configuration-options.md) </span></span>  
 <span data-ttu-id="ae118-250">[max full-text crawl range サーバー構成オプション](../../database-engine/configure-windows/max-full-text-crawl-range-server-configuration-option.md) </span><span class="sxs-lookup"><span data-stu-id="ae118-250">[max full-text crawl range Server Configuration Option](../../database-engine/configure-windows/max-full-text-crawl-range-server-configuration-option.md) </span></span>  
 <span data-ttu-id="ae118-251">[フルテキスト インデックスの作成](populate-full-text-indexes.md) </span><span class="sxs-lookup"><span data-stu-id="ae118-251">[Populate Full-Text Indexes](populate-full-text-indexes.md) </span></span>  
 <span data-ttu-id="ae118-252">[フルテキスト インデックスの作成と管理](create-and-manage-full-text-indexes.md) </span><span class="sxs-lookup"><span data-stu-id="ae118-252">[Create and Manage Full-Text Indexes](create-and-manage-full-text-indexes.md) </span></span>  
 <span data-ttu-id="ae118-253">[sys.dm_fts_memory_buffers &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-fts-memory-buffers-transact-sql) </span><span class="sxs-lookup"><span data-stu-id="ae118-253">[sys.dm_fts_memory_buffers &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-fts-memory-buffers-transact-sql) </span></span>  
 <span data-ttu-id="ae118-254">[sys.dm_fts_memory_pools &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-fts-memory-pools-transact-sql) </span><span class="sxs-lookup"><span data-stu-id="ae118-254">[sys.dm_fts_memory_pools &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-fts-memory-pools-transact-sql) </span></span>  
 [<span data-ttu-id="ae118-255">フルテキスト インデックスの作成のトラブルシューティング</span><span class="sxs-lookup"><span data-stu-id="ae118-255">Troubleshoot Full-Text Indexing</span></span>](troubleshoot-full-text-indexing.md)  
  
  
