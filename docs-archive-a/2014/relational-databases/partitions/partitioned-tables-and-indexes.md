---
title: パーティション テーブルとパーティション インデックス | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: ''
ms.topic: conceptual
helpviewer_keywords:
- partitioned tables [SQL Server], about partitioned tables
- partitioned indexes [SQL Server], architecture
- partitioned tables [SQL Server], architecture
- partitioned indexes [SQL Server], about partitioned indexes
ms.assetid: cc5bf181-18a0-44d5-8bd7-8060d227c927
author: MikeRayMSFT
ms.author: mikeray
ms.openlocfilehash: e8d041abcfe491f311e38bc8dab4be4ea253e37c
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/04/2020
ms.locfileid: "87739763"
---
# <a name="partitioned-tables-and-indexes"></a><span data-ttu-id="a0442-102">パーティション テーブルとパーティション インデックス</span><span class="sxs-lookup"><span data-stu-id="a0442-102">Partitioned Tables and Indexes</span></span>
  [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] <span data-ttu-id="a0442-103">では、テーブルおよびインデックスのパーティション分割をサポートします。</span><span class="sxs-lookup"><span data-stu-id="a0442-103">supports table and index partitioning.</span></span> <span data-ttu-id="a0442-104">パーティション テーブルとパーティション インデックスのデータは、データベース内の複数のファイル グループに分散できるように、複数の単位に分割されます。</span><span class="sxs-lookup"><span data-stu-id="a0442-104">The data of partitioned tables and indexes is divided into units that can be spread across more than one filegroup in a database.</span></span> <span data-ttu-id="a0442-105">行のグループが各パーティションにマップされるように、データは行方向にパーティション分割されます。</span><span class="sxs-lookup"><span data-stu-id="a0442-105">The data is partitioned horizontally, so that groups of rows are mapped into individual partitions.</span></span> <span data-ttu-id="a0442-106">1 つのインデックスまたはテーブルのすべてのパーティションは、同じデータベース内に存在する必要があります。</span><span class="sxs-lookup"><span data-stu-id="a0442-106">All partitions of a single index or table must reside in the same database.</span></span> <span data-ttu-id="a0442-107">データに対するクエリまたは更新の実行時は、テーブルやインデックスが 1 つの論理エンティティとして扱われます。</span><span class="sxs-lookup"><span data-stu-id="a0442-107">The table or index is treated as a single logical entity when queries or updates are performed on the data.</span></span> <span data-ttu-id="a0442-108">パーティション テーブルとパーティション インデックスは、[!INCLUDE[msCoName](../../includes/msconame-md.md)][!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] のすべてのエディションで使用できるわけではありません。</span><span class="sxs-lookup"><span data-stu-id="a0442-108">Partitioned tables and indexes are not available in every edition of [!INCLUDE[msCoName](../../includes/msconame-md.md)][!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="a0442-109">の各エディションでサポートされる機能の一覧につい [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] ては、「 [SQL Server 2014 の各エディションがサポートする機能](../../getting-started/features-supported-by-the-editions-of-sql-server-2014.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="a0442-109">For a list of features that are supported by the editions of [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], see [Features Supported by the Editions of SQL Server 2014](../../getting-started/features-supported-by-the-editions-of-sql-server-2014.md).</span></span>  
  
> [!IMPORTANT]  
>  [!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)] <span data-ttu-id="a0442-110">では、既定で最大 15,000 個のパーティションをサポートします。</span><span class="sxs-lookup"><span data-stu-id="a0442-110">supports up to 15,000 partitions by default.</span></span> <span data-ttu-id="a0442-111">[!INCLUDE[ssSQL11](../../includes/sssql11-md.md)]より前のバージョンでは、パーティションの数は既定で 1,000 個に限られていました。x86 ベースのシステムでは、パーティション数が 1,000 個を超えるテーブルまたはインデックスを作成できますが、それはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="a0442-111">In versions earlier than [!INCLUDE[ssSQL11](../../includes/sssql11-md.md)], the number of partitions was limited to 1,000 by default.On x86-based systems, creating a table or index with more than 1000 partitions is possible, but is not supported.</span></span>  
  
## <a name="benefits-of-partitioning"></a><span data-ttu-id="a0442-112">パーティション分割の利点</span><span class="sxs-lookup"><span data-stu-id="a0442-112">Benefits of Partitioning</span></span>  
 <span data-ttu-id="a0442-113">大きなテーブルやインデックスをパーティション分割することで、次のような管理上およびパフォーマンス上の利点が得られます。</span><span class="sxs-lookup"><span data-stu-id="a0442-113">Partitioning large tables or indexes can have the following manageability and performance benefits.</span></span>  
  
-   <span data-ttu-id="a0442-114">データ コレクション全体の整合性を保ちながら、データ サブセットの転送やアクセスを迅速かつ効率的に行うことができるようになります。</span><span class="sxs-lookup"><span data-stu-id="a0442-114">You can transfer or access subsets of data quickly and efficiently, while maintaining the integrity of a data collection.</span></span> <span data-ttu-id="a0442-115">たとえば、OLTP システムから OLAP システムへのデータの読み込みなどの操作は、データがパーティション分割されていない場合は数分から数時間かかりますが、数秒で実行されるようになります。</span><span class="sxs-lookup"><span data-stu-id="a0442-115">For example, an operation such as loading data from an OLTP to an OLAP system takes only seconds, instead of the minutes and hours the operation takes when the data is not partitioned.</span></span>  
  
-   <span data-ttu-id="a0442-116">1 つまたは複数のパーティションでのメンテナンス操作をより迅速に実行できます。</span><span class="sxs-lookup"><span data-stu-id="a0442-116">You can perform maintenance operations on one or more partitions more quickly.</span></span> <span data-ttu-id="a0442-117">テーブル全体ではなく、これらのデータ サブセットのみを対象にできるので、操作がより効率化されます。</span><span class="sxs-lookup"><span data-stu-id="a0442-117">The operations are more efficient because they target only these data subsets, instead of the whole table.</span></span> <span data-ttu-id="a0442-118">たとえば、1 つまたは複数のパーティションでデータを圧縮するか、インデックスの 1 つまたは複数のパーティションを再構築するかを選択できます。</span><span class="sxs-lookup"><span data-stu-id="a0442-118">For example, you can choose to compress data in one or more partitions or rebuild one or more partitions of an index.</span></span>  
  
-   <span data-ttu-id="a0442-119">頻繁に実行するクエリの種類とハードウェア構成に基づいて、クエリのパフォーマンスを改善できる場合があります。</span><span class="sxs-lookup"><span data-stu-id="a0442-119">You may improve query performance, based on the types of queries you frequently run and on your hardware configuration.</span></span> <span data-ttu-id="a0442-120">たとえば、クエリ オプティマイザーで 2 つ以上のパーティション テーブル間の等結合クエリを行う場合、そのテーブル内のパーティション分割列が同じであれば、パーティション自体を結合できるので処理がより迅速になります。</span><span class="sxs-lookup"><span data-stu-id="a0442-120">For example, the query optimizer can process equi-join queries between two or more partitioned tables faster when the partitioning columns in the tables are the same, because the partitions themselves can be joined.</span></span>  
  
     <span data-ttu-id="a0442-121">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] により I/O 操作用にデータの並べ替えが実行される場合、まずパーティションでデータが並べ替えられます。</span><span class="sxs-lookup"><span data-stu-id="a0442-121">When [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] performs data sorting for I/O operations, it sorts the data first by partition.</span></span> [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] <span data-ttu-id="a0442-122">では、一度に 1 つのドライブにしかアクセスできないので、パフォーマンスが低下することがあります。</span><span class="sxs-lookup"><span data-stu-id="a0442-122">accesses one drive at a time, and this might reduce performance.</span></span> <span data-ttu-id="a0442-123">データの並べ替えのパフォーマンスを向上させるには、RAID を構成して複数のディスク間でパーティションのデータ ファイルをストライプします。</span><span class="sxs-lookup"><span data-stu-id="a0442-123">To improve data sorting performance, stripe the data files of your partitions across more than one disk by setting up a RAID.</span></span> <span data-ttu-id="a0442-124">この方法を使用すると、 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] では今までどおりデータがパーティションで並べ替えられますが、すべてのドライブの各パーティションに同時にアクセスできるようになります。</span><span class="sxs-lookup"><span data-stu-id="a0442-124">In this way, although [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] still sorts data by partition, it can access all the drives of each partition at the same time.</span></span>  
  
     <span data-ttu-id="a0442-125">さらに、テーブル全体ではなくパーティション レベルでのロックのエスカレーションを有効にしてパフォーマンスを向上させることができます。</span><span class="sxs-lookup"><span data-stu-id="a0442-125">In addition, you can improve performance by enabling lock escalation at the partition level instead of a whole table.</span></span> <span data-ttu-id="a0442-126">これにより、テーブルでのロックの競合を減らすことができます。</span><span class="sxs-lookup"><span data-stu-id="a0442-126">This can reduce lock contention on the table.</span></span>  
  
## <a name="components-and-concepts"></a><span data-ttu-id="a0442-127">コンポーネントおよび概念</span><span class="sxs-lookup"><span data-stu-id="a0442-127">Components and Concepts</span></span>  
 <span data-ttu-id="a0442-128">テーブルおよびインデックスのパーティション分割に関連する用語を次に示します。</span><span class="sxs-lookup"><span data-stu-id="a0442-128">The following terms are applicable to table and index partitioning.</span></span>  
  
 <span data-ttu-id="a0442-129">パーティション関数</span><span class="sxs-lookup"><span data-stu-id="a0442-129">Partition function</span></span>  
 <span data-ttu-id="a0442-130">テーブルまたはインデックスの行を、パーティション分割列と呼ばれる特定の列の値に基づいて、一連のパーティションにマップする方法を定義するデータベース オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="a0442-130">A database object that defines how the rows of a table or index are mapped to a set of partitions based on the values of certain column, called a partitioning column.</span></span> <span data-ttu-id="a0442-131">つまり、テーブルのパーティションの数とパーティションの境界の定義方法は、パーティション関数によって定義されます。</span><span class="sxs-lookup"><span data-stu-id="a0442-131">That is, the partition function defines the number of partitions that the table will have and how the boundaries of the partitions are defined.</span></span> <span data-ttu-id="a0442-132">たとえば、販売注文データを格納するテーブルの場合、販売日などの `datetime` 列に基づいて、月別の 12 のパーションに分割できます。</span><span class="sxs-lookup"><span data-stu-id="a0442-132">For example, given a table that contains sales order data, you may want to partition the table into twelve (monthly) partitions based on a `datetime` column such as a sales date.</span></span>  
  
 <span data-ttu-id="a0442-133">パーティション構成</span><span class="sxs-lookup"><span data-stu-id="a0442-133">Partition scheme</span></span>  
 <span data-ttu-id="a0442-134">パーティション関数のパーティションを一連のファイル グループにマップするデータベース オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="a0442-134">A database object that maps the partitions of a partition function to a set of filegroups.</span></span> <span data-ttu-id="a0442-135">パーティションを別々のファイル グループに配置する主な理由は、パーティションのバックアップ操作を個別に実行できるようにすることです。</span><span class="sxs-lookup"><span data-stu-id="a0442-135">The primary reason for placing your partitions on separate filegroups is to make sure that you can independently perform backup operations on partitions.</span></span> <span data-ttu-id="a0442-136">これは、バックアップを個別のファイル グループで実行できるからです。</span><span class="sxs-lookup"><span data-stu-id="a0442-136">This is because you can perform backups on individual filegroups.</span></span>  
  
 <span data-ttu-id="a0442-137">パーティション分割列</span><span class="sxs-lookup"><span data-stu-id="a0442-137">Partitioning column</span></span>  
 <span data-ttu-id="a0442-138">パーティション関数が、テーブルまたはインデックスをパーティション分割するために使用するテーブルまたはインデックスの列。</span><span class="sxs-lookup"><span data-stu-id="a0442-138">The column of a table or index that a partition function uses to partition the table or index.</span></span> <span data-ttu-id="a0442-139">パーティション関数に参加する計算列は、明示的に PERSISTED とマークされている必要があります。</span><span class="sxs-lookup"><span data-stu-id="a0442-139">Computed columns that participate in a partition function must be explicitly marked PERSISTED.</span></span> <span data-ttu-id="a0442-140">`timestamp` 型を除き、インデックス列として使用できるすべてのデータ型をパーティション分割列として使用できます。</span><span class="sxs-lookup"><span data-stu-id="a0442-140">All data types that are valid for use as index columns can be used as a partitioning column, except `timestamp`.</span></span> <span data-ttu-id="a0442-141">`ntext` 型、`text` 型、`image` 型、`xml` 型、`varchar(max)` 型、`nvarchar(max)` 型、および `varbinary(max)` 型は指定できません。</span><span class="sxs-lookup"><span data-stu-id="a0442-141">The `ntext`, `text`, `image`, `xml`, `varchar(max)`, `nvarchar(max)`, or `varbinary(max)` data types cannot be specified.</span></span> <span data-ttu-id="a0442-142">また、Microsoft .NET Framework 共通言語ランタイム (CLR) ユーザー定義型の列とエイリアス データ型の列を指定することはできません。</span><span class="sxs-lookup"><span data-stu-id="a0442-142">Also, Microsoft .NET Framework common language runtime (CLR) user-defined type and alias data type columns cannot be specified.</span></span>  
  
 <span data-ttu-id="a0442-143">固定されたインデックス</span><span class="sxs-lookup"><span data-stu-id="a0442-143">Aligned index</span></span>  
 <span data-ttu-id="a0442-144">対応するテーブルと同じパーティション構成に基づいて構築されたインデックス。</span><span class="sxs-lookup"><span data-stu-id="a0442-144">An index that is built on the same partition scheme as its corresponding table.</span></span> <span data-ttu-id="a0442-145">テーブルとインデックスが固定されている状態では、両者のパーティション構造を保ったまま SQL Server がパーティションをすばやく効率的に切り替えることができます。</span><span class="sxs-lookup"><span data-stu-id="a0442-145">When a table and its indexes are in alignment, SQL Server can switch partitions quickly and efficiently while maintaining the partition structure of both the table and its indexes.</span></span> <span data-ttu-id="a0442-146">ベース テーブルに固定させるために、インデックスを同じ名前のパーティション関数に加える必要はありません。</span><span class="sxs-lookup"><span data-stu-id="a0442-146">An index does not have to participate in the same named partition function to be aligned with its base table.</span></span> <span data-ttu-id="a0442-147">ただし、インデックスとベース テーブルのパーティション関数は、本質的に同一 (つまり、1) 引数のデータ型が同一、2) 定義されるパーティションの数が同一、3) 定義されるパーティションの境界値が同一) である必要があります。</span><span class="sxs-lookup"><span data-stu-id="a0442-147">However, the partition function of the index and the base table must be essentially the same, in that 1) the arguments of the partition functions have the same data type, 2) they define the same number of partitions, and 3) they define the same boundary values for partitions.</span></span>  
  
 <span data-ttu-id="a0442-148">固定されていないインデックス</span><span class="sxs-lookup"><span data-stu-id="a0442-148">Nonaligned index</span></span>  
 <span data-ttu-id="a0442-149">対応するパーティション テーブルから個別に分割されたインデックス。</span><span class="sxs-lookup"><span data-stu-id="a0442-149">An index partitioned independently from its corresponding table.</span></span> <span data-ttu-id="a0442-150">つまり、インデックスのパーティション構成が異なっているか、インデックスがベース テーブルとは別のファイル グループに配置されています。</span><span class="sxs-lookup"><span data-stu-id="a0442-150">That is, the index has a different partition scheme or is placed on a separate filegroup from the base table.</span></span> <span data-ttu-id="a0442-151">次のような場合、固定されていないパーティション インデックスをデザインすると便利です。</span><span class="sxs-lookup"><span data-stu-id="a0442-151">Designing an nonaligned partitioned index can be useful in the following cases:</span></span>  
  
-   <span data-ttu-id="a0442-152">ベース テーブルがパーティション分割されていない。</span><span class="sxs-lookup"><span data-stu-id="a0442-152">The base table has not been partitioned.</span></span>  
  
-   <span data-ttu-id="a0442-153">インデックス キーが一意であり、テーブルのパーティション分割列を含んでいない。</span><span class="sxs-lookup"><span data-stu-id="a0442-153">The index key is unique and it does not contain the partitioning column of the table.</span></span>  
  
-   <span data-ttu-id="a0442-154">異なる結合列を使用して多くのテーブルが併置されている結合にベース テーブルを加える。</span><span class="sxs-lookup"><span data-stu-id="a0442-154">You want the base table to participate in collocated joins with more tables using different join columns.</span></span>  
  
 <span data-ttu-id="a0442-155">パーティションの解消</span><span class="sxs-lookup"><span data-stu-id="a0442-155">Partition elimination</span></span>  
 <span data-ttu-id="a0442-156">クエリ オプティマイザーがクエリのフィルター条件を満たすために、関連するパーティションのみにアクセスするときに使用されるプロセス。</span><span class="sxs-lookup"><span data-stu-id="a0442-156">The process by which the query optimizer accesses only the relevant partitions to satisfy the filter criteria of the query.</span></span>  
  
## <a name="performance-guidelines"></a><span data-ttu-id="a0442-157">パフォーマンスに関するガイドライン</span><span class="sxs-lookup"><span data-stu-id="a0442-157">Performance Guidelines</span></span>  
 <span data-ttu-id="a0442-158">新しいパーティション数の制限が 15,000 になったことは、メモリ、パーティション インデックス操作、DBCC コマンド、およびクエリに影響します。</span><span class="sxs-lookup"><span data-stu-id="a0442-158">The new, higher limit of 15,000 partitions affects memory, partitioned index operations, DBCC commands, and queries.</span></span> <span data-ttu-id="a0442-159">ここでは、パーティション数が 1,000 を超えた場合のパフォーマンスへの影響について説明し、必要に応じた回避策を示します。</span><span class="sxs-lookup"><span data-stu-id="a0442-159">This section describes the performance implications of increasing the number of partitions above 1,000 and provides workarounds as needed.</span></span> <span data-ttu-id="a0442-160">パーティション数の上限が 15,000 になると、データを保存できる期間が長くなります。</span><span class="sxs-lookup"><span data-stu-id="a0442-160">With the limit on the maximum number of partitions being increased to 15,000, you can store data for a longer time.</span></span> <span data-ttu-id="a0442-161">ただし、データの保持期間は必要最小限とし、パフォーマンスとパーティション数とのバランスをとる必要があります。</span><span class="sxs-lookup"><span data-stu-id="a0442-161">However, you should retain data only for as long as it is needed and maintain a balance between performance and number of partitions.</span></span>  
  
### <a name="memory-usage-and-guidelines"></a><span data-ttu-id="a0442-162">メモリ使用量とガイドライン</span><span class="sxs-lookup"><span data-stu-id="a0442-162">Memory Usage and Guidelines</span></span>  
 <span data-ttu-id="a0442-163">使用するパーティション数が多い場合は、16 GB 以上の RAM を使用することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="a0442-163">We recommend that you use at least 16 GB of RAM if a large number of partitions are in use.</span></span> <span data-ttu-id="a0442-164">システムに十分なメモリがない場合は、データ操作言語 (DML) ステートメント、データ定義言語 (DDL) ステートメント、およびその他の処理においてメモリ不足によるエラーが発生する場合があります。</span><span class="sxs-lookup"><span data-stu-id="a0442-164">If the system does not have enough memory, Data Manipulation Language (DML) statements, Data Definition Language (DDL) statements and other operations can fail due to insufficient memory.</span></span> <span data-ttu-id="a0442-165">16 GB の RAM を搭載したシステムでメモリを集中的に使用するプロセスが多数実行される場合は、多数のパーティションで実行される操作でメモリが不足する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="a0442-165">Systems with 16 GB of RAM that run many memory-intensive processes may run out of memory on operations that run on a large number of partitions.</span></span> <span data-ttu-id="a0442-166">したがって、メモリを 16 GB よりも大きくするほど、パフォーマンスとメモリの問題が少なくなります。</span><span class="sxs-lookup"><span data-stu-id="a0442-166">Therefore, the more memory you have over 16 GB, the less likely you are to encounter performance and memory issues.</span></span>  
  
 <span data-ttu-id="a0442-167">SQL Server でパーティション インデックスを作成するパフォーマンスは、メモリにより制限される場合があります。</span><span class="sxs-lookup"><span data-stu-id="a0442-167">Memory limitations can affect the performance or ability of SQL Server to build a partitioned index.</span></span> <span data-ttu-id="a0442-168">テーブルに既にクラスター化インデックスが適用されている場合、パーティション インデックスがベース テーブルまたはクラスター化インデックスに固定されていないとメモリによる制限を特に受けます。</span><span class="sxs-lookup"><span data-stu-id="a0442-168">This is especially the case when the index is not aligned with its base table or is not aligned with its clustered index, if the table already has a clustered index applied to it.</span></span>  
  
### <a name="partitioned-index-operations"></a><span data-ttu-id="a0442-169">パーティション インデックス操作</span><span class="sxs-lookup"><span data-stu-id="a0442-169">Partitioned Index Operations</span></span>  
 <span data-ttu-id="a0442-170">SQL Server でパーティション インデックスを作成するパフォーマンスは、メモリにより制限される場合があります。</span><span class="sxs-lookup"><span data-stu-id="a0442-170">Memory limitations can affect the performance or ability of SQL Server to build a partitioned index.</span></span> <span data-ttu-id="a0442-171">固定されていないインデックスの場合は、特に影響を受けます。</span><span class="sxs-lookup"><span data-stu-id="a0442-171">This is especially the case with nonaligned indexes.</span></span> <span data-ttu-id="a0442-172">固定されていないインデックスをパーティションが 1, 000 個以上あるテーブルに作成または再構築することは可能ですが、サポートされていません。</span><span class="sxs-lookup"><span data-stu-id="a0442-172">Creating and rebuilding nonaligned indexes on a table with more than 1,000 partitions is possible, but is not supported.</span></span> <span data-ttu-id="a0442-173">このような操作を行うと、操作中にパフォーマンスが低下したりメモリが過度に消費される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="a0442-173">Doing so may cause degraded performance or excessive memory consumption during these operations.</span></span>  
  
 <span data-ttu-id="a0442-174">固定されたインデックスの作成および再構築にかかる時間は、パーティション数が増えるにつれて長くなります。</span><span class="sxs-lookup"><span data-stu-id="a0442-174">Creating and rebuilding aligned indexes could take longer to execute as the number of partitions increases.</span></span> <span data-ttu-id="a0442-175">パフォーマンスおよびメモリの問題を回避するために、インデックスの作成および再構築の複数のコマンドを同時に実行しないことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="a0442-175">We recommend that you do not run multiple create and rebuild index commands at the same time as you may run into performance and memory issues.</span></span>  
  
 <span data-ttu-id="a0442-176">SQL Server でパーティション インデックスを作成するための並べ替えを実行するとき、最初にパーティションごとに 1 つの並べ替えテーブルが作成されます。</span><span class="sxs-lookup"><span data-stu-id="a0442-176">When SQL Server performs sorting to build partitioned indexes, it first builds one sort table for each partition.</span></span> <span data-ttu-id="a0442-177">次に、各パーティションのそれぞれのファイル グループ、または SORT_IN_TEMPDB インデックス オプションが指定されている場合は `tempdb` で並べ替えテーブルが作成されます。</span><span class="sxs-lookup"><span data-stu-id="a0442-177">It then builds the sort tables either in the respective filegroup of each partition or in `tempdb`, if the SORT_IN_TEMPDB index option is specified.</span></span> <span data-ttu-id="a0442-178">1 つの並べ替えテーブルを作成するために最低限必要なメモリの量が決まっています。</span><span class="sxs-lookup"><span data-stu-id="a0442-178">Each sort table requires a minimum amount of memory to build.</span></span> <span data-ttu-id="a0442-179">ベース テーブルに固定するパーティション インデックスを作成すると、並べ替えテーブルは一度に 1 つずつ作成されるのでメモリの消費を抑えることができます。</span><span class="sxs-lookup"><span data-stu-id="a0442-179">When you are building a partitioned index that is aligned with its base table, sort tables are built one at a time, using less memory.</span></span> <span data-ttu-id="a0442-180">しかし、固定されないパーティション インデックスを作成すると、複数の並べ替えテーブルが同時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="a0442-180">However, when you are building a nonaligned partitioned index, the sort tables are built at the same time.</span></span> <span data-ttu-id="a0442-181">そのため、このように同時に並べ替えを行うには十分なメモリが必要です。</span><span class="sxs-lookup"><span data-stu-id="a0442-181">As a result, there must be sufficient memory to handle these concurrent sorts.</span></span> <span data-ttu-id="a0442-182">パーティションの数が多いと、必要なメモリも増えます。</span><span class="sxs-lookup"><span data-stu-id="a0442-182">The larger the number of partitions, the more memory required.</span></span> <span data-ttu-id="a0442-183">1 つの並べ替えテーブル、つまりパーティションあたり最低必要なサイズは 40 ページ (1 ページは 8 KB) です。</span><span class="sxs-lookup"><span data-stu-id="a0442-183">The minimum size for each sort table, for each partition, is 40 pages, with 8 kilobytes per page.</span></span> <span data-ttu-id="a0442-184">たとえば、100 個のパーティションから構成される固定されないパーティション インデックスは、同時に 4,000 (40 \* 100) ページを同時に並べ替えることができるメモリが必要です。</span><span class="sxs-lookup"><span data-stu-id="a0442-184">For example, a nonaligned partitioned index with 100 partitions requires sufficient memory to serially sort 4,000 (40 \* 100) pages at the same time.</span></span> <span data-ttu-id="a0442-185">これだけのメモリを使用できれば、作成操作は成功しますがパフォーマンスが低下する場合があります。</span><span class="sxs-lookup"><span data-stu-id="a0442-185">If this memory is available, the build operation will succeed, but performance may suffer.</span></span> <span data-ttu-id="a0442-186">これだけのメモリを使用できない場合、作成操作は失敗します。</span><span class="sxs-lookup"><span data-stu-id="a0442-186">If this memory is not available, the build operation will fail.</span></span> <span data-ttu-id="a0442-187">一方、100 個のパーティションから構成される固定されたパーティション インデックスは、複数の並べ替えが同時に行われることがないので、40 ページを並べ替えることができるメモリがあれば十分です。</span><span class="sxs-lookup"><span data-stu-id="a0442-187">Alternatively, an aligned partitioned index with 100 partitions requires only sufficient memory to sort 40 pages, because the sorts are not performed at the same time.</span></span>  
  
 <span data-ttu-id="a0442-188">固定されたインデックス、固定されないインデックスを問わず、SQL Server がマルチプロセッサ コンピューターで 2 次以上の並列処理によって作成操作を実行している場合、メモリの要件がさらに高くなる場合もあります。</span><span class="sxs-lookup"><span data-stu-id="a0442-188">For both aligned and nonaligned indexes, the memory requirement can be greater if SQL Server is applying degrees of parallelism to the build operation on a multiprocessor computer.</span></span> <span data-ttu-id="a0442-189">これは並列処理の次数が多いと、メモリの要件も高くなるためです。</span><span class="sxs-lookup"><span data-stu-id="a0442-189">This is because the greater the degrees of parallelism, the greater the memory requirement.</span></span> <span data-ttu-id="a0442-190">たとえば、SQL Server の並列処理の次数が 4 に設定されている場合、100 個のパーティションから構成される固定されないパーティション インデックスは、同時に 4 基のプロセッサで 4,000 ページを並べ替えるために 16,000 ページ分のメモリが必要です。</span><span class="sxs-lookup"><span data-stu-id="a0442-190">For example, if SQL Server sets degrees of parallelism to 4, a nonaligned partitioned index with 100 partitions requires sufficient memory for four processors to sort 4,000 pages at the same time, or 16,000 pages.</span></span> <span data-ttu-id="a0442-191">パーティション インデックスが固定されている場合、4 基のプロセッサで 40 ページを並べ替えるため、メモリの要件は 160 (4 \* 40) ページまで下がります。</span><span class="sxs-lookup"><span data-stu-id="a0442-191">If the partitioned index is aligned, the memory requirement is reduced to four processors sorting 40 pages, or 160 (4 \* 40) pages.</span></span> <span data-ttu-id="a0442-192">MAXDOP インデックス オプションを使用して、手動で並列処理の次数を減らすことができます。</span><span class="sxs-lookup"><span data-stu-id="a0442-192">You can use the MAXDOP index option to manually reduce the degrees of parallelism.</span></span>  
  
### <a name="dbcc-commands"></a><span data-ttu-id="a0442-193">DBCC コマンド</span><span class="sxs-lookup"><span data-stu-id="a0442-193">DBCC Commands</span></span>  
 <span data-ttu-id="a0442-194">パーティション数が多い場合、DBCC コマンドの実行にかかる時間は、パーティション数が増えるほど長くなります。</span><span class="sxs-lookup"><span data-stu-id="a0442-194">With a larger number of partitions, DBCC commands could take longer to execute as the number of partitions increases.</span></span>  
  
### <a name="queries"></a><span data-ttu-id="a0442-195">クエリ</span><span class="sxs-lookup"><span data-stu-id="a0442-195">Queries</span></span>  
 <span data-ttu-id="a0442-196">パーティションの解消を使用するクエリは、パーティション数が多くなると、それに応じてパフォーマンスが向上する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="a0442-196">Queries that use partition elimination could have comparable or improved performance with larger number of partitions.</span></span> <span data-ttu-id="a0442-197">パーティションの解消を使用しないクエリの場合、その実行にかかる時間は、パーティション数が増えるほど長くなります。</span><span class="sxs-lookup"><span data-stu-id="a0442-197">Queries that do not use partition elimination could take longer to execute as the number of partitions increases.</span></span>  
  
 <span data-ttu-id="a0442-198">たとえば、テーブルの行数が 10 億で、 `A`、 `B`、および `C`の列があるとします。</span><span class="sxs-lookup"><span data-stu-id="a0442-198">For example, assume a table has 100 million rows and columns `A`, `B`, and `C`.</span></span> <span data-ttu-id="a0442-199">シナリオ 1 では、テーブルが列 `A`で 1,000 個のパーティションに分割されます</span><span class="sxs-lookup"><span data-stu-id="a0442-199">In scenario 1, the table is divided into 1000 partitions on column `A`.</span></span> <span data-ttu-id="a0442-200">シナリオ 2 では、テーブルが列 `A`で 10,000 個のパーティションに分割されます</span><span class="sxs-lookup"><span data-stu-id="a0442-200">In scenario 2, the table is divided into 10,000 partitions on column `A`.</span></span> <span data-ttu-id="a0442-201">列 `A` でフィルタリングする WHERE 句を持つテーブルでのクエリは、パーティションの解消を実行し、1 つのパーティションをスキャンします。</span><span class="sxs-lookup"><span data-stu-id="a0442-201">A query on the table that has a WHERE clause filtering on column `A` will perform partition elimination and scan one partition.</span></span> <span data-ttu-id="a0442-202">シナリオ 2 の場合は、パーティション内でスキャンする行数が少ないので、同じクエリがより高速に実行される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="a0442-202">That same query may run faster in scenario 2 as there are fewer rows to scan in a partition.</span></span> <span data-ttu-id="a0442-203">列 B でフィルタリングする WHERE 句を持つクエリは、すべてのパーティションをスキャンします。</span><span class="sxs-lookup"><span data-stu-id="a0442-203">A query that has a WHERE clause filtering on column B will scan all partitions.</span></span> <span data-ttu-id="a0442-204">シナリオ 1 の場合は、スキャンするパーティション数が少ないので、同じクエリがシナリオ 2 より高速に実行される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="a0442-204">The query may run faster in scenario 1 than in scenario 2 as there are fewer partitions to scan.</span></span>  
  
 <span data-ttu-id="a0442-205">パーティション分割列以外の列に対して TOP や MAX/MIN のような演算子を使用するクエリは、すべてのパーティションを評価する必要があるため、パーティション分割によってパフォーマンスが低下する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="a0442-205">Queries that use operators such as TOP or MAX/MIN on columns other than the partitioning column may experience reduced performance with partitioning because all partitions must be evaluated.</span></span>  
  
## <a name="behavior-changes-in-statistics-computation-during-partitioned-index-operations"></a><span data-ttu-id="a0442-206">パーティション インデックス操作中の統計計算での動作の変更</span><span class="sxs-lookup"><span data-stu-id="a0442-206">Behavior Changes in Statistics Computation During Partitioned Index Operations</span></span>  
 <span data-ttu-id="a0442-207">[!INCLUDE[ssSQL11](../../includes/sssql11-md.md)]以降では、パーティション インデックスが作成または再構築された場合、テーブル内のすべての行をスキャンして統計を作成することはできません。</span><span class="sxs-lookup"><span data-stu-id="a0442-207">Beginning with [!INCLUDE[ssSQL11](../../includes/sssql11-md.md)], statistics are not created by scanning all the rows in the table when a partitioned index is created or rebuilt.</span></span> <span data-ttu-id="a0442-208">代わりに、クエリ オプティマイザーが既定のサンプリング アルゴリズムを使用して統計を生成します。</span><span class="sxs-lookup"><span data-stu-id="a0442-208">Instead, the query optimizer uses the default sampling algorithm to generate statistics.</span></span> <span data-ttu-id="a0442-209">パーティション インデックスでデータベースをアップグレードした後で、これらのインデックスのヒストグラム データに違いが見つかる場合があります。</span><span class="sxs-lookup"><span data-stu-id="a0442-209">After upgrading a database with partitioned indexes, you may notice a difference in the histogram data for these indexes.</span></span> <span data-ttu-id="a0442-210">この動作の変更はクエリ パフォーマンスに影響しない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="a0442-210">This change in behavior may not affect query performance.</span></span> <span data-ttu-id="a0442-211">テーブル内のすべての行をスキャンしてパーティション インデックスの統計を作成するには、FULLSCAN 句で CREATE STATISTICS または UPDATE STATISTICS を使用します。</span><span class="sxs-lookup"><span data-stu-id="a0442-211">To obtain statistics on partitioned indexes by scanning all the rows in the table, use CREATE STATISTICS or UPDATE STATISTICS with the FULLSCAN clause.</span></span>  
  
## <a name="related-tasks"></a><span data-ttu-id="a0442-212">Related Tasks</span><span class="sxs-lookup"><span data-stu-id="a0442-212">Related Tasks</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="a0442-213">**タスク**</span><span class="sxs-lookup"><span data-stu-id="a0442-213">**Tasks**</span></span>|<span data-ttu-id="a0442-214">**トピック**</span><span class="sxs-lookup"><span data-stu-id="a0442-214">**Topic**</span></span>|  
|<span data-ttu-id="a0442-215">パーティション関数とパーティション構成の作成方法、およびそれらをテーブルおよびインデックスに適用する方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="a0442-215">Describes how to create partition functions and partition schemes and then apply these to a table and index.</span></span>|[<span data-ttu-id="a0442-216">パーティション テーブルとパーティション インデックスの作成</span><span class="sxs-lookup"><span data-stu-id="a0442-216">Create Partitioned Tables and Indexes</span></span>](create-partitioned-tables-and-indexes.md)|  
|||  
  
## <a name="related-content"></a><span data-ttu-id="a0442-217">関連コンテンツ</span><span class="sxs-lookup"><span data-stu-id="a0442-217">Related Content</span></span>  
 <span data-ttu-id="a0442-218">次のホワイトペーパーには、パーティション テーブルおよびパーティション インデックスの戦略と有用な実装について記述されています。</span><span class="sxs-lookup"><span data-stu-id="a0442-218">You may find the following white papers on partitioned table and index strategies and implementations useful.</span></span>  
  
-   <span data-ttu-id="a0442-219">[SQL Server 2008 を使用したパーティション テーブルとパーティション インデックス](https://msdn.microsoft.com/library/dd578580\(SQL.100\).aspx)</span><span class="sxs-lookup"><span data-stu-id="a0442-219">[Partitioned Table and Index Strategies Using SQL Server 2008](https://msdn.microsoft.com/library/dd578580\(SQL.100\).aspx)</span></span>  
  
-   <span data-ttu-id="a0442-220">[自動スライディング ウィンドウを実装する方法](https://msdn.microsoft.com/library/aa964122\(SQL.90\).aspx)</span><span class="sxs-lookup"><span data-stu-id="a0442-220">[How to Implement an Automatic Sliding Window](https://msdn.microsoft.com/library/aa964122\(SQL.90\).aspx)</span></span>  
  
-   [<span data-ttu-id="a0442-221">パーティション テーブルの一括読み込み</span><span class="sxs-lookup"><span data-stu-id="a0442-221">Bulk Loading into a Partitioned Table</span></span>](https://msdn.microsoft.com/library/cc966380.aspx)  
  
-   [<span data-ttu-id="a0442-222">パーティション テーブルとパーティション インデックスに対するクエリ処理の機能強化</span><span class="sxs-lookup"><span data-stu-id="a0442-222">Query Processing Enhancements on Partitioned Tables and Indexes</span></span>](https://msdn.microsoft.com/library/ms345599.aspx)  
  
-   [<span data-ttu-id="a0442-223">大規模なリレーショナル データ ウェアハウスを構築するためのトップ 10 のベスト プラクティス</span><span class="sxs-lookup"><span data-stu-id="a0442-223">Top 10 Best Practices for Building a Large Scale Relational Data Warehouse</span></span>](http://sqlcat.com/top10lists/archive/2008/02/06/top-10-best-practices-for-building-a-large-scale-relational-data-warehouse.aspx)  
  
  
