---
title: XML データ型と列 (SQL Server) | Microsoft Docs
ms.custom: ''
ms.date: 06/14/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: xml
ms.topic: conceptual
ms.assetid: 00db8f21-7d4b-4347-ae43-3a7c314d2fa1
author: rothja
ms.author: jroth
ms.openlocfilehash: 575f8b8fc640ea5ff671a6b0cef4208e7447898f
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/04/2020
ms.locfileid: "87741649"
---
# <a name="xml-data-type-and-columns-sql-server"></a><span data-ttu-id="f759c-102">XML データ型と列 (SQL Server)</span><span class="sxs-lookup"><span data-stu-id="f759c-102">XML Data Type and Columns (SQL Server)</span></span>
  <span data-ttu-id="f759c-103">このトピックでは、のデータ型の利点と制限事項について説明 `xml` [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] します。また、XML データの格納方法を選択する際にも役立ちます。</span><span class="sxs-lookup"><span data-stu-id="f759c-103">This topic discusses the advantages and the limitations of the `xml` data type in [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], and helps you to choose how to store XML data.</span></span>  
  
## <a name="relational-or-xml-data-model"></a><span data-ttu-id="f759c-104">リレーショナル データ モデルと XML データ モデル</span><span class="sxs-lookup"><span data-stu-id="f759c-104">Relational or XML Data Model</span></span>  
 <span data-ttu-id="f759c-105">使用するデータが既知のスキーマにより十分に構造化されている場合、データ ストレージとしてはリレーショナル モデルが最適です。</span><span class="sxs-lookup"><span data-stu-id="f759c-105">If your data is highly structured with known schema, the relational model is likely to work best for data storage.</span></span> [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] <span data-ttu-id="f759c-106">に用意されています。</span><span class="sxs-lookup"><span data-stu-id="f759c-106">provides the required functionality and tools you may need.</span></span> <span data-ttu-id="f759c-107">ただし、データが構造化されていないか構造化が部分的である場合、または構造化の状態が不明な場合は、データのモデリングを検討する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f759c-107">On the other hand, if the structure is semi-structured or unstructured, or unknown, you have to give consideration to modeling such data.</span></span>  
  
 <span data-ttu-id="f759c-108">構造や意味によるマークアップを行ってデータを移行できるようにするために、プラットフォームに依存しないモデルが必要な場合、XML が適しています。</span><span class="sxs-lookup"><span data-stu-id="f759c-108">XML is a good choice if you want a platform-independent model in order to ensure portability of the data by using structural and semantic markup.</span></span> <span data-ttu-id="f759c-109">また、次に示す条件に該当する場合も XML が適切です。</span><span class="sxs-lookup"><span data-stu-id="f759c-109">Additionally, it is an appropriate option if some of the following properties are satisfied:</span></span>  
  
-   <span data-ttu-id="f759c-110">データの密度が低いか構造が不明な場合。または将来のデータの構造が大きく変わる可能性がある場合。</span><span class="sxs-lookup"><span data-stu-id="f759c-110">Your data is sparse or you do not know the structure of the data, or the structure of your data may change significantly in the future.</span></span>  
  
-   <span data-ttu-id="f759c-111">データがエンティティ間の参照ではなく包含階層を成していて、再帰的な性質がある場合。</span><span class="sxs-lookup"><span data-stu-id="f759c-111">Your data represents containment hierarchy, instead of references among entities, and may be recursive.</span></span>  
  
-   <span data-ttu-id="f759c-112">データの順序が固定している場合。</span><span class="sxs-lookup"><span data-stu-id="f759c-112">Order is inherent in your data.</span></span>  
  
-   <span data-ttu-id="f759c-113">データの構造を基にして、データへのクエリやデータの部分的な更新を行う場合。</span><span class="sxs-lookup"><span data-stu-id="f759c-113">You want to query into the data or update parts of it, based on its structure.</span></span>  
  
 <span data-ttu-id="f759c-114">上記の条件のいずれにも該当しない場合は、リレーショナル データ モデルを使用してください。</span><span class="sxs-lookup"><span data-stu-id="f759c-114">If none of these conditions is met, you should use the relational data model.</span></span> <span data-ttu-id="f759c-115">たとえば、データが XML 形式であってもデータの格納と取得にしかデータベースを使用しない場合、`[n]varchar(max)` 列で十分です。</span><span class="sxs-lookup"><span data-stu-id="f759c-115">For example, if your data is in XML format but your application just uses the database to store and retrieve the data, an `[n]varchar(max)` column is all you require.</span></span> <span data-ttu-id="f759c-116">XML 列にデータを格納すると、それ以外の利点があります。</span><span class="sxs-lookup"><span data-stu-id="f759c-116">Storing the data in an XML column has additional benefits.</span></span> <span data-ttu-id="f759c-117">たとえば、データが適切な形式であり有効であることをデータベース エンジンで判断できることや、XML データに対するきめ細かいクエリや更新がサポートされることなどです。</span><span class="sxs-lookup"><span data-stu-id="f759c-117">This includes having the engine determine that the data is well formed or valid, and also includes support for fine-grained query and updates into the XML data.</span></span>  
  
## <a name="reasons-for-storing-xml-data-in-sql-server"></a><span data-ttu-id="f759c-118">SQL Server で XML データを保存する理由</span><span class="sxs-lookup"><span data-stu-id="f759c-118">Reasons for Storing XML Data in SQL Server</span></span>  
 <span data-ttu-id="f759c-119">次に、ファイル システムによる XML データの管理ではなく、 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] のネイティブ XML 機能を使用する理由を示します。</span><span class="sxs-lookup"><span data-stu-id="f759c-119">Following are some of the reasons to use native XML features in [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] instead of managing your XML data in the file system:</span></span>  
  
-   <span data-ttu-id="f759c-120">XML データの共有、クエリ、および変更をトランザクション方式で効率的に行うため。</span><span class="sxs-lookup"><span data-stu-id="f759c-120">You want to share, query, and modify your XML data in an efficient and transacted way.</span></span> <span data-ttu-id="f759c-121">アプリケーションにとって、きめ細かいデータ アクセスは重要です。</span><span class="sxs-lookup"><span data-stu-id="f759c-121">Fine-grained data access is important to your application.</span></span> <span data-ttu-id="f759c-122">たとえば、XML ドキュメントのセクションの一部を抽出したり、ドキュメント全体を置き換えることなく新しいセクションを挿入することができます。</span><span class="sxs-lookup"><span data-stu-id="f759c-122">For example, you may want to extract some of the sections within an XML document, or you may want to insert a new section without replacing your whole document.</span></span>  
  
-   <span data-ttu-id="f759c-123">リレーショナル データと XML データがあり、アプリケーションで双方のデータ間の相互運用性が必要なため。</span><span class="sxs-lookup"><span data-stu-id="f759c-123">You have relational data and XML data and you want interoperability between both relational and XML data within your application.</span></span>  
  
-   <span data-ttu-id="f759c-124">XML とリレーショナルの 2 つの領域にまたがるアプリケーションで、クエリやデータ変更に対する言語サポートが必要なため。</span><span class="sxs-lookup"><span data-stu-id="f759c-124">You need language support for query and data modification for cross-domain applications.</span></span>  
  
-   <span data-ttu-id="f759c-125">データが整形式であることの保証、および必要に応じて XML スキーマに従ったデータの検証をサーバーで行うため。</span><span class="sxs-lookup"><span data-stu-id="f759c-125">You want the server to guarantee that the data is well formed and also optionally validate your data according to XML schemas.</span></span>  
  
-   <span data-ttu-id="f759c-126">クエリの処理を効率化し、スケーラビリティを高めるため XML データにインデックスを設定し、特に優れたクエリ オプティマイザーを使用するため。</span><span class="sxs-lookup"><span data-stu-id="f759c-126">You want indexing of XML data for efficient query processing and good scalability, and the use of a first-rate query optimizer.</span></span>  
  
-   <span data-ttu-id="f759c-127">SOAP、ADO.NET、および OLE DB で XML データにアクセスするため。</span><span class="sxs-lookup"><span data-stu-id="f759c-127">You want SOAP, ADO.NET, and OLE DB access to XML data.</span></span>  
  
-   <span data-ttu-id="f759c-128">XML データの管理にデータベース サーバーの管理機能を使用するため。</span><span class="sxs-lookup"><span data-stu-id="f759c-128">You want to use administrative functionality of the database server for managing your XML data.</span></span> <span data-ttu-id="f759c-129">たとえば、バックアップ、復旧、およびレプリケーションなどです。</span><span class="sxs-lookup"><span data-stu-id="f759c-129">For example, this would be backup, recovery, and replication.</span></span>  
  
 <span data-ttu-id="f759c-130">上記の条件のいずれにも該当しない場合、XML 以外のラージ オブジェクト型 (`[n]varchar(max)`、`varbinary(max)` など) でデータを保存するのが適切です。</span><span class="sxs-lookup"><span data-stu-id="f759c-130">If none of these conditions is satisfied, it may be better to store your data as a non-XML, large object type, such as `[n]varchar(max)` or `varbinary(max)`.</span></span>  
  
## <a name="xml-storage-options"></a><span data-ttu-id="f759c-131">XML ストレージ オプション</span><span class="sxs-lookup"><span data-stu-id="f759c-131">XML Storage Options</span></span>  
 <span data-ttu-id="f759c-132">次に、 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] での XML のストレージ オプションを示します。</span><span class="sxs-lookup"><span data-stu-id="f759c-132">The storage options for XML in [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] include the following:</span></span>  
  
-   <span data-ttu-id="f759c-133">`xml` データ型としてのネイティブ ストレージ</span><span class="sxs-lookup"><span data-stu-id="f759c-133">Native storage as `xml` data type</span></span>  
  
     <span data-ttu-id="f759c-134">データの XML コンテンツを保持できる内部表現を使用してデータが保存されます。</span><span class="sxs-lookup"><span data-stu-id="f759c-134">The data is stored in an internal representation that preserves the XML content of the data.</span></span> <span data-ttu-id="f759c-135">内部表現には、包含階層、表示順、要素や属性の値に関する情報などがあります。</span><span class="sxs-lookup"><span data-stu-id="f759c-135">This internal representation includes information about the containment hierarchy, document order, and element and attribute values.</span></span> <span data-ttu-id="f759c-136">具体的には、XML データの InfoSet コンテンツが保持されます。</span><span class="sxs-lookup"><span data-stu-id="f759c-136">Specifically, the InfoSet content of the XML data is preserved.</span></span> <span data-ttu-id="f759c-137">InfoSet の詳細については、「[http://www.w3.org/TR/xml-infoset](https://go.microsoft.com/fwlink/?LinkId=48843)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="f759c-137">For more information about InfoSet, visit [http://www.w3.org/TR/xml-infoset](https://go.microsoft.com/fwlink/?LinkId=48843).</span></span> <span data-ttu-id="f759c-138">InfoSet コンテンツでは、重要でない空白文字、属性の順序、名前空間プレフィックス、および XML 宣言が保持されないので、テキスト形式の XML のまったく同一のコピーにはならない場合があります。</span><span class="sxs-lookup"><span data-stu-id="f759c-138">The InfoSet content may not be an identical copy of the text XML, because the following information is not retained: insignificant white spaces, order of attributes, namespace prefixes, and XML declaration.</span></span>  
  
     <span data-ttu-id="f759c-139">型指定された `xml` データ型、 `xml` XML スキーマにバインドされたデータ型の場合、スキーマ検証後の INFOSET (PSVI) は infoset に型情報を追加し、内部表現でエンコードされます。</span><span class="sxs-lookup"><span data-stu-id="f759c-139">For typed `xml` data type, an `xml` data type bound to XML schemas, the post-schema validation InfoSet (PSVI) adds type information to the InfoSet and is encoded in the internal representation.</span></span> <span data-ttu-id="f759c-140">その結果、解析速度が大幅に向上します。</span><span class="sxs-lookup"><span data-stu-id="f759c-140">This improves parsing speed significantly.</span></span> <span data-ttu-id="f759c-141">詳細については、[http://www.w3.org/TR/xmlschema-1](https://go.microsoft.com/fwlink/?LinkId=48881) と [http://www.w3.org/TR/xmlschema-2](https://go.microsoft.com/fwlink/?LinkId=4871) で W3C の XML スキーマの仕様を参照してください。</span><span class="sxs-lookup"><span data-stu-id="f759c-141">For more information, see the W3C XML Schema specifications at [http://www.w3.org/TR/xmlschema-1](https://go.microsoft.com/fwlink/?LinkId=48881) and [http://www.w3.org/TR/xmlschema-2](https://go.microsoft.com/fwlink/?LinkId=4871).</span></span>  
  
-   <span data-ttu-id="f759c-142">XML ストレージとリレーショナル ストレージのマッピング</span><span class="sxs-lookup"><span data-stu-id="f759c-142">Mapping between XML and relational storage</span></span>  
  
     <span data-ttu-id="f759c-143">AXSD (注釈付きスキーマ) を使用することで、XML は 1 つ以上のテーブルの複数の列に分解されます。</span><span class="sxs-lookup"><span data-stu-id="f759c-143">By using an annotated schema (AXSD), the XML is decomposed into columns in one or more tables.</span></span> <span data-ttu-id="f759c-144">分解されても、リレーショナル レベルでのデータの忠実性は保たれます。</span><span class="sxs-lookup"><span data-stu-id="f759c-144">This preserves fidelity of the data at the relational level.</span></span> <span data-ttu-id="f759c-145">したがって、要素間の順序は無視されますが階層構造は保持されます。</span><span class="sxs-lookup"><span data-stu-id="f759c-145">As a result, the hierarchical structure is preserved although order among elements is ignored.</span></span> <span data-ttu-id="f759c-146">再帰的なスキーマは使用できません。</span><span class="sxs-lookup"><span data-stu-id="f759c-146">The schema cannot be recursive.</span></span>  
  
-   <span data-ttu-id="f759c-147">ラージ オブジェクト ストレージ、`[n]varchar(max)` と `varbinary(max)`</span><span class="sxs-lookup"><span data-stu-id="f759c-147">Large object storage, `[n]varchar(max)` and `varbinary(max)`</span></span>  
  
     <span data-ttu-id="f759c-148">データの完全なコピーが保存されます。</span><span class="sxs-lookup"><span data-stu-id="f759c-148">An identical copy of the data is stored.</span></span> <span data-ttu-id="f759c-149">これは、法務文書など、特殊な用途に使用します。</span><span class="sxs-lookup"><span data-stu-id="f759c-149">This is useful for special-purpose applications such as legal documents.</span></span> <span data-ttu-id="f759c-150">ほとんどの場合、正確なコピーは不要であり、XML コンテンツ (InfoSet レベルの忠実性) で十分です。</span><span class="sxs-lookup"><span data-stu-id="f759c-150">Most applications do not require an exact copy and are satisfied with the XML content (InfoSet fidelity).</span></span>  
  
 <span data-ttu-id="f759c-151">一般的には、上記のいくつかの方法を組み合わせることができます。</span><span class="sxs-lookup"><span data-stu-id="f759c-151">Generally, you may have to use a combination of these approaches.</span></span> <span data-ttu-id="f759c-152">たとえば、`xml` データ型の列に XML データを保存して、列のプロパティをリレーショナル列に昇格させることができます。</span><span class="sxs-lookup"><span data-stu-id="f759c-152">For example, you may want to store your XML data in an `xml` data type column and promote properties from it into relational columns.</span></span> <span data-ttu-id="f759c-153">または、マッピングテクノロジを使用して、再帰的部分を XML 以外の列に格納し、再帰部分のみをデータ型の列に格納することもでき `xml` ます。</span><span class="sxs-lookup"><span data-stu-id="f759c-153">Or, you may want to use mapping technology to store nonrecursive parts in non-XML columns and only the recursive parts in `xml` data type columns.</span></span>  
  
### <a name="choice-of-xml-technology"></a><span data-ttu-id="f759c-154">XML テクノロジの選択</span><span class="sxs-lookup"><span data-stu-id="f759c-154">Choice of XML Technology</span></span>  
 <span data-ttu-id="f759c-155">ネイティブ XML と XML ビューのどちらの XML テクノロジを選択するかは、主に次の要因によって決まります。</span><span class="sxs-lookup"><span data-stu-id="f759c-155">The choice of XML technology, native XML versus XML view, generally depends upon the following factors:</span></span>  
  
-   <span data-ttu-id="f759c-156">ストレージ オプション</span><span class="sxs-lookup"><span data-stu-id="f759c-156">Storage options</span></span>  
  
     <span data-ttu-id="f759c-157">XML データは、ラージ オブジェクトとして保存するのが適切な場合 (製品マニュアルなど) と、リレーショナル列に保存するのに向いている場合 (XML に変換した商品品目など) があります。</span><span class="sxs-lookup"><span data-stu-id="f759c-157">Your XML data may be more appropriate for large object storage (for example, a product manual), or more amenable to storage in relational columns (for example, a line item converted to XML).</span></span> <span data-ttu-id="f759c-158">それぞれのストレージ オプションで保持される忠実性の度合いが異なります。</span><span class="sxs-lookup"><span data-stu-id="f759c-158">Each storage option preserves document fidelity to a different extent.</span></span>  
  
-   <span data-ttu-id="f759c-159">クエリ機能</span><span class="sxs-lookup"><span data-stu-id="f759c-159">Query capabilities</span></span>  
  
     <span data-ttu-id="f759c-160">クエリの性質およびクエリの対象になる XML データの範囲を基に、最適なストレージ オプションがわかる場合があります。</span><span class="sxs-lookup"><span data-stu-id="f759c-160">You may find one storage option more appropriate than another, based on the nature of your queries and on the extent to which you query your XML data.</span></span> <span data-ttu-id="f759c-161">XML ノードの述語評価など、XML データへのきめ細かいクエリは、2 つのストレージ オプションでのサポートの度合いに差があります。</span><span class="sxs-lookup"><span data-stu-id="f759c-161">Fine-grained query of your XML data, for example, predicate evaluation on XML nodes, is supported to varying degrees in the two storage options.</span></span>  
  
-   <span data-ttu-id="f759c-162">XML データのインデックス設定</span><span class="sxs-lookup"><span data-stu-id="f759c-162">Indexing XML data</span></span>  
  
     <span data-ttu-id="f759c-163">XML クエリのパフォーマンスを向上するために、XML データにインデックスを設定できます。</span><span class="sxs-lookup"><span data-stu-id="f759c-163">You may want to index the XML data to speed up XML query performance.</span></span> <span data-ttu-id="f759c-164">インデックス設定のオプションはストレージ オプションによって異なります。ワークロードを最小にするために、適切な選択を行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="f759c-164">Indexing options vary with the storage options; you have to make the appropriate choice to optimize your workload.</span></span>  
  
-   <span data-ttu-id="f759c-165">データ変更機能</span><span class="sxs-lookup"><span data-stu-id="f759c-165">Data modification capabilities</span></span>  
  
     <span data-ttu-id="f759c-166">一部のワークロードは、XML データのきめ細かい変更を伴います。</span><span class="sxs-lookup"><span data-stu-id="f759c-166">Some workloads involve fine-grained modification of XML data.</span></span> <span data-ttu-id="f759c-167">たとえば、ドキュメント内に新しいセクションを追加する場合などが該当しますが、Web コンテンツなどのその他のワークロードではこのような変更はありません。</span><span class="sxs-lookup"><span data-stu-id="f759c-167">For example, this can include adding a new section within a document, while other workloads, such as Web content, do not.</span></span> <span data-ttu-id="f759c-168">アプリケーションで、データ変更言語のサポートが重要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="f759c-168">Data modification language support may be important for your application.</span></span>  
  
-   <span data-ttu-id="f759c-169">スキーマのサポート</span><span class="sxs-lookup"><span data-stu-id="f759c-169">Schema support</span></span>  
  
     <span data-ttu-id="f759c-170">XML データは、スキーマを使用して記述できる場合があります。このときのスキーマは、XML スキーマ ドキュメントであっても、そうでなくてもかまいません。</span><span class="sxs-lookup"><span data-stu-id="f759c-170">Your XML data may be described by a schema that may or may not be an XML schema document.</span></span> <span data-ttu-id="f759c-171">スキーマにバインドされた XML がサポートされるかどうかは、XML テクノロジによって異なります。</span><span class="sxs-lookup"><span data-stu-id="f759c-171">The support for schema-bound XML depends upon the XML technology.</span></span>  
  
 <span data-ttu-id="f759c-172">どの選択肢を選ぶかで、パフォーマンス特性が異なります。</span><span class="sxs-lookup"><span data-stu-id="f759c-172">Different choices also have different performance characteristics.</span></span>  
  
### <a name="native-xml-storage"></a><span data-ttu-id="f759c-173">ネイティブ XML ストレージ</span><span class="sxs-lookup"><span data-stu-id="f759c-173">Native XML Storage</span></span>  
 <span data-ttu-id="f759c-174">XML データを、サーバーの `xml` データ型の列に保存できます。</span><span class="sxs-lookup"><span data-stu-id="f759c-174">You can store your XML data in an `xml` data type column at the server.</span></span> <span data-ttu-id="f759c-175">次の条件に該当する場合、この方法が適しています。</span><span class="sxs-lookup"><span data-stu-id="f759c-175">This is an appropriate choice if the following applies:</span></span>  
  
-   <span data-ttu-id="f759c-176">簡単にサーバーに XML データを保存すると同時に、表示順やドキュメント構造を保持する場合。</span><span class="sxs-lookup"><span data-stu-id="f759c-176">You want a straightforward way to store your XML data at the server and, at the same time, preserve document order and document structure.</span></span>  
  
-   <span data-ttu-id="f759c-177">XML データのスキーマがあるかどうかが明確でない場合。</span><span class="sxs-lookup"><span data-stu-id="f759c-177">You may or may not have a schema for your XML data.</span></span>  
  
-   <span data-ttu-id="f759c-178">XML データに対し、クエリや変更を行う場合。</span><span class="sxs-lookup"><span data-stu-id="f759c-178">You want to query and modify your XML data.</span></span>  
  
-   <span data-ttu-id="f759c-179">クエリ処理を高速化するために XML データにインデックスを設定する場合。</span><span class="sxs-lookup"><span data-stu-id="f759c-179">You want to index the XML data for faster query processing.</span></span>  
  
-   <span data-ttu-id="f759c-180">XML データと XML スキーマを管理するためのシステム カタログ ビューが必要な場合。</span><span class="sxs-lookup"><span data-stu-id="f759c-180">Your application needs system catalog views to administer your XML data and XML schemas.</span></span>  
  
 <span data-ttu-id="f759c-181">構造が多様な XML ドキュメントがある場合、またはリレーショナル構造へのマッピングが難しい複雑なスキーマや複数のスキーマに従った XML ドキュメントがある場合に、ネイティブ XML ストレージが役立ちます。</span><span class="sxs-lookup"><span data-stu-id="f759c-181">Native XML storage is useful when you have XML documents that have a range of structures, or you have XML documents that conform to different or complex schemas that are too hard to map to relational structures.</span></span>  
  
#### <a name="example-modeling-xml-data-using-the-xml-data-type"></a><span data-ttu-id="f759c-182">例: xml データ型を使用した XML データのモデリング</span><span class="sxs-lookup"><span data-stu-id="f759c-182">Example: Modeling XML Data Using the xml Data Type</span></span>  
 <span data-ttu-id="f759c-183">トピックごとに章が設けられ、それぞれの章の中には複数の節がある構成の XML 形式の製品マニュアルを考えてみます。</span><span class="sxs-lookup"><span data-stu-id="f759c-183">Consider a product manual in XML format that is made up of a separate chapter for each topic and that has multiple sections within each chapter.</span></span> <span data-ttu-id="f759c-184">節には項が含まれる場合があります。</span><span class="sxs-lookup"><span data-stu-id="f759c-184">A section can contain subsections.</span></span> <span data-ttu-id="f759c-185">したがって、\<section> は再帰要素になります。</span><span class="sxs-lookup"><span data-stu-id="f759c-185">As a result, \<section> is a recursive element.</span></span> <span data-ttu-id="f759c-186">製品マニュアルには、混合コンテンツ、図表、および技術データが大量に含まれているので、データは部分的に構造化された状態です。</span><span class="sxs-lookup"><span data-stu-id="f759c-186">Product manuals contain a large amount of mixed content, diagrams, and technical material; the data is semi-structured.</span></span> <span data-ttu-id="f759c-187">ユーザーは、「インデックス設定」に関する章の「クラスター化インデックス」に関する節を検索するなど、関心のあるトピックをコンテキストにより検索したり、技術データにクエリを実行します。</span><span class="sxs-lookup"><span data-stu-id="f759c-187">Users may want to perform a contextual search for topics of interest such as searching for the section on "clustered index" within the chapter on "indexing", and query technical quantities.</span></span>  
  
 <span data-ttu-id="f759c-188">この XML ドキュメントに適したストレージ モデルは `xml` データ型列です。</span><span class="sxs-lookup"><span data-stu-id="f759c-188">An appropriate storage model for your XML documents is an `xml` data type column.</span></span> <span data-ttu-id="f759c-189">このモデルであれば、XML データの InfoSet コンテンツが保持されます。</span><span class="sxs-lookup"><span data-stu-id="f759c-189">This preserves the InfoSet content of your XML data.</span></span> <span data-ttu-id="f759c-190">XML 列にインデックスを設定して、クエリ パフォーマンスを向上できる利点もあります。</span><span class="sxs-lookup"><span data-stu-id="f759c-190">Indexing the XML column benefits query performance.</span></span>  
  
#### <a name="example-retaining-exact-copies-of-xml-data"></a><span data-ttu-id="f759c-191">例: XML データの正確なコピーの保持</span><span class="sxs-lookup"><span data-stu-id="f759c-191">Example: Retaining Exact Copies of XML Data</span></span>  
 <span data-ttu-id="f759c-192">たとえば、政府の規定により、XML ドキュメントのテキストの正確なコピーを保持する必要があるとします。</span><span class="sxs-lookup"><span data-stu-id="f759c-192">For illustration, assume that government regulations require you to retain exact textual copies of your XML documents.</span></span> <span data-ttu-id="f759c-193">署名済み文書、法務文書、株取引の注文書などが該当します。</span><span class="sxs-lookup"><span data-stu-id="f759c-193">For example, these could include signed documents, legal documents, or stock transaction orders.</span></span> <span data-ttu-id="f759c-194">このようなドキュメントは `[n]varchar(max)` 列に保存できます。</span><span class="sxs-lookup"><span data-stu-id="f759c-194">You may want to store your documents in a `[n]varchar(max)` column.</span></span>  
  
 <span data-ttu-id="f759c-195">クエリを行うには、実行時にデータを `xml` データ型に変換して XQuery を実行します。</span><span class="sxs-lookup"><span data-stu-id="f759c-195">For querying, convert the data to `xml` data type at run time and execute Xquery on it.</span></span> <span data-ttu-id="f759c-196">実行時の変換は、ドキュメントが大きい場合は特にコストが高くなる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f759c-196">The run-time conversion may be costly, especially when the document is large.</span></span> <span data-ttu-id="f759c-197">頻繁にクエリを実行する場合は、`xml` データ型の列にドキュメントを冗長に保存してインデックスを設定しておき、`[n]varchar(max)` 型の列からドキュメントの正確なコピーを返すことができます。</span><span class="sxs-lookup"><span data-stu-id="f759c-197">If you query frequently, you can redundantly store the documents in an `xml` data type column and index it while you return exact document copies from the `[n]varchar(max)` column.</span></span>  
  
 <span data-ttu-id="f759c-198">XML 列は `[n]varchar(max)` 型の列を基にした計算列にすることができます。</span><span class="sxs-lookup"><span data-stu-id="f759c-198">The XML column may be a computed column, based on the `[n]varchar(max)` column.</span></span> <span data-ttu-id="f759c-199">ただし、xml インデックスは、計算された XML 列に対して作成したり、xml インデックスを作成したりすることはできません `[n]varchar(max)` `varbinary(max)` 。</span><span class="sxs-lookup"><span data-stu-id="f759c-199">However, you cannot create an XML index on a computed, XML column, nor can an XML index be built on `[n]varchar(max)` or `varbinary(max)` columns.</span></span>  
  
### <a name="xml-view-technology"></a><span data-ttu-id="f759c-200">XML ビュー テクノロジ</span><span class="sxs-lookup"><span data-stu-id="f759c-200">XML View Technology</span></span>  
 <span data-ttu-id="f759c-201">XML スキーマとデータベース内のテーブルとのマッピングを定義することで、永続的なデータの "XML ビュー" を作成します。</span><span class="sxs-lookup"><span data-stu-id="f759c-201">By defining a mapping between your XML schemas and the tables in a database, you create an "XML view" of your persistent data.</span></span> <span data-ttu-id="f759c-202">XML ビューを使用して基になるテーブルのデータを格納する場合に、XML 一括読み込みを行うことができます。</span><span class="sxs-lookup"><span data-stu-id="f759c-202">XML bulk load can be used to populate the underlying tables by using the XML view.</span></span> <span data-ttu-id="f759c-203">XML ビューには XPath Version 1.0 を使用してクエリを実行できます。テーブルでクエリが実行されるときには SQL クエリに変換されます。</span><span class="sxs-lookup"><span data-stu-id="f759c-203">You can query the XML view by using XPath version 1.0; the query is translated to SQL queries on the tables.</span></span> <span data-ttu-id="f759c-204">これと同様に、更新もテーブルに反映されます。</span><span class="sxs-lookup"><span data-stu-id="f759c-204">Similarly, updates are also propagated to those tables.</span></span>  
  
 <span data-ttu-id="f759c-205">このテクノロジは、次のような場合に役立ちます。</span><span class="sxs-lookup"><span data-stu-id="f759c-205">This technology is useful in the following situations:</span></span>  
  
-   <span data-ttu-id="f759c-206">既存のリレーショナル データの XML ビューを使用した XML 中心のプログラミング モデルが必要な場合。</span><span class="sxs-lookup"><span data-stu-id="f759c-206">You want to have an XML-centric programming model using XML views over your existing relational data.</span></span>  
  
-   <span data-ttu-id="f759c-207">外部のパートナーから提供された XML データのスキーマ (XSD、XDR) がある場合。</span><span class="sxs-lookup"><span data-stu-id="f759c-207">You have a schema (XSD, XDR) for your XML data that an external partner may have provided.</span></span>  
  
-   <span data-ttu-id="f759c-208">データの順序が重要ではない場合、クエリ テーブル データが再帰的でない場合、または事前に再帰の最大の深さがわかっている場合。</span><span class="sxs-lookup"><span data-stu-id="f759c-208">Order is not important in your data, or your query table data is not recursive, or the maximal recursion depth is known in advance.</span></span>  
  
-   <span data-ttu-id="f759c-209">XPath Version 1.0 を使用して、XML ビューからデータに対するクエリや変更を行う場合。</span><span class="sxs-lookup"><span data-stu-id="f759c-209">You want to query and modify the data through the XML view by using XPath version 1.0.</span></span>  
  
-   <span data-ttu-id="f759c-210">XML ビューを使用し、XML データの一括読み込みを行ってそれを基になるテーブルに分解する場合。</span><span class="sxs-lookup"><span data-stu-id="f759c-210">You want to bulk load XML data and decompose them into the underlying tables by using the XML view.</span></span>  
  
 <span data-ttu-id="f759c-211">例としては、データ交換や Web サービス向けに XML として公開されたリレーショナル データ、固定スキーマにバインドされた XML データなどがあります。</span><span class="sxs-lookup"><span data-stu-id="f759c-211">Examples include relational data exposed as XML for data exchange and Web services, and XML data with fixed schema.</span></span> <span data-ttu-id="f759c-212">詳細については、 [MSDN オンライン ライブラリ](https://go.microsoft.com/fwlink/?linkid=31174)を参照してください。</span><span class="sxs-lookup"><span data-stu-id="f759c-212">For more information, see the [MSDN Online Library](https://go.microsoft.com/fwlink/?linkid=31174).</span></span>  
  
#### <a name="example-modeling-data-using-an-annotated-xml-schema-axsd"></a><span data-ttu-id="f759c-213">例: AXSD (注釈付き XML スキーマ) を使用したデータ モデリング</span><span class="sxs-lookup"><span data-stu-id="f759c-213">Example: Modeling Data Using an Annotated XML Schema (AXSD)</span></span>  
 <span data-ttu-id="f759c-214">たとえば、顧客、注文、品目などの既存のリレーショナル データを XML として処理するとします。</span><span class="sxs-lookup"><span data-stu-id="f759c-214">For illustration, assume that you have existing relational data, such as customers, orders, and line items, that you want to handle as XML.</span></span> <span data-ttu-id="f759c-215">リレーショナル データに AXSD を使用して、XML ビューを定義します。</span><span class="sxs-lookup"><span data-stu-id="f759c-215">Define an XML view by using AXSD over the relational data.</span></span> <span data-ttu-id="f759c-216">XML ビューを使用すると、テーブルに XML データを一括で読み込み、XML ビューでリレーショナル データに対するクエリや更新を行うことができます。</span><span class="sxs-lookup"><span data-stu-id="f759c-216">The XML view allows you to bulk load XML data into your tables and query and update the relational data by using the XML view.</span></span> <span data-ttu-id="f759c-217">SQL アプリケーションの実行を中断することなく、XML でマークアップされたデータを他のアプリケーションと交換する必要がある場合に、このモデルが役立ちます。</span><span class="sxs-lookup"><span data-stu-id="f759c-217">This model is useful if you have to exchange data that contains XML markup with other applications while your SQL applications work uninterrupted.</span></span>  
  
### <a name="hybrid-model"></a><span data-ttu-id="f759c-218">ハイブリッド モデル</span><span class="sxs-lookup"><span data-stu-id="f759c-218">Hybrid Model</span></span>  
 <span data-ttu-id="f759c-219">多くの場合、リレーショナル列と `xml` データ型の列の組み合わせがデータモデリングに適しています。</span><span class="sxs-lookup"><span data-stu-id="f759c-219">Frequently, a combination of relational and `xml` data type columns is appropriate for data modeling.</span></span> <span data-ttu-id="f759c-220">XML データの値の一部をリレーショナル列に保存し、残り (または XML 値全体) を XML 列に保存することができます。</span><span class="sxs-lookup"><span data-stu-id="f759c-220">Some of the values from your XML data can be stored in relational columns, and the rest, or the whole XML value stored in an XML column.</span></span> <span data-ttu-id="f759c-221">そうすることで、リレーショナル列に作成したインデックスやロック特性を制御しやすくなり、パフォーマンスが向上する場合があります。</span><span class="sxs-lookup"><span data-stu-id="f759c-221">This may yield better performance in that you have more control over the indexes created on the relational columns and locking characteristics.</span></span>  
  
 <span data-ttu-id="f759c-222">リレーショナル列に保存する方が適切な値はワークロードによって異なります。</span><span class="sxs-lookup"><span data-stu-id="f759c-222">The values to store in relational columns depend on your workload.</span></span> <span data-ttu-id="f759c-223">たとえば、パス式 /Customer/@CustId を基にすべての XML 値を取得する場合、**CustId** 属性の値をリレーショナル列に昇格してインデックスを設定することにより、クエリ パフォーマンスが向上する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f759c-223">For example, if you retrieve all the XML values based on the path expression, /Customer/@CustId, promoting the value of the **CustId** attribute into a relational column and indexing it may yield faster query performance.</span></span> <span data-ttu-id="f759c-224">一方で、XML データが冗長性なしで多数のリレーショナル列に分解されている場合、再構成のコストが甚大になる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f759c-224">On the other hand, if your XML data is extensively and nonredundantly decomposed into relational columns, the re-assembly cost may be significant.</span></span>  
  
 <span data-ttu-id="f759c-225">テーブルのコンテンツを XML に変換した場合など、十分に構造化された XML データでは、すべての値をリレーショナル列にマップすることができ、XML ビュー テクノロジを使用できる場合もあります。</span><span class="sxs-lookup"><span data-stu-id="f759c-225">For highly structured XML data, for example, the content of a table has been converted into XML; you can map all values to relational columns, and possibly use XML view technology.</span></span>  
  
## <a name="granularity-of-xml-data"></a><span data-ttu-id="f759c-226">XML データの粒度</span><span class="sxs-lookup"><span data-stu-id="f759c-226">Granularity of XML Data</span></span>  
 <span data-ttu-id="f759c-227">XML 列に保存される XML データの粒度は、ロックの際に非常に重要であるだけでなく、更新の際にも重要です。</span><span class="sxs-lookup"><span data-stu-id="f759c-227">The granularity of the XML data stored in an XML column is very important for locking and, to a lesser degree, it is also important for updates.</span></span> [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] <span data-ttu-id="f759c-228">では、XML データと XML 以外のデータに対して同一のロック メカニズムを使用します。</span><span class="sxs-lookup"><span data-stu-id="f759c-228">uses the same locking mechanism for both XML and non-XML data.</span></span> <span data-ttu-id="f759c-229">したがって行レベルのロックを設定すると、行内のすべての XML インスタンスがロックされます。</span><span class="sxs-lookup"><span data-stu-id="f759c-229">Therefore, row-level locking causes all XML instances in the row to be locked.</span></span> <span data-ttu-id="f759c-230">粒度が粗い場合、マルチユーザー シナリオで更新のために大きな XML インスタンスをロックすると、スループットが低下します。</span><span class="sxs-lookup"><span data-stu-id="f759c-230">When the granularity is large, locking large XML instances for updates causes throughput to decline in a multiuser scenario.</span></span> <span data-ttu-id="f759c-231">一方、分割しすぎるとオブジェクトのカプセル化状態が失われ、再構成のコストが上がります。</span><span class="sxs-lookup"><span data-stu-id="f759c-231">On the other hand, severe decomposition loses object encapsulation and increases reassembly cost.</span></span>  
  
 <span data-ttu-id="f759c-232">優れた設計を行うには、データ モデリングの要件とロックや更新の特性との間でバランスを取ることが重要です。</span><span class="sxs-lookup"><span data-stu-id="f759c-232">A balance between data modeling requirements and locking and update characteristics is important for good design.</span></span> <span data-ttu-id="f759c-233">ただし [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]では、実際に保存される XML インスタンスのサイズが決定的な要因になることはありません。</span><span class="sxs-lookup"><span data-stu-id="f759c-233">However, in [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], the size of actual stored XML instances is not as critical.</span></span>  
  
 <span data-ttu-id="f759c-234">たとえば、新旧の XML インスタンスの比較による BLOB (バイナリ ラージ オブジェクト) やインデックスの部分更新が新しくサポートされるようになったので、それにより XML インスタンスが更新されます。</span><span class="sxs-lookup"><span data-stu-id="f759c-234">For example, updates to an XML instance are performed by using new support for partial binary large object (BLOB) and partial index updates in which the existing stored XML instance is compared to its updated version.</span></span> <span data-ttu-id="f759c-235">BLOB (バイナリ ラージ オブジェクト) の部分更新は、2 つの XML インスタンスの差異を比較して差分のみを更新します。</span><span class="sxs-lookup"><span data-stu-id="f759c-235">Partial binary large object (BLOB) update performs a differential comparison between the two XML instances and updates only the differences.</span></span> <span data-ttu-id="f759c-236">インデックスの部分更新は、XML インデックスの変更が必要な行のみを変更します。</span><span class="sxs-lookup"><span data-stu-id="f759c-236">Partial index updates modify only those rows that must be changed in the XML index.</span></span>  
  
## <a name="limitations-of-the-xml-data-type"></a><span data-ttu-id="f759c-237">xml データ型の制限事項</span><span class="sxs-lookup"><span data-stu-id="f759c-237">Limitations of the xml Data Type</span></span>  
 <span data-ttu-id="f759c-238">`xml` データ型には、次の一般的な制限事項が適用されます。</span><span class="sxs-lookup"><span data-stu-id="f759c-238">Note the following general limitations that apply to the `xml` data type:</span></span>  
  
-   <span data-ttu-id="f759c-239">保存する `xml` データ型のインスタンスは 2 GB 以内である必要があります。</span><span class="sxs-lookup"><span data-stu-id="f759c-239">The stored representation of `xml` data type instances cannot exceed 2 GB.</span></span>  
  
-   <span data-ttu-id="f759c-240">**sql_variant** インスタンスのサブタイプとしては使用できません。</span><span class="sxs-lookup"><span data-stu-id="f759c-240">It cannot be used as a subtype of a **sql_variant** instance.</span></span>  
  
-   <span data-ttu-id="f759c-241">`text` または `ntext` にキャストしたり、変換することはできません。</span><span class="sxs-lookup"><span data-stu-id="f759c-241">It does not support casting or converting to either `text` or `ntext`.</span></span> <span data-ttu-id="f759c-242">代わりに、`varchar(max)` タグまたは `nvarchar(max)` タグを使用してください。</span><span class="sxs-lookup"><span data-stu-id="f759c-242">Use `varchar(max)` or `nvarchar(max)` instead.</span></span>  
  
-   <span data-ttu-id="f759c-243">比較や並べ替えはできません。</span><span class="sxs-lookup"><span data-stu-id="f759c-243">It cannot be compared or sorted.</span></span> <span data-ttu-id="f759c-244">したがって、`xml` データ型は GROUP BY ステートメント内では使用できません。</span><span class="sxs-lookup"><span data-stu-id="f759c-244">This means an `xml` data type cannot be used in a GROUP BY statement.</span></span>  
  
-   <span data-ttu-id="f759c-245">ISNULL、COALESCE、および DATALENGTH を除く組み込みのスカラー関数のパラメーターとしては使用できません。</span><span class="sxs-lookup"><span data-stu-id="f759c-245">It cannot be used as a parameter to any scalar, built-in functions other than ISNULL, COALESCE, and DATALENGTH.</span></span>  
  
-   <span data-ttu-id="f759c-246">インデックスのキー列としては使用できません。</span><span class="sxs-lookup"><span data-stu-id="f759c-246">It cannot be used as a key column in an index.</span></span> <span data-ttu-id="f759c-247">ただし、クラスター化インデックスのデータとして使用したり、非クラスター化インデックスの作成時に INCLUDE キーワードを使用して明示的に非クラスター化インデックスに追加することはできます。</span><span class="sxs-lookup"><span data-stu-id="f759c-247">However, it can be included as data in a clustered index or explicitly added to a nonclustered index by using the INCLUDE keyword when the nonclustered index is created.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="f759c-248">参照</span><span class="sxs-lookup"><span data-stu-id="f759c-248">See Also</span></span>  
 [<span data-ttu-id="f759c-249">XML ドキュメントの一括インポートと一括エクスポートの例 &#40;SQL Server&#41;</span><span class="sxs-lookup"><span data-stu-id="f759c-249">Examples of Bulk Import and Export of XML Documents &#40;SQL Server&#41;</span></span>](../import-export/examples-of-bulk-import-and-export-of-xml-documents-sql-server.md)  
  
  
