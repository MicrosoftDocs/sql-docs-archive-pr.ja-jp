---
title: クラスター化インデックスと非クラスター化インデックスの概念 | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: table-view-index
ms.topic: conceptual
helpviewer_keywords:
- query optimizer [SQL Server], index usage
- index concepts [SQL Server]
ms.assetid: b7d6b323-728d-4763-a987-92e6292f6f7a
author: MikeRayMSFT
ms.author: mikeray
ms.openlocfilehash: c9eb51a24000b8af4a466fe4330644a722ad325b
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/04/2020
ms.locfileid: "87740969"
---
# <a name="clustered-and-nonclustered-indexes-described"></a><span data-ttu-id="db68a-102">クラスター化インデックスと非クラスター化インデックスの概念</span><span class="sxs-lookup"><span data-stu-id="db68a-102">Clustered and Nonclustered Indexes Described</span></span>
  <span data-ttu-id="db68a-103">インデックスとは、テーブルまたはビューに関連付けられたディスク上の構造で、テーブルやビューからの行の取得を高速化します。</span><span class="sxs-lookup"><span data-stu-id="db68a-103">An index is an on-disk structure associated with a table or view that speeds retrieval of rows from the table or view.</span></span> <span data-ttu-id="db68a-104">インデックスには、テーブル内またはビュー内の 1 つ以上の列から構築されたキーが含まれています。</span><span class="sxs-lookup"><span data-stu-id="db68a-104">An index contains keys built from one or more columns in the table or view.</span></span> <span data-ttu-id="db68a-105">これらのキーは 1 つの構造 (B-Tree) 内に格納され、 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] はその構造を使用して、キー値に関連した 1 つ以上の行を効率よく迅速に検出できます。</span><span class="sxs-lookup"><span data-stu-id="db68a-105">These keys are stored in a structure (B-tree) that enables [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] to find the row or rows associated with the key values quickly and efficiently.</span></span>  
  
 <span data-ttu-id="db68a-106">テーブルまたはビューには、次の種類のインデックスを含めることができます。</span><span class="sxs-lookup"><span data-stu-id="db68a-106">A table or view can contain the following types of indexes:</span></span>  
  
-   <span data-ttu-id="db68a-107">クラスター化インデックス</span><span class="sxs-lookup"><span data-stu-id="db68a-107">Clustered</span></span>  
  
    -   <span data-ttu-id="db68a-108">クラスター化インデックスは、テーブルまたはビュー内のデータ行をそのキー値に基づいて並べ替え、格納します。</span><span class="sxs-lookup"><span data-stu-id="db68a-108">Clustered indexes sort and store the data rows in the table or view based on their key values.</span></span> <span data-ttu-id="db68a-109">クラスター化インデックスは、インデックス定義に含まれる列です。</span><span class="sxs-lookup"><span data-stu-id="db68a-109">These are the columns included in the index definition.</span></span> <span data-ttu-id="db68a-110">データ行自体は 1 つの順序でしか並べ替えられないので、1 つのテーブルに設定できるクラスター化インデックスは 1 つだけです。</span><span class="sxs-lookup"><span data-stu-id="db68a-110">There can be only one clustered index per table, because the data rows themselves can be sorted in only one order.</span></span>  
  
    -   <span data-ttu-id="db68a-111">テーブル内のデータ行が並べ替えられた順に格納されるのは、テーブルにクラスター化インデックスが含まれているときだけです。</span><span class="sxs-lookup"><span data-stu-id="db68a-111">The only time the data rows in a table are stored in sorted order is when the table contains a clustered index.</span></span> <span data-ttu-id="db68a-112">テーブルにクラスター化インデックスが含まれている場合、そのテーブルをクラスター化テーブルと呼びます。</span><span class="sxs-lookup"><span data-stu-id="db68a-112">When a table has a clustered index, the table is called a clustered table.</span></span> <span data-ttu-id="db68a-113">クラスター化インデックスが含まれないテーブルのデータ行は、ヒープと呼ばれる順序付けられていない構造に格納されます。</span><span class="sxs-lookup"><span data-stu-id="db68a-113">If a table has no clustered index, its data rows are stored in an unordered structure called a heap.</span></span>  
  
-   <span data-ttu-id="db68a-114">非クラスター化インデックス</span><span class="sxs-lookup"><span data-stu-id="db68a-114">Nonclustered</span></span>  
  
    -   <span data-ttu-id="db68a-115">非クラスター化インデックスは、データ行とは独立した構造になっています。</span><span class="sxs-lookup"><span data-stu-id="db68a-115">Nonclustered indexes have a structure separate from the data rows.</span></span> <span data-ttu-id="db68a-116">非クラスター化インデックスには、非クラスター化インデックスのキー値が含まれており、各キー値のエントリにはキー値が含まれているデータ行へのポインターが含まれています。</span><span class="sxs-lookup"><span data-stu-id="db68a-116">A nonclustered index contains the nonclustered index key values and each key value entry has a pointer to the data row that contains the key value.</span></span>  
  
    -   <span data-ttu-id="db68a-117">非クラスター化インデックス内のインデックス行からデータ行を指すポインターを、行ロケーターと呼びます。</span><span class="sxs-lookup"><span data-stu-id="db68a-117">The pointer from an index row in a nonclustered index to a data row is called a row locator.</span></span> <span data-ttu-id="db68a-118">行ロケーターの構造は、データ ページがヒープまたはクラスター化テーブルのどちらに格納されているかによって異なります。</span><span class="sxs-lookup"><span data-stu-id="db68a-118">The structure of the row locator depends on whether the data pages are stored in a heap or a clustered table.</span></span> <span data-ttu-id="db68a-119">ヒープに格納されている場合、行ロケーターは行を指すポインターです。</span><span class="sxs-lookup"><span data-stu-id="db68a-119">For a heap, a row locator is a pointer to the row.</span></span> <span data-ttu-id="db68a-120">クラスター化テーブルに格納されている場合、行ロケーターはクラスター化インデックス キーです。</span><span class="sxs-lookup"><span data-stu-id="db68a-120">For a clustered table, the row locator is the clustered index key.</span></span>  
  
    -   <span data-ttu-id="db68a-121">非キー列をリーフ レベルの非クラスター化インデックスに追加することで、サイズが 900 バイトまで、キー列が 16 個までという、既存のインデックス キーの制限を回避して、すべてを対象とするインデックスが設定されたクエリを実行できます。</span><span class="sxs-lookup"><span data-stu-id="db68a-121">You can add nonkey columns to the leaf level of the nonclustered index to by-pass existing index key limits, 900 bytes and 16 key columns, and execute fully covered, indexed, queries.</span></span> <span data-ttu-id="db68a-122">詳細については、「 [付加列インデックスの作成](create-indexes-with-included-columns.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="db68a-122">For more information, see [Create Indexes with Included Columns](create-indexes-with-included-columns.md).</span></span>  
  
 <span data-ttu-id="db68a-123">クラスター化インデックスと非クラスター化インデックスは共に一意インデックスにできます。</span><span class="sxs-lookup"><span data-stu-id="db68a-123">Both clustered and nonclustered indexes can be unique.</span></span> <span data-ttu-id="db68a-124">つまり、2 つの行がインデックス キーに同じ値を持つことができなくなります。</span><span class="sxs-lookup"><span data-stu-id="db68a-124">This means no two rows can have the same value for the index key.</span></span> <span data-ttu-id="db68a-125">一意インデックスにしない場合、インデックスは一意でなくなり、複数の行が同じキー値を共有できます。</span><span class="sxs-lookup"><span data-stu-id="db68a-125">Otherwise, the index is not unique and multiple rows can share the same key value.</span></span> <span data-ttu-id="db68a-126">詳細については、「 [一意のインデックスの作成](create-unique-indexes.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="db68a-126">For more information, see [Create Unique Indexes](create-unique-indexes.md).</span></span>  
  
 <span data-ttu-id="db68a-127">テーブル データが変更されるたびに、テーブルまたはビューのインデックスが自動的にメンテナンスされます。</span><span class="sxs-lookup"><span data-stu-id="db68a-127">Indexes are automatically maintained for a table or view whenever the table data is modified.</span></span>  
  
 <span data-ttu-id="db68a-128">特別な用途のインデックスのその他の種類については、「 [インデックス](indexes.md) 」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="db68a-128">See [Indexes](indexes.md) for additional types of special purpose indexes.</span></span>  
  
## <a name="indexes-and-constraints"></a><span data-ttu-id="db68a-129">インデックスと制約</span><span class="sxs-lookup"><span data-stu-id="db68a-129">Indexes and Constraints</span></span>  
 <span data-ttu-id="db68a-130">PRIMARY KEY 制約と UNIQUE 制約がテーブル列に定義されると、インデックスが自動的に作成されます。</span><span class="sxs-lookup"><span data-stu-id="db68a-130">Indexes are automatically created when PRIMARY KEY and UNIQUE constraints are defined on table columns.</span></span> <span data-ttu-id="db68a-131">たとえば、テーブルを作成し、特定の列を主キーとして識別すると、その列に PRIMARY KEY 制約とインデックスが [!INCLUDE[ssDE](../../includes/ssde-md.md)] によって自動的に作成されます。</span><span class="sxs-lookup"><span data-stu-id="db68a-131">For example, when you create a table and identify a particular column to be the primary key, the [!INCLUDE[ssDE](../../includes/ssde-md.md)] automatically creates a PRIMARY KEY constraint and index on that column.</span></span> <span data-ttu-id="db68a-132">詳細については、「 [主キーの作成](../tables/create-primary-keys.md) 」および「 [UNIQUE 制約の作成](../tables/create-unique-constraints.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="db68a-132">For more information, see [Create Primary Keys](../tables/create-primary-keys.md) and [Create Unique Constraints](../tables/create-unique-constraints.md).</span></span>  
  
## <a name="how-indexes-are-used-by-the-query-optimizer"></a><span data-ttu-id="db68a-133">クエリ オプティマイザーでのインデックスの使用方法</span><span class="sxs-lookup"><span data-stu-id="db68a-133">How Indexes Are Used by the Query Optimizer</span></span>  
 <span data-ttu-id="db68a-134">インデックスを適切に設計すると、ディスク I/O 操作が減少し、使用するシステム リソースが少なくなります。その結果、クエリのパフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="db68a-134">Well-designed indexes can reduce disk I/O operations and consume fewer system resources therefore improving query performance.</span></span> <span data-ttu-id="db68a-135">インデックスは、SELECT、UPDATE、DELETE、または MERGE の各ステートメントを含むさまざまなクエリで役立ちます。</span><span class="sxs-lookup"><span data-stu-id="db68a-135">Indexes can be helpful for a variety of queries that contain SELECT, UPDATE, DELETE, or MERGE statements.</span></span> <span data-ttu-id="db68a-136">`SELECT Title, HireDate FROM HumanResources.Employee WHERE EmployeeID = 250` データベースのクエリ [!INCLUDE[ssSampleDBobject](../../includes/sssampledbobject-md.md)] について考えてみましょう。</span><span class="sxs-lookup"><span data-stu-id="db68a-136">Consider the query `SELECT Title, HireDate FROM HumanResources.Employee WHERE EmployeeID = 250` in the [!INCLUDE[ssSampleDBobject](../../includes/sssampledbobject-md.md)] database.</span></span> <span data-ttu-id="db68a-137">このクエリが実行されるときに、クエリ オプティマイザーでは、データの取得に使用できる方法がそれぞれ評価され、最も効率的な方法が選択されます。</span><span class="sxs-lookup"><span data-stu-id="db68a-137">When this query is executed, the query optimizer evaluates each available method for retrieving the data and selects the most efficient method.</span></span> <span data-ttu-id="db68a-138">選択される方法には、テーブルのスキャン、1 つ以上のインデックスのスキャン (存在する場合) などがあります。</span><span class="sxs-lookup"><span data-stu-id="db68a-138">The method may be a table scan, or may be scanning one or more indexes if they exist.</span></span>  
  
 <span data-ttu-id="db68a-139">テーブル スキャンを実行すると、クエリ オプティマイザーでテーブルのすべての行が読み取られ、クエリの条件を満たす行が抽出されます。</span><span class="sxs-lookup"><span data-stu-id="db68a-139">When performing a table scan, the query optimizer reads all the rows in the table, and extracts the rows that meet the criteria of the query.</span></span> <span data-ttu-id="db68a-140">テーブル スキャンでは、ディスク I/O 操作が数多く行われ、リソースが集中的に使用される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="db68a-140">A table scan generates many disk I/O operations and can be resource intensive.</span></span> <span data-ttu-id="db68a-141">ただし、クエリの結果セットに大部分のテーブル行が含まれる場合などは、テーブル スキャンが最も効率的な方法になることがあります。</span><span class="sxs-lookup"><span data-stu-id="db68a-141">However, a table scan could be the most efficient method if, for example, the result set of the query is a high percentage of rows from the table.</span></span>  
  
 <span data-ttu-id="db68a-142">クエリ オプティマイザーでインデックスが使用されるときは、インデックス キー列が検索され、クエリで必要とされる行のストレージの場所が検索されて、一致する行がその場所から抽出されます。</span><span class="sxs-lookup"><span data-stu-id="db68a-142">When the query optimizer uses an index, it searches the index key columns, finds the storage location of the rows needed by the query and extracts the matching rows from that location.</span></span> <span data-ttu-id="db68a-143">一般に、インデックスの検索はテーブルの検索よりも高速です。これは、テーブルとは異なり、多くの場合、インデックスでは各行にごく少数の列しか含まれず、行が既に並べ替え済みであるためです。</span><span class="sxs-lookup"><span data-stu-id="db68a-143">Generally, searching the index is much faster than searching the table because unlike a table, an index frequently contains very few columns per row and the rows are in sorted order.</span></span>  
  
 <span data-ttu-id="db68a-144">クエリ オプティマイザーでは、通常、クエリを実行するときに最も効率的な方法が選択されます。</span><span class="sxs-lookup"><span data-stu-id="db68a-144">The query optimizer typically selects the most efficient method when executing queries.</span></span> <span data-ttu-id="db68a-145">ただし、インデックスが使用できなければ、クエリ オプティマイザーではテーブル スキャンを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="db68a-145">However, if no indexes are available, the query optimizer must use a table scan.</span></span> <span data-ttu-id="db68a-146">クエリ オプティマイザーが効率的なインデックスを選択できるように、環境に最も適したインデックスを設計および作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="db68a-146">Your task is to design and create indexes that are best suited to your environment so that the query optimizer has a selection of efficient indexes from which to select.</span></span> [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]<span data-ttu-id="db68a-147">[データベース エンジン チューニング アドバイザー](../performance/database-engine-tuning-advisor.md) が用意されており、データベース環境の分析や適切なインデックスの選択に役立てることができます。</span><span class="sxs-lookup"><span data-stu-id="db68a-147">provides the [Database Engine Tuning Advisor](../performance/database-engine-tuning-advisor.md) to help with the analysis of your database environment and in the selection of appropriate indexes.</span></span>  
  
## <a name="related-tasks"></a><span data-ttu-id="db68a-148">Related Tasks</span><span class="sxs-lookup"><span data-stu-id="db68a-148">Related Tasks</span></span>  
 [<span data-ttu-id="db68a-149">クラスター化インデックスの作成</span><span class="sxs-lookup"><span data-stu-id="db68a-149">Create Clustered Indexes</span></span>](create-clustered-indexes.md)  
  
 [<span data-ttu-id="db68a-150">非クラスター化インデックスの作成</span><span class="sxs-lookup"><span data-stu-id="db68a-150">Create Nonclustered Indexes</span></span>](create-nonclustered-indexes.md)  
  
  
