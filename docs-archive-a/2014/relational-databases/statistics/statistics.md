---
title: 統計 | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: performance
ms.topic: conceptual
helpviewer_keywords:
- statistical information [SQL Server], query optimization
- query performance [SQL Server], statistics
- query optimization statistics [SQL Server]
- statistical information [SQL Server], database options
- query optimization statistics [SQL Server], about query optimization statistics
- statistical information [SQL Server], guidelines
- statistical information [SQL Server]
- using statistics [SQL Server]
- statistical information [SQL Server], indexes
- index statistics [SQL Server]
- query optimizer [SQL Server], statistics
- statistics [SQL Server]
ms.assetid: b86a88ba-4f7c-4e19-9fbd-2f8bcd3be14a
author: MikeRayMSFT
ms.author: mikeray
ms.openlocfilehash: 0f0950e48245bed53581d2f91b120ab9555aa562
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/04/2020
ms.locfileid: "87644374"
---
# <a name="statistics"></a><span data-ttu-id="6d6b0-102">統計</span><span class="sxs-lookup"><span data-stu-id="6d6b0-102">Statistics</span></span>
  <span data-ttu-id="6d6b0-103">クエリ オプティマイザーでは、クエリのパフォーマンスを向上させるクエリ プランを作成するために統計を使用します。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-103">The query optimizer uses statistics to create query plans that improve query performance.</span></span> <span data-ttu-id="6d6b0-104">ほとんどのクエリでは、高品質のクエリ プランに必要な統計がクエリ オプティマイザーによって既に生成されていますが、最適な結果を得るために追加の統計情報を作成したりクエリのデザインを変更したりする必要がある場合もあります。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-104">For most queries, the query optimizer already generates the necessary statistics for a high quality query plan; in a few cases, you need to create additional statistics or modify the query design for best results.</span></span> <span data-ttu-id="6d6b0-105">このトピックでは、クエリ最適化に関する統計の概念と、それを効果的に使用するためのガイドラインについて説明します。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-105">This topic discusses statistics concepts and provides guidelines for using query optimization statistics effectively.</span></span>  
  
##  <a name="components-and-concepts"></a><a name="DefinitionQOStatistics"></a> <span data-ttu-id="6d6b0-106">コンポーネントおよび概念</span><span class="sxs-lookup"><span data-stu-id="6d6b0-106">Components and Concepts</span></span>  
 <span data-ttu-id="6d6b0-107">統計</span><span class="sxs-lookup"><span data-stu-id="6d6b0-107">Statistics</span></span>  
 <span data-ttu-id="6d6b0-108">クエリ最適化に関する統計は、テーブルまたはインデックス付きビューの 1 つまたは複数の列の値の分布に関する統計情報を格納するオブジェクトです。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-108">Statistics for query optimization are objects that contain statistical information about the distribution of values in one or more columns of a table or indexed view.</span></span> <span data-ttu-id="6d6b0-109">クエリオプティマイザーでは、これらの統計を使用して、クエリ結果内の*カーディナリティ*(行数) を推定します。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-109">The query optimizer uses these statistics to estimate the *cardinality*, or number of rows, in the query result.</span></span> <span data-ttu-id="6d6b0-110">これらの*カーディナリティの推定*により、クエリオプティマイザーは高品質なクエリプランを作成できます。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-110">These *cardinality estimates* enable the query optimizer to create a high-quality query plan.</span></span> <span data-ttu-id="6d6b0-111">たとえば、クエリ オプティマイザーでは、カーディナリティの推定に基づいて、リソースの消費が多い Index Scan 操作ではなく Index Seek 操作が使用される場合があります。この場合、クエリのパフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-111">For example, the query optimizer could use cardinality estimates to choose the index seek operator instead of the more resource-intensive index scan operator, and in doing so improve query performance.</span></span>  
  
 <span data-ttu-id="6d6b0-112">統計オブジェクトは 1 つ以上のテーブル列で構成されるリストごとに作成され、それぞれに最初の列の値の分布を示すヒストグラムが含まれます。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-112">Each statistics object is created on a list of one or more table columns and includes a histogram displaying the distribution of values in the first column.</span></span> <span data-ttu-id="6d6b0-113">複数列の統計オブジェクトには、さらに、列間の値の相関関係に関する統計情報も格納されます。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-113">Statistics objects on multiple columns also store statistical information about the correlation of values among the columns.</span></span> <span data-ttu-id="6d6b0-114">これらの相関関係の統計情報 ( *密度*) は、個別の列値を持つ行の数から得られます。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-114">These correlation statistics, or *densities*, are derived from the number of distinct rows of column values.</span></span> <span data-ttu-id="6d6b0-115">統計オブジェクトの詳細については、「[DBCC SHOW_STATISTICS &#40;Transact-SQL&#41;](/sql/t-sql/database-console-commands/dbcc-show-statistics-transact-sql)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-115">For more information about statistics objects, see [DBCC SHOW_STATISTICS &#40;Transact-SQL&#41;](/sql/t-sql/database-console-commands/dbcc-show-statistics-transact-sql).</span></span>  
  
 <span data-ttu-id="6d6b0-116">フィルター選択された統計情報</span><span class="sxs-lookup"><span data-stu-id="6d6b0-116">Filtered Statistics</span></span>  
 <span data-ttu-id="6d6b0-117">適切に定義されたデータのサブセットから選択するクエリでは、フィルター選択された統計情報を使用するとクエリのパフォーマンスを向上させることができます。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-117">Filtered statistics can improve query performance for queries that select from well-defined subsets of data.</span></span> <span data-ttu-id="6d6b0-118">フィルター選択された統計情報では、統計情報に含まれるデータのサブセットを選択するためにフィルター述語を使用します。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-118">Filtered statistics use a filter predicate to select the subset of data that is included in the statistics.</span></span> <span data-ttu-id="6d6b0-119">統計情報を適切にフィルター選択すると、テーブル全体の統計情報を使用する場合と比べて、クエリ実行プランが向上します。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-119">Well-designed filtered statistics can improve the query execution plan compared with full-table statistics.</span></span> <span data-ttu-id="6d6b0-120">フィルター述語の詳細については、「[CREATE STATISTICS &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-statistics-transact-sql)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-120">For more information about the filter predicate, see [CREATE STATISTICS &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-statistics-transact-sql).</span></span> <span data-ttu-id="6d6b0-121">フィルター選択された統計情報を作成する場合の詳細については、このトピックの「 [統計を作成する場合](#UpdateStatistics) 」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-121">For more information about when to create filtered statistics, see the [When to Create Statistics](#UpdateStatistics) section in this topic.</span></span> <span data-ttu-id="6d6b0-122">ケース スタディについては、SQLCAT Web サイトのブログ「 [Using Filtered Statistics with Partitioned Tables](https://go.microsoft.com/fwlink/?LinkId=178505)」(英語) を参照してください。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-122">For a case study, see the blog entry, [Using Filtered Statistics with Partitioned Tables](https://go.microsoft.com/fwlink/?LinkId=178505), on the SQLCAT Web site.</span></span>  
  
 <span data-ttu-id="6d6b0-123">統計オプション</span><span class="sxs-lookup"><span data-stu-id="6d6b0-123">Statistics Options</span></span>  
 <span data-ttu-id="6d6b0-124">統計の作成と更新のタイミングおよび方法を指定するための 3 つのオプションを設定できます。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-124">There are three options that you can set that affect when and how statistics are created and updated.</span></span> <span data-ttu-id="6d6b0-125">これらのオプションは、データベース レベルでのみ設定されます。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-125">These options are set at the database level only.</span></span>  
  
 <span data-ttu-id="6d6b0-126">AUTO_CREATE_STATISTICS オプション</span><span class="sxs-lookup"><span data-stu-id="6d6b0-126">AUTO_CREATE_STATISTICS Option</span></span>  
 <span data-ttu-id="6d6b0-127">統計の自動作成オプション AUTO_CREATE_STATISTICS がオンの場合、クエリ プランのカーディナリティの推定を向上させるために、クエリ オプティマイザーによってクエリ述語内の個々の列に関する統計が必要に応じて作成されます。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-127">When the automatic create statistics option, AUTO_CREATE_STATISTICS, is on, the query optimizer creates statistics on individual columns in the query predicate, as necessary, to improve cardinality estimates for the query plan.</span></span> <span data-ttu-id="6d6b0-128">これらの 1 列ずつの統計は、既存の統計オブジェクトにまだヒストグラムがない列について作成されます。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-128">These single-column statistics are created on columns that do not already have a histogram in an existing statistics object.</span></span> <span data-ttu-id="6d6b0-129">AUTO_CREATE_STATISTICS オプションでは、インデックスに対する統計を作成するかどうかは判断されません。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-129">The AUTO_CREATE_STATISTICS option does not determine whether statistics get created for indexes.</span></span> <span data-ttu-id="6d6b0-130">また、フィルター選択された統計情報も生成されません。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-130">This option also does not generate filtered statistics.</span></span> <span data-ttu-id="6d6b0-131">このオプションは、テーブル全体の 1 列ずつの統計にのみ適用されます。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-131">It applies strictly to single-column statistics for the full table.</span></span>  
  
 <span data-ttu-id="6d6b0-132">AUTO_CREATE_STATISTICS オプションを使用した結果としてクエリ オプティマイザーによって統計が作成された場合、その統計名は `_WA`で始まります。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-132">When the query optimizer creates statistics as a result of using the AUTO_CREATE_STATISTICS option, the statistics name starts with `_WA`.</span></span> <span data-ttu-id="6d6b0-133">次のクエリを使用すると、クエリ オプティマイザーでクエリ述語列の統計が作成されたかどうかを判断できます。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-133">You can use the following query to determine if the query optimizer has created statistics for a query predicate column.</span></span>  
  
```  
SELECT OBJECT_NAME(s.object_id) AS object_name,  
    COL_NAME(sc.object_id, sc.column_id) AS column_name,  
    s.name AS statistics_name  
FROM sys.stats AS s JOIN sys.stats_columns AS sc  
    ON s.stats_id = sc.stats_id AND s.object_id = sc.object_id  
WHERE s.name like '_WA%'  
ORDER BY s.name;  
```  
  
 <span data-ttu-id="6d6b0-134">AUTO_UPDATE_STATISTICS オプション</span><span class="sxs-lookup"><span data-stu-id="6d6b0-134">AUTO_UPDATE_STATISTICS Option</span></span>  
 <span data-ttu-id="6d6b0-135">統計の自動更新オプション AUTO_UPDATE_STATISTICS がオンの場合、古くなっている可能性がある統計がクエリ オプティマイザーによって判断され、それらがクエリで使用されると更新されます。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-135">When the automatic update statistics option, AUTO_UPDATE_STATISTICS, is on, the query optimizer determines when statistics might be out-of-date and then updates them when they are used by a query.</span></span> <span data-ttu-id="6d6b0-136">挿入、更新、削除、またはマージの各操作によってテーブルまたはインデックス付きビューのデータの分布が変わると、統計は古くなったと判断されます。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-136">Statistics become out-of-date after insert, update, delete, or merge operations change the data distribution in the table or indexed view.</span></span> <span data-ttu-id="6d6b0-137">クエリ オプティマイザーでは、統計が前回更新されてから発生したデータ変更の数をカウントし、その変更の数をしきい値と比較することで、統計が古くなっている可能性がないかを判断します。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-137">The query optimizer determines when statistics might be out-of-date by counting the number of data modifications since the last statistics update and comparing the number of modifications to a threshold.</span></span> <span data-ttu-id="6d6b0-138">このしきい値は、テーブルまたはインデックス付きビューの行数に基づいて決められます。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-138">The threshold is based on the number of rows in the table or indexed view.</span></span>  
  
 <span data-ttu-id="6d6b0-139">クエリ オプティマイザーによる古い統計の確認は、クエリをコンパイルする前と、キャッシュされたクエリ プランを実行する前に行われます。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-139">The query optimizer checks for out-of-date statistics before compiling a query and before executing a cached query plan.</span></span> <span data-ttu-id="6d6b0-140">クエリをコンパイルする前は、クエリ オプティマイザーで、クエリ述語内の列、テーブル、およびインデックス付きビューを使用して古くなっている可能性がある統計が判断されます。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-140">Before compiling a query, the query optimizer uses the columns, tables, and indexed views in the query predicate to determine which statistics might be out-of-date.</span></span> <span data-ttu-id="6d6b0-141">キャッシュされたクエリ プランを実行する前は、 [!INCLUDE[ssDE](../../../includes/ssde-md.md)] で、クエリ プランが最新の統計を参照しているかどうかが確認されます。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-141">Before executing a cached query plan, the [!INCLUDE[ssDE](../../../includes/ssde-md.md)] verifies that the query plan references up-to-date statistics.</span></span>  
  
 <span data-ttu-id="6d6b0-142">AUTO_UPDATE_STATISTICS オプションは、インデックスに対して作成された統計オブジェクト、クエリ述語内の列に対して 1 列ずつ作成された統計オブジェクト、および [CREATE STATISTICS](/sql/t-sql/statements/create-statistics-transact-sql) ステートメントを使用して作成された統計に適用されます。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-142">The AUTO_UPDATE_STATISTICS option applies to statistics objects created for indexes, single-columns in query predicates, and statistics created with the [CREATE STATISTICS](/sql/t-sql/statements/create-statistics-transact-sql) statement.</span></span> <span data-ttu-id="6d6b0-143">また、フィルター選択された統計情報にも適用されます。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-143">This option also applies to filtered statistics.</span></span>  
  
 <span data-ttu-id="6d6b0-144">AUTO_UPDATE_STATISTICS_ASYNC</span><span class="sxs-lookup"><span data-stu-id="6d6b0-144">AUTO_UPDATE_STATISTICS_ASYNC</span></span>  
 <span data-ttu-id="6d6b0-145">統計の非同期更新オプション AUTO_UPDATE_STATISTICS_ASYNC によって、クエリ オプティマイザーで統計の同期更新と非同期更新のどちらを使用するかが決まります。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-145">The asynchronous statistics update option, AUTO_UPDATE_STATISTICS_ASYNC, determines whether the query optimizer uses synchronous or asynchronous statistics updates.</span></span> <span data-ttu-id="6d6b0-146">既定では、統計の非同期更新オプションはオフであり、クエリ オプティマイザーによる統計の更新は同期更新になります。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-146">By default, the asynchronous statistics update option is off, and the query optimizer updates statistics synchronously.</span></span> <span data-ttu-id="6d6b0-147">AUTO_UPDATE_STATISTICS_ASYNC オプションは、インデックスに対して作成された統計オブジェクト、クエリ述語内の列に対して 1 列ずつ作成された統計オブジェクト、および [CREATE STATISTICS](/sql/t-sql/statements/create-statistics-transact-sql) ステートメントを使用して作成された統計に適用されます。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-147">The AUTO_UPDATE_STATISTICS_ASYNC option applies to statistics objects created for indexes, single columns in query predicates, and statistics created with the [CREATE STATISTICS](/sql/t-sql/statements/create-statistics-transact-sql) statement.</span></span>  
  
 <span data-ttu-id="6d6b0-148">統計の更新には、同期更新 (既定) と非同期更新があります。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-148">Statistics updates can be either synchronous (the default) or asynchronous.</span></span> <span data-ttu-id="6d6b0-149">統計の同期更新では、クエリは常に最新の統計を使用してコンパイルおよび実行されます。統計が古い場合、クエリ オプティマイザーでは、統計が更新されるまでクエリのコンパイルおよび実行を待機します。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-149">With synchronous statistics updates, queries always compile and execute with up-to-date statistics; When statistics are out-of-date, the query optimizer waits for updated statistics before compiling and executing the query.</span></span> <span data-ttu-id="6d6b0-150">統計の非同期更新では、クエリは、既存の統計が古い場合でもその統計を使用してコンパイルされます。クエリのコンパイル時に古い統計が使用された場合、クエリ オプティマイザーで最適なクエリ プランが選択されない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-150">With asynchronous statistics updates, queries compile with existing statistics even if the existing statistics are out-of-date; The query optimizer could choose a suboptimal query plan if statistics are out-of-date when the query compiles.</span></span> <span data-ttu-id="6d6b0-151">非同期更新の完了後にコンパイルされるクエリには、更新された統計を使用できます。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-151">Queries that compile after the asynchronous updates have completed will benefit from using the updated statistics.</span></span>  
  
 <span data-ttu-id="6d6b0-152">テーブルの切り捨てや大部分の行の一括更新を行うなど、データの分布が変わる操作を実行する場合は、同期統計を使用することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-152">Consider using synchronous statistics when you perform operations that change the distribution of data, such as truncating a table or performing a bulk update of a large percentage of the rows.</span></span> <span data-ttu-id="6d6b0-153">操作が完了した後に統計を更新していない場合、同期統計を使用すれば、変更されたデータに対するクエリを実行する前に統計が最新になります。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-153">If you do not update the statistics after completing the operation, using synchronous statistics will ensure statistics are up-to-date before executing queries on the changed data.</span></span>  
  
 <span data-ttu-id="6d6b0-154">次のような場合は、非同期統計を使用してクエリの応答時間を予測しやすくすることを検討してください。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-154">Consider using asynchronous statistics to achieve more predictable query response times for the following scenarios:</span></span>  
  
-   <span data-ttu-id="6d6b0-155">アプリケーションで同じクエリ、類似のクエリ、またはキャッシュされた類似のクエリ プランを頻繁に実行する場合。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-155">Your application frequently executes the same query, similar queries, or similar cached query plans.</span></span> <span data-ttu-id="6d6b0-156">クエリの応答時間は、統計の同期更新を使用するよりも非同期更新を使用した方が予測しやすくなります。非同期更新の場合、クエリ オプティマイザーでは、統計が最新になるまで待機せずに着信クエリを実行できるためです。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-156">Your query response times might be more predictable with asynchronous statistics updates than with synchronous statistics updates because the query optimizer can execute incoming queries without waiting for up-to-date statistics.</span></span> <span data-ttu-id="6d6b0-157">これにより、一部のクエリの遅延については回避することができます。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-157">This avoids delaying some queries and not others.</span></span>  
  
-   <span data-ttu-id="6d6b0-158">アプリケーションで統計の更新を待機している 1 つ以上のクエリによって、クライアント要求がタイムアウトする場合。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-158">Your application has experienced client request time outs caused by one or more queries waiting for updated statistics.</span></span> <span data-ttu-id="6d6b0-159">場合によっては、同期統計を待機していることが原因で、厳しいタイムアウト時間が設定されたアプリケーションが失敗することがあります。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-159">In some cases, waiting for synchronous statistics could cause applications with aggressive time outs to fail.</span></span>  
  
 <span data-ttu-id="6d6b0-160">INCREMENTAL STATS</span><span class="sxs-lookup"><span data-stu-id="6d6b0-160">INCREMENTAL STATS</span></span>  
 <span data-ttu-id="6d6b0-161">ON の場合、作成される統計はパーティションごとの統計です。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-161">When ON, the statistics created are per partition statistics.</span></span> <span data-ttu-id="6d6b0-162">OFF の場合、統計ツリーが削除され、 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] によって統計が再計算されます。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-162">When OFF, the statistics tree is dropped and [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] re-computes the statistics.</span></span> <span data-ttu-id="6d6b0-163">既定値は OFF です。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-163">The default is OFF.</span></span> <span data-ttu-id="6d6b0-164">この設定は、データベース レベルの INCREMENTAL プロパティをオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-164">This setting overrides the database level INCREMENTAL property.</span></span>  
  
 <span data-ttu-id="6d6b0-165">大きなテーブルに新しいパーティションを追加した場合、新しいパーティションが含まれるように統計を更新する必要があります。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-165">When new partitions are added to a large table, statistics should be updated to include the new partitions.</span></span> <span data-ttu-id="6d6b0-166">ただし、テーブル全体のスキャン (FULLSCAN または SAMPLE オプション) に要する時間は非常に長くなることがあります。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-166">However the time required to scan the entire table (FULLSCAN or SAMPLE option) might be quite long.</span></span> <span data-ttu-id="6d6b0-167">また、新しいパーティションに対する統計のみが必要となるため、テーブル全体をスキャンする必要はありません。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-167">Also, scanning the entire table isn't necessary because only the statistics on the new partitions might be needed.</span></span> <span data-ttu-id="6d6b0-168">増分オプションでは、パーティションごとの統計が作成され格納されるため、更新時には、新しい統計を必要とするそれらのパーティションの統計のみを更新します。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-168">The incremental option creates and stores statistics on a per partition basis, and when updated, only refreshes statistics on those partitions that need new statistics</span></span>  
  
 <span data-ttu-id="6d6b0-169">パーティションごとの統計がサポートされていない場合、このオプションは無視され、警告が生成されます。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-169">If per partition statistics are not supported the option is ignored and a warning is generated.</span></span> <span data-ttu-id="6d6b0-170">次の種類の統計では、増分統計がサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-170">Incremental stats are not supported for following statistics types:</span></span>  
  
-   <span data-ttu-id="6d6b0-171">ベース テーブルにパーティションで固定されていないインデックスを使用して作成された統計。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-171">Statistics created with indexes that are not partition-aligned with the base table.</span></span>  
  
-   <span data-ttu-id="6d6b0-172">AlwaysOn の読み取り可能なセカンダリ データベースに対して作成された統計。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-172">Statistics created on AlwaysOn readable secondary databases.</span></span>  
  
-   <span data-ttu-id="6d6b0-173">読み取り専用のデータベースに対して作成された統計。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-173">Statistics created on read-only databases.</span></span>  
  
-   <span data-ttu-id="6d6b0-174">フィルター選択されたインデックスに対して作成された統計。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-174">Statistics created on filtered indexes.</span></span>  
  
-   <span data-ttu-id="6d6b0-175">ビューに対して作成された統計。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-175">Statistics created on views.</span></span>  
  
-   <span data-ttu-id="6d6b0-176">内部テーブルに対して作成された統計。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-176">Statistics created on internal tables.</span></span>  
  
-   <span data-ttu-id="6d6b0-177">空間インデックスまたは XML インデックスを使用して作成された統計。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-177">Statistics created with spatial indexes or XML indexes.</span></span>  
  
||  
|-|  
|<span data-ttu-id="6d6b0-178">**適用対象**: [!INCLUDE[ssSQL14](../../includes/sssql14-md.md)] から [!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)]</span><span class="sxs-lookup"><span data-stu-id="6d6b0-178">**Applies to**: [!INCLUDE[ssSQL14](../../includes/sssql14-md.md)] through [!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)].</span></span>|  
  
##  <a name="when-to-create-statistics"></a><a name="CreateStatistics"></a><span data-ttu-id="6d6b0-179">統計を作成する場合</span><span class="sxs-lookup"><span data-stu-id="6d6b0-179">When to Create Statistics</span></span>  
 <span data-ttu-id="6d6b0-180">クエリ オプティマイザーによって、既に次のようにして統計が作成されています。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-180">The query optimizer already creates statistics in the following ways:</span></span>  
  
1.  <span data-ttu-id="6d6b0-181">インデックスの作成時に、クエリ オプティマイザーによってテーブルまたはビューのインデックスに対する統計が作成されます。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-181">The query optimizer creates statistics for indexes on tables or views when the index is created.</span></span> <span data-ttu-id="6d6b0-182">これらの統計は、インデックスのキー列について作成されます。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-182">These statistics are created on the key columns of the index.</span></span> <span data-ttu-id="6d6b0-183">インデックスがフィルター選択されたインデックスの場合は、フィルター選択されたインデックスに指定された行のサブセットと同じ行のサブセットについて、フィルター選択された統計が作成されます。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-183">If the index is a filtered index, the query optimizer creates filtered statistics on the same subset of rows specified for the filtered index.</span></span> <span data-ttu-id="6d6b0-184">フィルター選択されたインデックスの詳細については、「[フィルター選択されたインデックスの作成](../indexes/create-filtered-indexes.md)」および 「[CREATE INDEX &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-index-transact-sql)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-184">For more information about filtered indexes, see [Create Filtered Indexes](../indexes/create-filtered-indexes.md) and [CREATE INDEX &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-index-transact-sql).</span></span>  
  
2.  <span data-ttu-id="6d6b0-185">AUTO_CREATE_STATISTICS がオンの場合、クエリ オプティマイザーによってクエリ述語内の列に対して 1 列ずつ統計が作成されます。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-185">The query optimizer creates statistics for single columns in query predicates when AUTO_CREATE_STATISTICS is on.</span></span>  
  
 <span data-ttu-id="6d6b0-186">ほとんどのクエリでは、これらの 2 つの方法で作成された統計を使用すれば、高品質のクエリ プランになります。ただし、 [CREATE STATISTICS](/sql/t-sql/statements/create-statistics-transact-sql) ステートメントを使用して追加の統計を作成することで、クエリ プランが向上する場合もあります。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-186">For most queries, these two methods for creating statistics ensure a high-quality query plan; in a few cases, you can improve query plans by creating additional statistics with the [CREATE STATISTICS](/sql/t-sql/statements/create-statistics-transact-sql) statement.</span></span> <span data-ttu-id="6d6b0-187">これらの追加の統計では、クエリ オプティマイザーでインデックスまたは 1 列ずつの統計を作成する場合には考慮されない統計的相関関係を取り込むことができます。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-187">These additional statistics can capture statistical correlations that the query optimizer does not account for when it creates statistics for indexes or single columns.</span></span> <span data-ttu-id="6d6b0-188">アプリケーションのテーブル データには、計算して統計オブジェクトに含めればクエリ オプティマイザーでクエリ プランを向上させることができる、他の統計的相関関係が含まれている場合があります。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-188">Your application might have additional statistical correlations in the table data that, if calculated into a statistics object, could enable the query optimizer to improve query plans.</span></span> <span data-ttu-id="6d6b0-189">たとえば、データ行のサブセットに関するフィルター選択された統計情報や、クエリ述語列の複数列統計を使用することで、クエリ プランが向上することがあります。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-189">For example, filtered statistics on a subset of data rows or multicolumn statistics on query predicate columns might improve the query plan.</span></span>  
  
 <span data-ttu-id="6d6b0-190">CREATE STATISTICS ステートメントを使用して統計を作成する場合、AUTO_CREATE_STATISTICS オプションをオンのままにし、クエリ述語列に対する 1 列ずつの統計がクエリ オプティマイザーによって通常どおり作成されるようにしておくことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-190">When creating statistics with the CREATE STATISTICS statement, we recommend keeping the AUTO_CREATE_STATISTICS option on so that the query optimizer continues to routinely create single-column statistics for query predicate columns.</span></span> <span data-ttu-id="6d6b0-191">クエリ述語の詳細については、「[検索条件 &#40;Transact-SQL&#41;](/sql/t-sql/queries/search-condition-transact-sql)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-191">For more information about query predicates, see [Search Condition &#40;Transact-SQL&#41;](/sql/t-sql/queries/search-condition-transact-sql).</span></span>  
  
 <span data-ttu-id="6d6b0-192">次のいずれかに該当する場合は、CREATE STATISTICS ステートメントを使用して統計を作成することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-192">Consider creating statistics with the CREATE STATISTICS statement when any of the following applies:</span></span>  
  
-   <span data-ttu-id="6d6b0-193">[!INCLUDE[ssDE](../../../includes/ssde-md.md)] チューニング アドバイザーで統計を作成するように提示される。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-193">The [!INCLUDE[ssDE](../../../includes/ssde-md.md)] Tuning Advisor suggests creating statistics.</span></span>  
  
-   <span data-ttu-id="6d6b0-194">相関関係にある複数の列がクエリ述語に含まれているが、それらがまだ同じインデックスに存在しない。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-194">The query predicate contains multiple correlated columns that are not already in the same index.</span></span>  
  
-   <span data-ttu-id="6d6b0-195">データのサブセットから選択するクエリを使用する。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-195">The query selects from a subset of data.</span></span>  
  
-   <span data-ttu-id="6d6b0-196">クエリに統計がない。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-196">The query has missing statistics.</span></span>  
  
### <a name="query-predicate-contains-multiple-correlated-columns"></a><span data-ttu-id="6d6b0-197">相関関係にある複数の列がクエリ述語に含まれている</span><span class="sxs-lookup"><span data-stu-id="6d6b0-197">Query Predicate Contains Multiple Correlated Columns</span></span>  
 <span data-ttu-id="6d6b0-198">列間に相関関係や依存関係がある複数の列がクエリ述語に含まれている場合、複数列の統計を使用するとクエリ プランが向上することがあります。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-198">When a query predicate contains multiple columns that have cross-column relationships and dependencies, statistics on the multiple columns might improve the query plan.</span></span> <span data-ttu-id="6d6b0-199">複数列の統計には、 *密度*と呼ばれる列間の相関関係の統計が含まれます。これは、1 列ずつの統計では使用できません。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-199">Statistics on multiple columns contain cross-column correlation statistics, called *densities*, that are not available in single-column statistics.</span></span> <span data-ttu-id="6d6b0-200">複数の列間のデータの相関関係によってクエリ結果が異なる場合、密度を使用するとカーディナリティの推定が向上します。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-200">Densities can improve cardinality estimates when query results depend on data relationships among multiple columns.</span></span>  
  
 <span data-ttu-id="6d6b0-201">列が同じインデックスに既に存在する場合、複数列統計オブジェクトは既に存在するため、手動で作成する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-201">If the columns are already in the same index, the multicolumn statistics object already exists and it is not necessary to create it manually.</span></span> <span data-ttu-id="6d6b0-202">列が同じインデックスにまだ存在しない場合は、列のインデックスを作成するか CREATE STATISTICS ステートメントを使用することによって、複数列統計を作成できます。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-202">If the columns are not already in the same index, you can create multicolumn statistics by creating an index on the columns or by using the CREATE STATISTICS statement.</span></span> <span data-ttu-id="6d6b0-203">メンテナンスに必要なシステム リソースは、インデックスの方が統計オブジェクトよりも多くなります。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-203">It requires more system resources to maintain an index than a statistics object.</span></span> <span data-ttu-id="6d6b0-204">複数列のインデックスを必要としないアプリケーションの場合は、インデックスを作成せずに統計オブジェクトを作成すると、システム リソースを節約できます。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-204">If the application does not require the multicolumn index, you can economize on system resources by creating the statistics object without creating the index.</span></span>  
  
 <span data-ttu-id="6d6b0-205">複数列統計を作成する場合、統計オブジェクト定義内の列の順序によって、カーディナリティの推定に密度を使用した場合の効果が変わります。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-205">When creating multicolumn statistics, the order of the columns in the statistics object definition affects the effectiveness of densities for making cardinality estimates.</span></span> <span data-ttu-id="6d6b0-206">統計オブジェクトには、統計オブジェクト定義内のキー列の各プレフィックスの密度が格納されます。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-206">The statistics object stores densities for each prefix of key columns in the statistics object definition.</span></span> <span data-ttu-id="6d6b0-207">密度については、「[DBCC SHOW_STATISTICS &#40;Transact-SQL&#41;](/sql/t-sql/database-console-commands/dbcc-show-statistics-transact-sql)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-207">For more information about densities, see [DBCC SHOW_STATISTICS &#40;Transact-SQL&#41;](/sql/t-sql/database-console-commands/dbcc-show-statistics-transact-sql).</span></span>  
  
 <span data-ttu-id="6d6b0-208">カーディナリティの推定に効果的な密度を作成するには、クエリ述語内の列が、統計オブジェクト定義内の列のいずれかのプレフィックスに一致する必要があります。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-208">To create densities that are useful for cardinality estimates, the columns in the query predicate must match one of the prefixes of columns in the statistics object definition.</span></span> <span data-ttu-id="6d6b0-209">たとえば、次の例では、列 `LastName`、 `MiddleName`、および `FirstName`に対する複数列統計オブジェクトを作成しています。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-209">For example, the following creates a multicolumn statistics object on the columns `LastName`, `MiddleName`, and `FirstName`.</span></span>  
  
```  
USE AdventureWorks2012;  
GO  
IF EXISTS (SELECT name FROM sys.stats  
    WHERE name = 'LastFirst'  
    AND object_ID = OBJECT_ID ('Person.Person'))  
DROP STATISTICS Person.Person.LastFirst;  
GO  
CREATE STATISTICS LastFirst ON Person.Person (LastName, MiddleName, FirstName);  
GO  
```  
  
 <span data-ttu-id="6d6b0-210">この例では、統計オブジェクト `LastFirst` に、列プレフィックス (`LastName`)、(`LastName, MiddleName`)、および (`LastName, MiddleName, FirstName`) の密度が格納されています。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-210">In this example, the statistics object `LastFirst` has densities for the following column prefixes: (`LastName`), (`LastName, MiddleName`), and (`LastName, MiddleName, FirstName`).</span></span> <span data-ttu-id="6d6b0-211">(`LastName, FirstName`) の密度は使用できません。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-211">The density is not available for (`LastName, FirstName`).</span></span> <span data-ttu-id="6d6b0-212">`LastName` を使用せずに `FirstName` と `MiddleName` を使用したクエリの場合は、カーディナリティの推定に密度を使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-212">If the query uses `LastName` and `FirstName` without using `MiddleName`, the density is not available for cardinality estimates.</span></span>  
  
### <a name="query-selects-from-a-subset-of-data"></a><span data-ttu-id="6d6b0-213">データのサブセットから選択するクエリを使用する</span><span class="sxs-lookup"><span data-stu-id="6d6b0-213">Query Selects from a Subset of Data</span></span>  
 <span data-ttu-id="6d6b0-214">クエリ オプティマイザーでは、1 列ずつおよびインデックスに対して統計を作成する際、すべての行の値に対する統計を作成します。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-214">When the query optimizer creates statistics for single columns and indexes, it creates the statistics for the values in all rows.</span></span> <span data-ttu-id="6d6b0-215">行のサブセットから選択するクエリの場合、その行のサブセットのデータ分布が一意であれば、フィルター選択された統計情報を使用することでクエリ プランを向上させることができます。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-215">When queries select from a subset of rows, and that subset of rows has a unique data distribution, filtered statistics can improve query plans.</span></span> <span data-ttu-id="6d6b0-216">フィルター選択された統計情報は、CREATE STATISTICS ステートメントを WHERE 句と共に使用してフィルター述語の式を定義することで作成できます。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-216">You can create filtered statistics by using the CREATE STATISTICS statement with the WHERE clause to define the filter predicate expression.</span></span>  
  
 <span data-ttu-id="6d6b0-217">たとえば、 [!INCLUDE[ssSampleDBnormal](../../includes/sssampledbnormal-md.md)]を使用する場合、Production.Product テーブルの各製品は、Production.ProductCategory テーブルの 4 つのカテゴリ (Bikes、Components、Clothing、および Accessories) のいずれかに属しています。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-217">For example, using [!INCLUDE[ssSampleDBnormal](../../includes/sssampledbnormal-md.md)], each product in the Production.Product table belongs to one of four categories in the Production.ProductCategory table: Bikes, Components, Clothing, and Accessories.</span></span> <span data-ttu-id="6d6b0-218">各カテゴリでは、重量に関するデータ分布が異なります。自転車の重量は 13.77 ～ 30.0、部品の重量は 2.12 ～ 1050.00 (一部 NULL 値)、衣類の重量はすべて NULL、付属品の重量も NULL です。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-218">Each of the categories has a different data distribution for weight: bike weights range from 13.77 to 30.0, component weights range from 2.12 to 1050.00 with some NULL values, clothing weights are all NULL, and accessory weights are also NULL.</span></span>  
  
 <span data-ttu-id="6d6b0-219">たとえば Bikes の場合、自転車のすべての重量についてのフィルター選択された統計情報を使用すると、テーブル全体の統計情報を使用する場合や、Weight 列の統計情報が存在しない場合と比べて、より正確な統計情報がクエリ オプティマイザーに提供され、クエリ プランの品質が向上します。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-219">Using Bikes as an example, filtered statistics on all bike weights will provide more accurate statistics to the query optimizer and can improve the query plan quality compared with full-table statistics or nonexistent statistics on the Weight column.</span></span> <span data-ttu-id="6d6b0-220">自転車の重量の列は、フィルター選択された統計情報には適していますが、重量の参照が比較的少ない場合、フィルター選択されたインデックスには必ずしも適しているとは限りません。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-220">The bike weight column is a good candidate for filtered statistics but not necessarily a good candidate for a filtered index if the number of weight lookups is relatively small.</span></span> <span data-ttu-id="6d6b0-221">フィルター選択されたインデックスを使用することで得られる参照のパフォーマンスの向上よりも、フィルター選択されたインデックスをデータベースに追加するためのメンテナンス コストとストレージ コストの増加の方が大きい場合があります。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-221">The performance gain for lookups that a filtered index provides might not outweigh the additional maintenance and storage cost for adding a filtered index to the database.</span></span>  
  
 <span data-ttu-id="6d6b0-222">次のステートメントでは、Bikes のすべてのサブカテゴリについてのフィルター選択された統計 `BikeWeights` を作成します。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-222">The following statement creates the `BikeWeights` filtered statistics on all of the subcategories for Bikes.</span></span> <span data-ttu-id="6d6b0-223">フィルター選択された述語式で、比較 `Production.ProductSubcategoryID IN (1,2,3)`を使用して自転車のすべてのサブカテゴリを列挙することで、自転車を定義しています。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-223">The filtered predicate expression defines bikes by enumerating all of the bike subcategories with the comparison `Production.ProductSubcategoryID IN (1,2,3)`.</span></span> <span data-ttu-id="6d6b0-224">Bikes カテゴリは Production.ProductCategory テーブルに格納されているため、述語でそのカテゴリ名を使用することはできません。フィルター式に含まれるすべての列が、同じテーブル内に存在する必要があります。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-224">The predicate cannot use the Bikes category name because it is stored in the Production.ProductCategory table, and all columns in the filter expression must be in the same table.</span></span>  
  
 [!code-sql[StatisticsDDL#FilteredStats2](../../snippets/tsql/SQL14/tsql/statisticsddl/transact-sql/filteredstats.sql#filteredstats2)]  
  
 <span data-ttu-id="6d6b0-225">クエリ オプティマイザーでは、 `BikeWeights` というフィルター選択された統計情報を使用して、重量が `25`を超えるすべての自転車を選択する次のクエリのクエリ プランを向上させることができます。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-225">The query optimizer can use the `BikeWeights` filtered statistics to improve the query plan for the following query that selects all of the bikes that weigh more than `25`.</span></span>  
  
```  
SELECT P.Weight AS Weight, S.Name AS BikeName  
FROM Production.Product AS P  
    JOIN Production.ProductSubcategory AS S   
    ON P.ProductSubcategoryID = S.ProductSubcategoryID  
WHERE P.ProductSubcategoryID IN (1,2,3) AND P.Weight > 25  
ORDER BY P.Weight;  
GO  
```  
  
### <a name="query-identifies-missing-statistics"></a><span data-ttu-id="6d6b0-226">統計がないことをクエリで識別する</span><span class="sxs-lookup"><span data-stu-id="6d6b0-226">Query Identifies Missing Statistics</span></span>  
 <span data-ttu-id="6d6b0-227">クエリ オプティマイザーでは、エラーやその他のイベントによって統計を作成できない場合、統計を使用せずにクエリ プランを作成します。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-227">If an error or other event prevents the query optimizer from creating statistics, the query optimizer creates the query plan without using statistics.</span></span> <span data-ttu-id="6d6b0-228">クエリ オプティマイザーでは存在しない統計をマークし、次回のクエリの実行時に再生成しようとします。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-228">The query optimizer marks the statistics as missing and attempts to regenerate the statistics the next time the query is executed.</span></span>  
  
 <span data-ttu-id="6d6b0-229">統計が存在しない場合は、 [!INCLUDE[ssManStudioFull](../../includes/ssmanstudiofull-md.md)]を使用してクエリの実行プランをグラフィカルに表示すると、警告 (赤色のテーブル名) が表示されます。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-229">Missing statistics are indicated as warnings (table name in red text) when the execution plan of a query is graphically displayed using [!INCLUDE[ssManStudioFull](../../includes/ssmanstudiofull-md.md)].</span></span> <span data-ttu-id="6d6b0-230">また、 **を使用して** Missing Column Statistics [!INCLUDE[ssSqlProfiler](../../includes/sssqlprofiler-md.md)] イベント クラスを監視すると、統計がない場合はそのことがわかります。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-230">Additionally, monitoring the **Missing Column Statistics** event class by using [!INCLUDE[ssSqlProfiler](../../includes/sssqlprofiler-md.md)] indicates when statistics are missing.</span></span> <span data-ttu-id="6d6b0-231">詳細については、「[Errors and Warnings イベント カテゴリ &#40;データベース エンジン&#41;](../event-classes/errors-and-warnings-event-category-database-engine.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-231">For more information, see [Errors and Warnings Event Category &#40;Database Engine&#41;](../event-classes/errors-and-warnings-event-category-database-engine.md).</span></span>  
  
 <span data-ttu-id="6d6b0-232">統計がない場合は、次の手順を実行します。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-232">If statistics are missing, perform the following steps:</span></span>  
  
-   <span data-ttu-id="6d6b0-233">AUTO_CREATE_STATISTICS と AUTO_UPDATE_STATISTICS がオンになっていることを確認します。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-233">Verify that AUTO_CREATE_STATISTICS and AUTO_UPDATE_STATISTICS are on.</span></span>  
  
-   <span data-ttu-id="6d6b0-234">データベースが読み取り専用ではないことを確認します。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-234">Verify that the database is not read-only.</span></span> <span data-ttu-id="6d6b0-235">データベースが読み取り専用の場合、クエリ オプティマイザーでは統計を保存できません。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-235">If the database is read-only, the query optimizer cannot save statistics.</span></span>  
  
-   <span data-ttu-id="6d6b0-236">存在しない統計を CREATE STATISTICS ステートメントを使用して作成します。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-236">Create the missing statistics by using the CREATE STATISTICS statement.</span></span>  
  
 <span data-ttu-id="6d6b0-237">読み取り専用データベースまたは読み取り専用スナップショットに関する統計が欠落しているか、古くなっている場合、[!INCLUDE[ssDE](../../../includes/ssde-md.md)]は、`tempdb` に一時的な統計を作成して維持します。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-237">When statistics on a read-only database or read-only snapshot are missing or stale, the [!INCLUDE[ssDE](../../../includes/ssde-md.md)] creates and maintains temporary statistics in `tempdb`.</span></span> <span data-ttu-id="6d6b0-238">[!INCLUDE[ssDE](../../../includes/ssde-md.md)] で一時的な統計を作成する場合は、一時的な統計と永続的な統計とを区別するためのサフィックス _readonly_database_statistic が統計名に付加されます。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-238">When the [!INCLUDE[ssDE](../../../includes/ssde-md.md)] creates temporary statistics, the statistics name is appended with the suffix _readonly_database_statistic to differentiate the temporary statistics from the permanent statistics.</span></span> <span data-ttu-id="6d6b0-239">サフィックス _readonly_database_statistic は、 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]によって生成される統計用に予約されています。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-239">The suffix _readonly_database_statistic is reserved for statistics generated by [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="6d6b0-240">読み書き可能なデータベースでは、一時的な統計用のスクリプトを作成して再現できます。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-240">Scripts for the temporary statistics can be created and reproduced on a read-write database.</span></span> <span data-ttu-id="6d6b0-241">スクリプトを作成する場合、 [!INCLUDE[ssManStudio](../../includes/ssmanstudio-md.md)] では、統計名のサフィックスを _readonly_database_statistic から _readonly_database_statistic_scripted に変更します。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-241">When scripted, [!INCLUDE[ssManStudio](../../includes/ssmanstudio-md.md)] changes the suffix of the statistics name from _readonly_database_statistic to _readonly_database_statistic_scripted.</span></span>  
  
 <span data-ttu-id="6d6b0-242">一時的な統計を作成して更新できるのは、 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] のみです。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-242">Only [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] can create and update temporary statistics.</span></span> <span data-ttu-id="6d6b0-243">ただし、永続的な統計の場合と同じツールを使用すると、一時的な統計を削除して、統計のプロパティを監視できます。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-243">However, you can delete temporary statistics and monitor statistics properties using the same tools that you use for permanent statistics:</span></span>  
  
-   <span data-ttu-id="6d6b0-244">[DROP STATISTICS &#40;Transact-SQL&#41;](/sql/t-sql/statements/drop-statistics-transact-sql) ステートメントを使用して作成された統計に適用されます。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-244">Delete temporary statistics using the [DROP STATISTICS &#40;Transact-SQL&#41;](/sql/t-sql/statements/drop-statistics-transact-sql) statement.</span></span>  
  
-   <span data-ttu-id="6d6b0-245">**sys.stats** カタログ ビューと **sys.stats_columns** カタログ ビューを使用して統計を監視します。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-245">Monitor statistics using the **sys.stats** and **sys.stats_columns** catalog views.</span></span> <span data-ttu-id="6d6b0-246">**sys_stats** には、どの統計が一時的または永続的なものかを示すための **is_temporary** 列が含まれています。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-246">**sys_stats** includes the **is_temporary** column, to indicate which statistics are permanent and which are temporary.</span></span>  
  
 <span data-ttu-id="6d6b0-247">一時的な統計は `tempdb` に格納されるので、[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] サービスを再起動すると、一時的な統計がすべて表示されなくなります。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-247">Because temporary statistics are stored in `tempdb`, a restart of the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] service causes all temporary statistics to disappear.</span></span>  
  
##  <a name="when-to-update-statistics"></a><a name="UpdateStatistics"></a><span data-ttu-id="6d6b0-248">統計を更新する場合</span><span class="sxs-lookup"><span data-stu-id="6d6b0-248">When to Update Statistics</span></span>  
 <span data-ttu-id="6d6b0-249">クエリ オプティマイザーでは、古くなっている可能性がある統計を判断し、それらがクエリ プランに必要な場合は更新します。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-249">The query optimizer determines when statistics might be out-of-date and then updates them when they are needed for a query plan.</span></span> <span data-ttu-id="6d6b0-250">場合によっては、AUTO_UPDATE_STATISTICS をオンにした場合より頻繁に統計を更新することで、クエリ プランが向上し、クエリのパフォーマンスが向上することがあります。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-250">In some cases you can improve the query plan and therefore improve query performance by updating statistics more frequently than occur when AUTO_UPDATE_STATISTICS is on.</span></span> <span data-ttu-id="6d6b0-251">統計は、UPDATE STATISTICS ステートメントまたは sp_updatestats ストアド プロシージャを使用して更新できます。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-251">You can update statistics with the UPDATE STATISTICS statement or the stored procedure sp_updatestats.</span></span>  
  
 <span data-ttu-id="6d6b0-252">統計を更新すると、クエリが最新の統計を使用してコンパイルされるようになります。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-252">Updating statistics ensures that queries compile with up-to-date statistics.</span></span> <span data-ttu-id="6d6b0-253">ただし、統計の更新によりクエリが再コンパイルされます。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-253">However, updating statistics causes queries to recompile.</span></span> <span data-ttu-id="6d6b0-254">パフォーマンスの向上を目的とする場合、クエリ プランの改善とクエリの再コンパイルに要する時間の間にはトレードオフの関係があるため、あまり頻繁に統計を更新しないようにすることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-254">We recommend not updating statistics too frequently because there is a performance tradeoff between improving query plans and the time it takes to recompile queries.</span></span> <span data-ttu-id="6d6b0-255">実際のトレードオフはアプリケーションによって異なります。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-255">The specific tradeoffs depend on your application.</span></span>  
  
 <span data-ttu-id="6d6b0-256">UPDATE STATISTICS または sp_updatestats を使用して統計を更新する場合、AUTO_UPDATE_STATISTICS オプションを ON に設定したままにし、通常の更新がクエリ オプティマイザーによって引き続き行われるようにしておくことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-256">When updating statistics with UPDATE STATISTICS or sp_updatestats, we recommend keeping AUTO_UPDATE_STATISTICS set to ON so that the query optimizer continues to routinely update statistics.</span></span> <span data-ttu-id="6d6b0-257">列、インデックス、テーブル、またはインデックス付きビューの統計を更新する方法については、「[UPDATE STATISTICS &#40;Transact-SQL&#41;](/sql/t-sql/statements/update-statistics-transact-sql)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-257">For more information about how to update statistics on a column, an index, a table, or an indexed view, see [UPDATE STATISTICS &#40;Transact-SQL&#41;](/sql/t-sql/statements/update-statistics-transact-sql).</span></span> <span data-ttu-id="6d6b0-258">データベース内のすべてのユーザー定義および内部テーブルの統計を更新する方法については、ストアド プロシージャ [sp_updatestats &#40;Transact-SQL&#41;](/sql/relational-databases/system-stored-procedures/sp-updatestats-transact-sql) の説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-258">For information about how to update statistics for all user-defined and internal tables in the database, see the stored procedure [sp_updatestats &#40;Transact-SQL&#41;](/sql/relational-databases/system-stored-procedures/sp-updatestats-transact-sql).</span></span>  
  
 <span data-ttu-id="6d6b0-259">統計の最終更新日を調べるには、 [STATS_DATE](/sql/t-sql/functions/stats-date-transact-sql) 関数を使用します。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-259">To determine when statistics were last updated, use the [STATS_DATE](/sql/t-sql/functions/stats-date-transact-sql) function.</span></span>  
  
 <span data-ttu-id="6d6b0-260">次のような場合は、統計を更新することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-260">Consider updating statistics for the following conditions:</span></span>  
  
-   <span data-ttu-id="6d6b0-261">クエリの実行に時間がかかる。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-261">Query execution times are slow.</span></span>  
  
-   <span data-ttu-id="6d6b0-262">昇順または降順のキー列に対して挿入操作を実行する。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-262">Insert operations occur on ascending or descending key columns.</span></span>  
  
-   <span data-ttu-id="6d6b0-263">メンテナンス操作の実行後。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-263">After maintenance operations.</span></span>  
  
### <a name="query-execution-times-are-slow"></a><span data-ttu-id="6d6b0-264">クエリの実行に時間がかかる</span><span class="sxs-lookup"><span data-stu-id="6d6b0-264">Query Execution Times Are Slow</span></span>  
 <span data-ttu-id="6d6b0-265">クエリの応答時間が遅い場合や予測できない場合は、他のトラブルシューティング手順を実行する前に、クエリの統計が最新のものであることを確認してください。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-265">If query response times are slow or unpredictable, ensure that queries have up-to-date statistics before performing additional troubleshooting steps.</span></span>  
  
### <a name="insert-operations-occur-on-ascending-or-descending-key-columns"></a><span data-ttu-id="6d6b0-266">昇順または降順のキー列に対して挿入操作を実行する</span><span class="sxs-lookup"><span data-stu-id="6d6b0-266">Insert Operations Occur on Ascending or Descending Key Columns</span></span>  
 <span data-ttu-id="6d6b0-267">昇順または降順のキー列 (IDENTITY 列や実時間のタイムスタンプ列など) の統計では、クエリ オプティマイザーで実行されるよりも頻繁に統計の更新が必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-267">Statistics on ascending or descending key columns, such as IDENTITY or real-time timestamp columns, might require more frequent statistics updates than the query optimizer performs.</span></span> <span data-ttu-id="6d6b0-268">挿入操作によって昇順または降順の列に新しい値が追加された場合に、</span><span class="sxs-lookup"><span data-stu-id="6d6b0-268">Insert operations append new values to ascending or descending columns.</span></span> <span data-ttu-id="6d6b0-269">追加された行数が少なすぎると、統計の更新が実行されないことがあります。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-269">The number of rows added might be too small to trigger a statistics update.</span></span> <span data-ttu-id="6d6b0-270">統計が最新ではない場合に、追加された最新の行から選択するクエリを実行すると、現在の統計にそれらの新しい値のカーディナリティの推定が含まれません。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-270">If statistics are not up-to-date and queries select from the most recently added rows, the current statistics will not have cardinality estimates for these new values.</span></span> <span data-ttu-id="6d6b0-271">その結果、カーディナリティの推定が不正確になり、クエリのパフォーマンスが低下することがあります。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-271">This can result in inaccurate cardinality estimates and slow query performance.</span></span>  
  
 <span data-ttu-id="6d6b0-272">たとえば、最新の販売注文日から選択するクエリで、統計が最新の販売注文日のカーディナリティの推定を含むように更新されていないと、カーディナリティの推定が不正確になります。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-272">For example, a query that selects from the most recent sales order dates will have inaccurate cardinality estimates if the statistics are not updated to include cardinality estimates for the most recent sales order dates.</span></span>  
  
### <a name="after-maintenance-operations"></a><span data-ttu-id="6d6b0-273">メンテナンス操作の実行後</span><span class="sxs-lookup"><span data-stu-id="6d6b0-273">After Maintenance Operations</span></span>  
 <span data-ttu-id="6d6b0-274">テーブルの切り捨てや大部分の行の一括挿入を行うなど、データの分布が変わるメンテナンス操作を実行した後は、統計を更新することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-274">Consider updating statistics after performing maintenance procedures that change the distribution of data, such as truncating a table or performing a bulk insert of a large percentage of the rows.</span></span> <span data-ttu-id="6d6b0-275">これにより、統計の自動更新を待つことによってクエリ処理で発生する以降の遅延を回避することができます。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-275">This can avoid future delays in query processing while queries wait for automatic statistics updates.</span></span>  
  
 <span data-ttu-id="6d6b0-276">インデックスの再構築、デフラグ、再構成などの操作では、データの分布は変わりません。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-276">Operations such as rebuilding, defragmenting, or reorganizing an index do not change the distribution of data.</span></span> <span data-ttu-id="6d6b0-277">そのため、ALTER INDEX REBUILD、DBCC REINDEX、DBCC INDEXDEFRAG、または ALTER INDEX REORGANIZE の各操作を実行した後に統計を更新する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-277">Therefore, you do not need to update statistics after performing ALTER INDEX REBUILD, DBCC REINDEX, DBCC INDEXDEFRAG, or ALTER INDEX REORGANIZE operations.</span></span> <span data-ttu-id="6d6b0-278">ALTER INDEX REBUILD または DBCC DBREINDEX を使用してテーブルまたはビューのインデックスを再構築した場合、クエリ オプティマイザーによって統計が更新されますが、この統計の更新はインデックスを再作成する過程で実行されるものです。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-278">The query optimizer updates statistics when you rebuild an index on a table or view with ALTER INDEX REBUILD or DBCC DBREINDEX, however; this statistics update is a byproduct of re-creating the index.</span></span> <span data-ttu-id="6d6b0-279">DBCC INDEXDEFRAG 操作または ALTER INDEX REORGANIZE 操作の後は、クエリ オプティマイザーで統計は更新されません。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-279">The query optimizer does not update statistics after DBCC INDEXDEFRAG or ALTER INDEX REORGANIZE operations.</span></span>  
  
##  <a name="queries-that-use-statistics-effectively"></a><a name="DesignStatistics"></a><span data-ttu-id="6d6b0-280">統計を効果的に使用するクエリ</span><span class="sxs-lookup"><span data-stu-id="6d6b0-280">Queries That Use Statistics Effectively</span></span>  
 <span data-ttu-id="6d6b0-281">クエリ述語にローカル変数や複雑な式が含まれている場合など、特定のクエリ実装では、最適なクエリ プランにならないことがあります。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-281">Certain query implementations, such as local variables and complex expressions in the query predicate, can lead to suboptimal query plans.</span></span> <span data-ttu-id="6d6b0-282">クエリのデザイン ガイドラインに従って統計を効果的に使用することで、この問題を回避できる場合があります。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-282">Following query design guidelines for using statistics effectively can help to avoid this.</span></span> <span data-ttu-id="6d6b0-283">クエリ述語の詳細については、「[検索条件 &#40;Transact-SQL&#41;](/sql/t-sql/queries/search-condition-transact-sql)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-283">For more information about query predicates, see [Search Condition &#40;Transact-SQL&#41;](/sql/t-sql/queries/search-condition-transact-sql).</span></span>  
  
 <span data-ttu-id="6d6b0-284">クエリのデザイン ガイドラインを適用して統計を効果的に使用することで、クエリ述語で使用される式、変数、および関数に対する *カーディナリティの推定* を向上させると、クエリ プランを向上させることができます。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-284">You can improve query plans by applying query design guidelines that use statistics effectively to improve *cardinality estimates* for expressions, variables, and functions used in query predicates.</span></span> <span data-ttu-id="6d6b0-285">クエリ オプティマイザーでは、式、変数、または関数の値が不明な場合、ヒストグラムで参照する値を特定できないため、ヒストグラムから最適なカーディナリティの推定を得ることができません。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-285">When the query optimizer does not know the value of an expression, variable, or function, it does not know which value to lookup in the histogram and therefore cannot retrieve the best cardinality estimate from the histogram.</span></span> <span data-ttu-id="6d6b0-286">その場合、クエリ オプティマイザーでは、ヒストグラム内のサンプリングされたすべての行の値ごとの平均行数に基づいてカーディナリティの推定を行います。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-286">Instead, the query optimizer bases the cardinality estimate on the average number of rows per distinct value for all of the sampled rows in the histogram.</span></span> <span data-ttu-id="6d6b0-287">その結果、カーディナリティが適切に推定されず、クエリのパフォーマンスが低下することがあります。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-287">This leads to suboptimal cardinality estimates and can hurt query performance.</span></span>  
  
 <span data-ttu-id="6d6b0-288">以下のガイドラインでは、カーディナリティの推定を向上させることによってクエリ プランを改善するためのクエリの作成方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-288">The following guidelines describe how to write queries to improve query plans by improving cardinality estimates.</span></span>  
  
### <a name="improving-cardinality-estimates-for-expressions"></a><span data-ttu-id="6d6b0-289">式に対するカーディナリティの推定を向上させる</span><span class="sxs-lookup"><span data-stu-id="6d6b0-289">Improving Cardinality Estimates for Expressions</span></span>  
 <span data-ttu-id="6d6b0-290">式に対するカーディナリティの推定を向上させるには、次のガイドラインに従います。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-290">To improve cardinality estimates for expressions, follow these guidelines:</span></span>  
  
-   <span data-ttu-id="6d6b0-291">定数を含む式は可能な限り単純にします。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-291">Whenever possible, simplify expressions with constants in them.</span></span> <span data-ttu-id="6d6b0-292">クエリ オプティマイザーでは、カーディナリティの推定を判断する前に、定数を含むすべての関数および式の評価は行われません。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-292">The query optimizer does not evaluate all functions and expressions containing constants prior to determining cardinality estimates.</span></span> <span data-ttu-id="6d6b0-293">たとえば、式 ABS(`-100) to 100`を簡略化します。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-293">For example, simplify the expression ABS(`-100) to 100`.</span></span>  
  
-   <span data-ttu-id="6d6b0-294">式で複数の変数を使用している場合は、式の計算列を作成し、その計算列に対する統計またはインデックスを作成することを検討します。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-294">If the expression uses multiple variables, consider creating a computed column for the expression and then create statistics or an index on the computed column.</span></span> <span data-ttu-id="6d6b0-295">たとえば、クエリ述語 `WHERE PRICE + Tax > 100` のカーディナリティの推定は、式 `Price + Tax` に対する計算列を作成すると向上する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-295">For example, the query predicate `WHERE PRICE + Tax > 100` might have a better cardinality estimate if you create a computed column for the expression `Price + Tax`.</span></span>  
  
### <a name="improving-cardinality-estimates-for-variables-and-functions"></a><span data-ttu-id="6d6b0-296">変数および関数に対するカーディナリティの推定を向上させる</span><span class="sxs-lookup"><span data-stu-id="6d6b0-296">Improving Cardinality Estimates for Variables and Functions</span></span>  
 <span data-ttu-id="6d6b0-297">変数および関数に対するカーディナリティの推定を向上させるには、次のガイドラインに従います。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-297">To improve the cardinality estimates for variables and functions, follow these guidelines:</span></span>  
  
-   <span data-ttu-id="6d6b0-298">クエリ述語でローカル変数を使用している場合は、ローカル変数の代わりにパラメーターを使用してクエリを書き換えることを検討します。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-298">If the query predicate uses a local variable, consider rewriting the query to use a parameter instead of a local variable.</span></span> <span data-ttu-id="6d6b0-299">ローカル変数の値は、クエリ オプティマイザーでのクエリ実行プランの作成時には認識されません。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-299">The value of a local variable is not known when the query optimizer creates the query execution plan.</span></span> <span data-ttu-id="6d6b0-300">クエリでパラメーターを使用すると、クエリ オプティマイザーで、ストアド プロシージャに渡される最初の実際のパラメーター値に対するカーディナリティの推定が使用されます。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-300">When a query uses a parameter, the query optimizer uses the cardinality estimate for the first actual parameter value that is passed to the stored procedure.</span></span>  
  
-   <span data-ttu-id="6d6b0-301">複数ステートメントのテーブル値関数の結果を格納する場合は、標準のテーブルか一時テーブルを使用することを検討します。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-301">Consider using a standard table or temporary table to hold the results of multi-statement table-valued functions.</span></span> <span data-ttu-id="6d6b0-302">クエリ オプティマイザーでは、複数ステートメントのテーブル値関数の統計は作成されません。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-302">The query optimizer does not create statistics for multi-statement table-valued functions.</span></span> <span data-ttu-id="6d6b0-303">この方法を使用すると、クエリ オプティマイザーでテーブル列の統計を作成できるため、それを使用することでクエリ プランを向上させることができます。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-303">With this approach the query optimizer can create statistics on the table columns and use them to create a better query plan.</span></span>  
  
-   <span data-ttu-id="6d6b0-304">テーブル変数の代わりに標準のテーブルか一時テーブルを使用することを検討します。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-304">Consider using a standard table or temporary table as a replacement for table variables.</span></span> <span data-ttu-id="6d6b0-305">クエリ オプティマイザーでは、テーブル変数の統計は作成されません。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-305">The query optimizer does not create statistics for table variables.</span></span> <span data-ttu-id="6d6b0-306">この方法を使用すると、クエリ オプティマイザーでテーブル列の統計を作成できるため、それを使用することでクエリ プランを向上させることができます。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-306">With this approach the query optimizer can create statistics on the table columns and use them to create a better query plan.</span></span> <span data-ttu-id="6d6b0-307">一時テーブルとテーブル変数のどちらを使用するかの判断には、トレードオフの関係があります。ストアド プロシージャでテーブル変数を使用すると、ストアド プロシージャの再コンパイルの回数が、一時テーブルを使用した場合よりも少なくなります。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-307">There are tradeoffs in determining whether to use a temporary table or a table variable; Table variables used in stored procedures cause fewer recompilations of the stored procedure than temporary tables.</span></span> <span data-ttu-id="6d6b0-308">アプリケーションによっては、テーブル変数の代わりに一時テーブルを使用しても、パフォーマンスが向上しない場合もあります。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-308">Depending on the application, using a temporary table instead of a table variable might not improve performance.</span></span>  
  
-   <span data-ttu-id="6d6b0-309">渡されたパラメーターを使用するクエリがストアド プロシージャに含まれている場合は、パラメーター値がクエリで使用される前にストアド プロシージャ内で変更されないようにします。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-309">If a stored procedure contains a query that uses a passed-in parameter, avoid changing the parameter value within the stored procedure before using it in the query.</span></span> <span data-ttu-id="6d6b0-310">クエリに対するカーディナリティの推定は、更新された値ではなく渡されたパラメーターの値に基づいて行われます。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-310">The cardinality estimates for the query are based on the passed-in parameter value and not the updated value.</span></span> <span data-ttu-id="6d6b0-311">パラメーター値が変更されないようにするには、2 つのストアド プロシージャを使用するようにクエリを書き換えます。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-311">To avoid changing the parameter value, you can rewrite the query to use two stored procedures.</span></span>  
  
     <span data-ttu-id="6d6b0-312">たとえば、次のストアド プロシージャ `Sales.GetRecentSales` では、パラメーター `@date` の場合に `@date is NULL`の値を変更します。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-312">For example, the following stored procedure `Sales.GetRecentSales` changes the value of the parameter `@date` when `@date is NULL`.</span></span>  
  
    ```  
    USE AdventureWorks2012;  
    GO  
    IF OBJECT_ID ( 'Sales.GetRecentSales', 'P') IS NOT NULL  
        DROP PROCEDURE Sales.GetRecentSales;  
    GO  
    CREATE PROCEDURE Sales.GetRecentSales (@date datetime)  
    AS BEGIN  
        IF @date is NULL  
            SET @date = DATEADD(MONTH, -3, (SELECT MAX(ORDERDATE) FROM Sales.SalesOrderHeader))  
        SELECT * FROM Sales.SalesOrderHeader h, Sales.SalesOrderDetail d  
        WHERE h.SalesOrderID = d.SalesOrderID  
        AND h.OrderDate > @date  
    END  
    GO  
    ```  
  
     <span data-ttu-id="6d6b0-313">ストアド プロシージャ `Sales.GetRecentSales` の最初の呼び出しで `@date` パラメーターに NULL が渡された場合、クエリ オプティマイザーでは、クエリ述語が `@date = NULL` で呼び出されていなくても、`@date = NULL` に対するカーディナリティの推定を使用してストアド プロシージャをコンパイルします。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-313">If the first call to the stored procedure `Sales.GetRecentSales` passes a NULL for the `@date` parameter, the query optimizer will compile the stored procedure with the cardinality estimate for `@date = NULL` even though the query predicate is not called with `@date = NULL`.</span></span> <span data-ttu-id="6d6b0-314">このカーディナリティの推定は、実際のクエリ結果の行数と大きく異なる場合があります。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-314">This cardinality estimate might be significantly different than the number of rows in the actual query result.</span></span> <span data-ttu-id="6d6b0-315">そのため、クエリ オプティマイザーにより、最適なクエリ プランが選択されないことがあります。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-315">As a result, the query optimizer might choose a suboptimal query plan.</span></span> <span data-ttu-id="6d6b0-316">この問題を回避するには、ストアド プロシージャを次のように 2 つのプロシージャに書き換えます。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-316">To help avoid this, you can rewrite the stored procedure into two procedures as follows:</span></span>  
  
    ```  
    USE AdventureWorks2012;  
    GO  
    IF OBJECT_ID ( 'Sales.GetNullRecentSales', 'P') IS NOT NULL  
        DROP PROCEDURE Sales.GetNullRecentSales;  
    GO  
    CREATE PROCEDURE Sales.GetNullRecentSales (@date datetime)  
    AS BEGIN  
        IF @date is NULL  
            SET @date = DATEADD(MONTH, -3, (SELECT MAX(ORDERDATE) FROM Sales.SalesOrderHeader))  
        EXEC Sales.GetNonNullRecentSales @date;  
    END  
    GO  
    IF OBJECT_ID ( 'Sales.GetNonNullRecentSales', 'P') IS NOT NULL  
        DROP PROCEDURE Sales.GetNonNullRecentSales;  
    GO  
    CREATE PROCEDURE Sales.GetNonNullRecentSales (@date datetime)  
    AS BEGIN  
        SELECT * FROM Sales.SalesOrderHeader h, Sales.SalesOrderDetail d  
        WHERE h.SalesOrderID = d.SalesOrderID  
        AND h.OrderDate > @date  
    END  
    GO  
    ```  
  
### <a name="improving-cardinality-estimates-with-query-hints"></a><span data-ttu-id="6d6b0-317">クエリ ヒントを使用してカーディナリティの推定を向上させる</span><span class="sxs-lookup"><span data-stu-id="6d6b0-317">Improving Cardinality Estimates with Query Hints</span></span>  
 <span data-ttu-id="6d6b0-318">ローカル変数に対するカーディナリティの推定を向上させるために、RECOMPILE を指定して OPTIMIZE FOR または OPTIMIZE FOR UNKNOWN クエリ ヒントを使用することができます。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-318">To improve cardinality estimates for local variables, you can use the OPTIMIZE FOR or OPTIMIZE FOR UNKNOWN query hints with RECOMPILE.</span></span> <span data-ttu-id="6d6b0-319">詳細については、「[クエリ ヒント &#40;Transact-SQL&#41;](/sql/t-sql/queries/hints-transact-sql-query)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-319">For more information, see [Query Hints &#40;Transact-SQL&#41;](/sql/t-sql/queries/hints-transact-sql-query).</span></span>  
  
 <span data-ttu-id="6d6b0-320">アプリケーションによっては、クエリを実行するたびに再コンパイルすると時間がかかりすぎる場合がありますが、</span><span class="sxs-lookup"><span data-stu-id="6d6b0-320">For some applications, recompiling the query each time it executes might take too much time.</span></span> <span data-ttu-id="6d6b0-321">OPTIMIZER FOR クエリ ヒントは RECOMPILE オプションを使用しなくても役立つことがあります。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-321">The OPTIMIZER FOR query hint can help even if you don't use the RECOMPILE option.</span></span> <span data-ttu-id="6d6b0-322">たとえば、ストアド プロシージャ Sales.GetRecentSales に OPTIMIZER FOR オプションを追加して、特定の日付を指定することができます。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-322">For example, you could add an OPTIMIZER FOR option to the stored procedure Sales.GetRecentSales to specify a specific date.</span></span> <span data-ttu-id="6d6b0-323">Sales.GetRecentSales プロシージャに OPTIMIZE FOR を追加した例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-323">The following example adds the OPTIMIZE FOR option to the Sales.GetRecentSales procedure.</span></span>  
  
```sql
USE AdventureWorks2012;  
GO  
IF OBJECT_ID ( 'Sales.GetRecentSales', 'P') IS NOT NULL  
    DROP PROCEDURE Sales.GetRecentSales;  
GO  
CREATE PROCEDURE Sales.GetRecentSales (@date datetime)  
AS BEGIN  
    IF @date is NULL  
        SET @date = DATEADD(MONTH, -3, (SELECT MAX(ORDERDATE) FROM Sales.SalesOrderHeader))  
    SELECT * FROM Sales.SalesOrderHeader h, Sales.SalesOrderDetail d  
    WHERE h.SalesOrderID = d.SalesOrderID  
    AND h.OrderDate > @date  
    OPTION ( OPTIMIZE FOR ( @date = '2004-05-01 00:00:00.000'))  
END;  
GO  
```  
  
### <a name="improving-cardinality-estimates-with-plan-guides"></a><span data-ttu-id="6d6b0-324">プラン ガイドを使用してカーディナリティの推定を向上させる</span><span class="sxs-lookup"><span data-stu-id="6d6b0-324">Improving Cardinality Estimates with Plan Guides</span></span>  
 <span data-ttu-id="6d6b0-325">アプリケーションによっては、クエリを変更できない場合や、RECOMPILE クエリ ヒントを使用すると再コンパイルが多くなりすぎる場合など、クエリのデザイン ガイドラインを適用できないことがあります。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-325">For some applications, query design guidelines might not apply because you cannot change the query or using the RECOMPILE query hint might be cause too many recompiles.</span></span> <span data-ttu-id="6d6b0-326">プラン ガイドを使用すると、アプリケーション ベンダーによるアプリケーションの違いを確認しながら、その他のヒント (USE PLAN など) を指定してクエリの動作を制御することができます。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-326">You can use plan guides to specify other hints, such as USE PLAN, to control the behavior of the query while investigating application changes with the application vendor.</span></span> <span data-ttu-id="6d6b0-327">プラン ガイドの詳細については、「 [Plan Guides](../performance/plan-guides.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="6d6b0-327">For more information about plan guides, see [Plan Guides](../performance/plan-guides.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="6d6b0-328">参照</span><span class="sxs-lookup"><span data-stu-id="6d6b0-328">See Also</span></span>  
 <span data-ttu-id="6d6b0-329">[CREATE STATISTICS &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-statistics-transact-sql) </span><span class="sxs-lookup"><span data-stu-id="6d6b0-329">[CREATE STATISTICS &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-statistics-transact-sql) </span></span>  
 <span data-ttu-id="6d6b0-330">[UPDATE STATISTICS &#40;Transact-SQL&#41;](/sql/t-sql/statements/update-statistics-transact-sql) </span><span class="sxs-lookup"><span data-stu-id="6d6b0-330">[UPDATE STATISTICS &#40;Transact-SQL&#41;](/sql/t-sql/statements/update-statistics-transact-sql) </span></span>  
 <span data-ttu-id="6d6b0-331">[sp_updatestats &#40;Transact-SQL&#41;](/sql/relational-databases/system-stored-procedures/sp-updatestats-transact-sql) </span><span class="sxs-lookup"><span data-stu-id="6d6b0-331">[sp_updatestats &#40;Transact-SQL&#41;](/sql/relational-databases/system-stored-procedures/sp-updatestats-transact-sql) </span></span>  
 <span data-ttu-id="6d6b0-332">[DBCC SHOW_STATISTICS &#40;Transact-SQL&#41;](/sql/t-sql/database-console-commands/dbcc-show-statistics-transact-sql) </span><span class="sxs-lookup"><span data-stu-id="6d6b0-332">[DBCC SHOW_STATISTICS &#40;Transact-SQL&#41;](/sql/t-sql/database-console-commands/dbcc-show-statistics-transact-sql) </span></span>  
 <span data-ttu-id="6d6b0-333">[ALTER DATABASE SET オプション &#40;Transact-SQL&#41;](/sql/t-sql/statements/alter-database-transact-sql-set-options) </span><span class="sxs-lookup"><span data-stu-id="6d6b0-333">[ALTER DATABASE SET Options &#40;Transact-SQL&#41;](/sql/t-sql/statements/alter-database-transact-sql-set-options) </span></span>  
 <span data-ttu-id="6d6b0-334">[DROP STATISTICS &#40;Transact-SQL&#41;](/sql/t-sql/statements/drop-statistics-transact-sql) </span><span class="sxs-lookup"><span data-stu-id="6d6b0-334">[DROP STATISTICS &#40;Transact-SQL&#41;](/sql/t-sql/statements/drop-statistics-transact-sql) </span></span>  
 <span data-ttu-id="6d6b0-335">[CREATE INDEX &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-index-transact-sql) </span><span class="sxs-lookup"><span data-stu-id="6d6b0-335">[CREATE INDEX &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-index-transact-sql) </span></span>  
 <span data-ttu-id="6d6b0-336">[ALTER INDEX &#40;Transact-SQL&#41;](/sql/t-sql/statements/alter-index-transact-sql) </span><span class="sxs-lookup"><span data-stu-id="6d6b0-336">[ALTER INDEX &#40;Transact-SQL&#41;](/sql/t-sql/statements/alter-index-transact-sql) </span></span>  
 [<span data-ttu-id="6d6b0-337">フィルター選択されたインデックスの作成</span><span class="sxs-lookup"><span data-stu-id="6d6b0-337">Create Filtered Indexes</span></span>](../indexes/create-filtered-indexes.md)  
