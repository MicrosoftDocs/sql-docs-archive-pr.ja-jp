---
title: ODBC テーブル値パラメーターの使用 |Microsoft Docs
ms.custom: ''
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: native-client
ms.topic: reference
helpviewer_keywords:
- table-valued parameters (ODBC), scenarios
- ODBC, table-valued parameters
ms.assetid: f1b73932-4570-4a8a-baa0-0f229d9c32ee
author: rothja
ms.author: jroth
ms.openlocfilehash: 2b128246f7c4ed9a9cec5e28698c743877f9873d
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/04/2020
ms.locfileid: "87740886"
---
# <a name="uses-of-odbc-table-valued-parameters"></a><span data-ttu-id="2a2b1-102">ODBC テーブル値パラメーターの使用</span><span class="sxs-lookup"><span data-stu-id="2a2b1-102">Uses of ODBC Table-Valued Parameters</span></span>
  <span data-ttu-id="2a2b1-103">このトピックでは、ODBC でテーブル値パラメーターを使用する主なユーザー シナリオについて説明します。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-103">This topic discusses the primary user scenarios for using table-valued parameters with ODBC:</span></span>  
  
-   <span data-ttu-id="2a2b1-104">複数行のバッファーに完全にバインドされるテーブル値パラメーター (すべての値をメモリ内に保持した TVP としてデータを送信する)</span><span class="sxs-lookup"><span data-stu-id="2a2b1-104">Table-Valued Parameter with Fully Bound Multirow Buffers (Send Data as a TVP with All Values in Memory)</span></span>  
  
-   <span data-ttu-id="2a2b1-105">行のストリーミングを使用するテーブル値パラメーター (実行時のデータを使用する TVP としてデータを送信する)</span><span class="sxs-lookup"><span data-stu-id="2a2b1-105">Table-Valued Parameter with Row Streaming (Send Data as a TVP Using Data-At-Execution)</span></span>  
  
-   <span data-ttu-id="2a2b1-106">システム カタログからテーブル値パラメーターのメタデータを取得</span><span class="sxs-lookup"><span data-stu-id="2a2b1-106">Retrieving Table-Valued Parameter Metadata from the System Catalog</span></span>  
  
-   <span data-ttu-id="2a2b1-107">準備されたステートメント用にテーブル値パラメーターのメタデータを取得</span><span class="sxs-lookup"><span data-stu-id="2a2b1-107">Retrieving Table-Valued Parameter Metadata for a Prepared Statement</span></span>  
  
## <a name="table-valued-parameter-with-fully-bound-multirow-buffers-send-data-as-a-tvp-with-all-values-in-memory"></a><span data-ttu-id="2a2b1-108">複数行のバッファーに完全にバインドされるテーブル値パラメーター (すべての値をメモリ内に保持した TVP としてデータを送信する)</span><span class="sxs-lookup"><span data-stu-id="2a2b1-108">Table-Valued Parameter with Fully Bound Multirow Buffers (Send Data as a TVP with All Values in Memory)</span></span>  
 <span data-ttu-id="2a2b1-109">複数行のバッファーに完全にバインドされる形式で使用する場合、すべてのパラメーター値はメモリ内から使用できます。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-109">When used with fully bound multirow buffers, all parameter values are available in memory.</span></span> <span data-ttu-id="2a2b1-110">このような形式は OLTP トランザクションなどでは一般的に行われ、テーブル値パラメーターを 1 つのストアド プロシージャにパッケージ化できます。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-110">This is typical, for example, of an OLTP transaction, in which table-valued parameters can be packaged into a single stored procedure.</span></span> <span data-ttu-id="2a2b1-111">テーブル値パラメーターを使用しないと、複雑な複数のステートメントで構成されるバッチを動的に生成し、サーバーを複数回呼び出すことになります。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-111">Without table-valued parameters, this would involve either generating a complex multi-statement batch dynamically, or making multiple calls to the server.</span></span>  
  
 <span data-ttu-id="2a2b1-112">テーブル値パラメーター自体は、他のパラメーターと共に[SQLBindParameter](https://go.microsoft.com/fwlink/?LinkId=59328)を使用してバインドされます。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-112">The table-valued parameter itself is bound by using [SQLBindParameter](https://go.microsoft.com/fwlink/?LinkId=59328) along with the other parameters.</span></span> <span data-ttu-id="2a2b1-113">すべてのパラメーターがバインドされると、アプリケーションは各テーブル値パラメーターにパラメーターフォーカス属性 SQL_SOPT_SS_PARAM_FOCUS を設定し、テーブル値パラメーターの列に対して SQLBindParameter を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-113">After all parameters have been bound, the application sets the parameter focus attribute, SQL_SOPT_SS_PARAM_FOCUS, on each table-valued parameter and calls SQLBindParameter for the columns of the table-valued parameter.</span></span>  
  
 <span data-ttu-id="2a2b1-114">テーブル値パラメーターのサーバー型は、[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 固有の新しい型 SQL_SS_TABLE です。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-114">The server type for a table-valued parameter is a new [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]-specific type, SQL_SS_TABLE.</span></span> <span data-ttu-id="2a2b1-115">SQL_SS_TABLE の C データ型へのバインドは、常に SQL_C_DEFAULT にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-115">The binding C type for SQL_SS_TABLE must always be SQL_C_DEFAULT.</span></span> <span data-ttu-id="2a2b1-116">テーブル値パラメーターにバインドされたパラメーターについては、データが転送されません。このパラメーターは、テーブルのメタデータを渡し、テーブル値パラメーターを構成する列にデータを渡す方法を制御するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-116">No data is transferred for the table-valued parameter bound parameter; it is used to pass table metadata and to control how to pass data in the constituent columns of the table-valued parameter.</span></span>  
  
 <span data-ttu-id="2a2b1-117">テーブル値パラメーターの長さには、サーバーに送信される行数が設定されます。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-117">The length of the table-valued parameter is set to the number of rows being sent to the server.</span></span> <span data-ttu-id="2a2b1-118">テーブル値パラメーターの SQLBindParameter の*Columnsize*パラメーターは、送信できる最大行数を指定します。これは、列バッファーの配列サイズです。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-118">The *ColumnSize* parameter of SQLBindParameter for a table-valued parameter specifies the maximum number of rows that can be sent; this is the array size of the column buffers.</span></span> <span data-ttu-id="2a2b1-119">*Parametervalueptr*は、SQLBindParameter 内のテーブル値パラメーターのパラメーターバッファーです。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-119">*ParameterValuePtr* is the parameter buffer,for a table-valued parameter in SQLBindParameter.</span></span> <span data-ttu-id="2a2b1-120">*Parametervalueptr*とそれに関連付けられている*bufferlength*は、必要に応じてテーブル値パラメーターの型名を渡すために使用されます。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-120">*ParameterValuePtr* and its associated *BufferLength* are used to pass the type name of the table-valued parameter when required.</span></span> <span data-ttu-id="2a2b1-121">型名は、ストアド プロシージャの呼び出しには必要ありませんが、SQL ステートメントには必要です。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-121">The type name is not required for stored procedure calls, but it is required for SQL statements.</span></span>  
  
 <span data-ttu-id="2a2b1-122">SQLBindParameter の呼び出しでテーブル値パラメーターの型名を指定する場合は、ANSI アプリケーションとしてビルドされたアプリケーションであっても、常に Unicode 値として指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-122">When a table-valued parameter type name is specified on a call to SQLBindParameter, it must always be specified as a Unicode value, even in applications that are built as ANSI applications.</span></span> <span data-ttu-id="2a2b1-123">SQLSetDescField を使用してテーブル値パラメーターの型名を指定する場合、アプリケーションのビルド方法に準拠したリテラルを使用できます。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-123">When you specify a table-valued parameter type name by using SQLSetDescField, you can use a literal that conforms to the way the application is built.</span></span> <span data-ttu-id="2a2b1-124">ODBC ドライバー マネージャーで、必要な Unicode 変換を実行します。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-124">The ODBC Driver Manager will perform any required Unicode conversion.</span></span>  
  
 <span data-ttu-id="2a2b1-125">テーブル値パラメーターおよびテーブル値パラメーターの列のメタデータは、SQLGetDescRec、SQLSetDescRec、SQLGetDescField、および SQLSetDescField を使用して、個別に、または明示的に操作できます。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-125">Metadata for table-valued parameters and table-valued parameter columns can be manipulated individually and explicitly by using SQLGetDescRec, SQLSetDescRec, SQLGetDescField, and SQLSetDescField.</span></span> <span data-ttu-id="2a2b1-126">ただし、SQLBindParameter のオーバーロードは通常、より便利であり、ほとんどの場合、明示的な記述子アクセスは必要ありません。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-126">However, overloading SQLBindParameter is usually more convenient and does not require explicit descriptor access in most cases.</span></span> <span data-ttu-id="2a2b1-127">この方法は、他のデータ型の SQLBindParameter の定義と一致します。ただし、テーブル値パラメーターの場合は、影響を受ける記述子フィールドが若干異なります。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-127">This approach is consistent with the definition of SQLBindParameter for other data types, except that for a table-valued parameter the affected descriptor fields are slightly different.</span></span>  
  
 <span data-ttu-id="2a2b1-128">アプリケーションでは、場合によっては、動的な SQL を含むテーブル値パラメーターを使用して、テーブル値パラメーターの型名を指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-128">Sometimes, an application uses a table-valued parameter with dynamic SQL and the type name of the table-valued parameter must be supplied.</span></span> <span data-ttu-id="2a2b1-129">この場合、テーブル値パラメーターが接続の現在の既定のスキーマで定義されていない場合は、SQL_CA_SS_TYPE_CATALOG_NAME と SQL_CA_SS_TYPE_SCHEMA_NAME を SQLSetDescField を使用して設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-129">If this is the case and the table-valued parameter is not defined in the current default schema for the connection, SQL_CA_SS_TYPE_CATALOG_NAME and SQL_CA_SS_TYPE_SCHEMA_NAME must be set by using SQLSetDescField.</span></span> <span data-ttu-id="2a2b1-130">テーブル型の定義とテーブル値パラメーターは同じデータベースに存在する必要があるため、アプリケーションでテーブル値パラメーターを使用する場合は、SQL_CA_SS_TYPE_CATALOG_NAME を設定しないでください。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-130">Because table type definitions and table-valued parameters must be in the same database, SQL_CA_SS_TYPE_CATALOG_NAME must not be set if the application uses table-valued parameters.</span></span> <span data-ttu-id="2a2b1-131">それ以外の場合、SQLSetDescField はエラーを報告します。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-131">Otherwise, SQLSetDescField will report an error.</span></span>  
  
 <span data-ttu-id="2a2b1-132">このシナリオのサンプルコードは、「 `demo_fixed_TVP_binding` [テーブル値パラメーター &#40;ODBC&#41;に使用する](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md)」の手順に記載されています。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-132">Sample code for this scenario is in the procedure `demo_fixed_TVP_binding` in [Use Table-Valued Parameters &#40;ODBC&#41;](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md).</span></span>  
  
## <a name="table-valued-parameter-with-row-streaming-send-data-as-a-tvp-using-data-at-execution"></a><span data-ttu-id="2a2b1-133">行のストリーミングを使用するテーブル値パラメーター (実行時のデータを使用する TVP としてデータを送信する)</span><span class="sxs-lookup"><span data-stu-id="2a2b1-133">Table-Valued Parameter with Row Streaming (Send Data as a TVP Using Data-At-Execution)</span></span>  
 <span data-ttu-id="2a2b1-134">このシナリオでは、要求に応じてアプリケーションからドライバーに行が渡され、サーバーにストリーム送信されます。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-134">In this scenario, the application supplies rows to the driver as it requests them and they are streamed to the server.</span></span> <span data-ttu-id="2a2b1-135">これにより、すべての行をメモリ内にバッファリングする必要がなくなります。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-135">This avoids having to buffer all rows in memory.</span></span> <span data-ttu-id="2a2b1-136">これは、一括挿入や一括更新のシナリオの代表的な例です。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-136">This is representative of bulk insert/update scenarios.</span></span> <span data-ttu-id="2a2b1-137">テーブル値パラメーターは、パフォーマンスの点ではパラメーター配列と一括コピーとの間に位置します。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-137">Table-valued parameters provide a performance point somewhere between parameter arrays and bulk copy.</span></span> <span data-ttu-id="2a2b1-138">つまり、テーブル値パラメーターは、パラメーター配列と同程度にプログラミングが容易ですが、サーバー側の柔軟性が増します。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-138">That is, table-valued parameters are about as easy to program as parameter arrays, but they provide greater flexibility at the server.</span></span>  
  
 <span data-ttu-id="2a2b1-139">テーブル値パラメーターとその列は、前の「複数行のバッファーに完全にバインドされるテーブル値パラメーター」で説明したとおりにバインドされますが、テーブル値パラメーター自体の長さのインジケーターは、SQL_DATA_AT_EXEC に設定されます。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-139">The table-valued parameter and its columns are bound as discussed in the previous section, Table-Valued Parameter with Fully Bound Multirow Buffers, but the length indicator of the table-valued parameter itself is set to SQL_DATA_AT_EXEC.</span></span> <span data-ttu-id="2a2b1-140">ドライバーは、実行時データパラメーターの通常の方法で SQLExecute または SQLExecuteDirect に応答します。つまり、SQL_NEED_DATA を返します。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-140">The driver responds to SQLExecute or SQLExecuteDirect in the usual way for data-at-execution parameters-that is, by returning SQL_NEED_DATA.</span></span> <span data-ttu-id="2a2b1-141">ドライバーがテーブル値パラメーターのデータを受け入れる準備が整うと、SQLParamData は SQLBindParameter の*Parametervalueptr*の値を返します。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-141">When the driver is ready to accept data for a table-valued parameter, SQLParamData returns the value of *ParameterValuePtr* in SQLBindParameter.</span></span>  
  
 <span data-ttu-id="2a2b1-142">アプリケーションでは、テーブル値パラメーターとして SQLPutData を使用して、テーブル値パラメーターの構成列のデータを使用できるかどうかを示します。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-142">An application uses SQLPutData for a table-valued parameter to indicate the availability of data for table-valued parameter constituent columns.</span></span> <span data-ttu-id="2a2b1-143">SQLPutData がテーブル値パラメーターに対して呼び出される場合、 *DataPtr*は常に null である必要があります。また、 *StrLen_or_Ind*は、テーブル値パラメーターのバッファーに指定された配列のサイズ (SQLBindParameter の*columnsize*パラメーター) 以下である必要があります。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-143">When SQLPutData is called for a table-valued parameter, *DataPtr* must always be null and *StrLen_or_Ind* must be either 0 or a number less than or equal to the array size specified for table-valued parameter buffers (the *ColumnSize* parameter of SQLBindParameter).</span></span> <span data-ttu-id="2a2b1-144">0 はテーブル値パラメーターの行がなくなったことを示すため、ドライバーはプロシージャの次の実パラメーターの処理に進みます。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-144">0 signifies that there are no more rows for the table-valued parameter, and the driver will proceed to process to the next actual procedure parameter.</span></span> <span data-ttu-id="2a2b1-145">*StrLen_or_Ind*が0でない場合、ドライバーはテーブル値パラメーターではないパラメーターと同じ方法でテーブル値パラメーターを構成する列を処理します。各テーブル値パラメーターの列は、実際のデータ長、SQL_NULL_DATA を指定することも、長さ/インジケーターバッファーを使用して実行時にデータを指定することもできます。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-145">When *StrLen_or_Ind* is not 0, the driver will process the table-valued parameter constituent columns in the same way as non-table-valued parameter bound parameters: Each table-valued parameter column can specify its actual data length, SQL_NULL_DATA, or it can specify data at execution via its length/indicator buffer.</span></span> <span data-ttu-id="2a2b1-146">文字またはバイナリ値を部分的に渡すときに、通常どおり SQLPutData を繰り返し呼び出すことで、テーブル値パラメーターの列の値を渡すことができます。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-146">Table-valued parameter column values can be passed by repeated calls to SQLPutData as usual when a character or binary value is to be passed in pieces.</span></span>  
  
 <span data-ttu-id="2a2b1-147">テーブル値パラメーターのすべての列が処理されたら、ドライバーはテーブル値パラメーターに戻り、テーブル値パラメーターのデータの次の行を処理します。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-147">When all table-valued parameter columns have been processed, the driver returns to the table-valued parameter to process further rows of table-valued parameter data.</span></span> <span data-ttu-id="2a2b1-148">したがって、実行時データのテーブル値パラメーターの場合、バインドされたパラメーターを順番にスキャンする通常の方法には従いません。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-148">Therefore, for data-at-execution table-valued parameters, the driver does not follow the usual sequential scan of bound parameters.</span></span> <span data-ttu-id="2a2b1-149">バインドされたテーブル値パラメーターは、SQLPutData が0に等しい*StrLen_Or_IndPtr*呼び出されるまでポーリングされます。このとき、ドライバーはテーブル値パラメーターの列をスキップし、次の実際のストアドプロシージャパラメーターに移動します。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-149">A bound table-valued parameter will be polled until SQLPutData is called with *StrLen_Or_IndPtr* equal to 0, at which time the driver skips table-valued parameter columns and moves to the next actual stored procedure parameter.</span></span>  <span data-ttu-id="2a2b1-150">SQLPutData が1以上のインジケーター値を渡すと、ドライバーは、バインドされたすべての行と列の値を持つまで、テーブル値パラメーターの列と行を順番に処理します。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-150">When SQLPutData passes an indicator value greater than or equal to 1, the driver processes table-valued parameter columns and rows sequentially until it has values for all bound rows and columns.</span></span> <span data-ttu-id="2a2b1-151">その後、ドライバーはテーブル値パラメーターに戻ります。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-151">Then the driver returns to the table-valued parameter.</span></span> <span data-ttu-id="2a2b1-152">テーブル値パラメーターのテーブル値パラメーターのトークンを受信してから、テーブル値パラメーターの Sqlparamdata (hstmt, NULL, n) を呼び出す場合、アプリケーションでは、サーバーに渡される次の行に対して、テーブル値パラメーターの構成列データとインジケーターバッファーの内容を設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-152">Between receiving the token for the table-valued parameter from SQLParamData and calling SQLPutData(hstmt, NULL, n) for a table-valued parameter, the application must set table-valued parameter constituent column data and indicator buffer contents for the next row or rows to be passed to the server.</span></span>  
  
 <span data-ttu-id="2a2b1-153">このシナリオのサンプルコードは、「 `demo_variable_TVP_binding` [テーブル値パラメーター &#40;ODBC&#41;に使用する](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md)」のルーチンに含まれています。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-153">Sample code for this scenario is in the routine `demo_variable_TVP_binding` in [Use Table-Valued Parameters &#40;ODBC&#41;](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md).</span></span>  
  
## <a name="retrieving-table-valued-parameter-metadata-from-the-system-catalog"></a><span data-ttu-id="2a2b1-154">システム カタログからテーブル値パラメーターのメタデータを取得</span><span class="sxs-lookup"><span data-stu-id="2a2b1-154">Retrieving Table-Valued Parameter Metadata from the System Catalog</span></span>  
 <span data-ttu-id="2a2b1-155">アプリケーションが SQLProcedureColumns を呼び出して、テーブル値パラメーターのパラメーターを持つプロシージャを呼び出すと、DATA_TYPE が SQL_SS_TABLE として返され、TYPE_NAME はテーブル値パラメーターのテーブル型の名前になります。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-155">When an application calls SQLProcedureColumns for a procedure that has table-valued parameter parameters, DATA_TYPE is returned as SQL_SS_TABLE and TYPE_NAME is the name of the table type for the table-valued parameter.</span></span> <span data-ttu-id="2a2b1-156">SQLProcedureColumns によって返される結果セットには、次の2つの列が追加されます。 SS_TYPE_CATALOG_NAME は、テーブル値パラメーターのテーブル型が定義されているカタログの名前を返し、SS_TYPE_SCHEMA_NAME はテーブル値パラメーターのテーブル型が定義されているスキーマの名前を返します。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-156">Two additional columns are added to the result set returned by SQLProcedureColumns: SS_TYPE_CATALOG_NAME returns the name of the catalog where the table type of the table-value parameter is defined, and SS_TYPE_SCHEMA_NAME returns the name of the schema where the where the table type of the table-value parameter is defined.</span></span> <span data-ttu-id="2a2b1-157">ODBC 仕様に準拠して、SS_TYPE_CATALOG_NAME と SS_TYPE_SCHEMA_NAME は、以前のバージョンので追加されたすべてのドライバー固有の列の前 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] と、odbc 自体によって指定されたすべての列の前に表示されます。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-157">In conformance with the ODBC specification, SS_TYPE_CATALOG_NAME and SS_TYPE_SCHEMA_NAME appear before all driver specific columns that were added in previous versions of [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], and after all columns mandated by ODBC itself.</span></span>  
  
 <span data-ttu-id="2a2b1-158">新しい列は、テーブル値パラメーター用だけでなく、CLR ユーザー定義型パラメーター用にも作成されます。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-158">The new columns will be populated not only for table-valued parameters, but also for CLR user-defined type parameters.</span></span> <span data-ttu-id="2a2b1-159">UDT パラメーターの既存のスキーマ列とカタログ列も依然として作成されますが、共通のスキーマ列とカタログ列を必要とするデータ型にもそれらの列を含めておくと、今後アプリケーション開発が簡単になります </span><span class="sxs-lookup"><span data-stu-id="2a2b1-159">The existing schema and catalog columns of UDT parameters will still be populated, but having common schema and catalog columns for data types that require them will simplify application development in the future.</span></span> <span data-ttu-id="2a2b1-160">(XML スキーマ コレクションは多少異なり、この変更には含まれていないことに注意してください)。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-160">(Note that XML schema collections are somewhat different and are not included in this change.)</span></span>  
  
 <span data-ttu-id="2a2b1-161">アプリケーションでは、永続的なテーブル、システムテーブル、およびビューと同じように、SQLTables を使用してテーブル型の名前を決定します。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-161">An application uses SQLTables to determine the names of table types the same way it does for persistent tables, system tables, and views.</span></span> <span data-ttu-id="2a2b1-162">アプリケーションでテーブル値パラメーターに関連付けられたテーブル型を識別できるように、新しいテーブル型として TABLE TYPE が導入されました。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-162">A new table type, TABLE TYPE, is introduced to enable an application to identify table types associated with table-valued parameters.</span></span> <span data-ttu-id="2a2b1-163">テーブル型と通常のテーブルでは、異なる名前空間を使用します。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-163">Table types and regular tables use different namespaces.</span></span> <span data-ttu-id="2a2b1-164">つまり、テーブル型と実際のテーブルに、同じ名前を使用できます。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-164">This means that you can use the same name for both a table type and an actual table.</span></span> <span data-ttu-id="2a2b1-165">これに対処するために、新しいステートメント属性として SQL_SOPT_SS_NAME_SCOPE が導入されました。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-165">To handle this, a new statement attribute, SQL_SOPT_SS_NAME_SCOPE, has been introduced.</span></span> <span data-ttu-id="2a2b1-166">この属性は、テーブル名をパラメーターとして受け取る SQLTables およびその他のカタログ関数が、テーブル名を実際のテーブルの名前またはテーブル型の名前として解釈するかどうかを指定します。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-166">This attribute specifies whether SQLTables and other catalog functions that take a table name as a parameter should interpret the table name as the name of an actual table or the name of a table type.</span></span>  
  
 <span data-ttu-id="2a2b1-167">アプリケーションでは、SQLColumns を使用して、永続テーブルの場合と同じ方法でテーブル型の列を決定しますが、最初に SQL_SOPT_SS_NAME_SCOPE を設定して、実際のテーブルではなくテーブル型を操作していることを示す必要があります。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-167">An application uses SQLColumns to determine the columns for a table type in the same way it does for persistent tables, but must first set SQL_SOPT_SS_NAME_SCOPE to indicate that it is working with table types rather than actual tables.</span></span> <span data-ttu-id="2a2b1-168">SQLPrimaryKeys はテーブル型でも使用できますが、SQL_SOPT_SS_NAME_SCOPE を使用します。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-168">SQLPrimaryKeys can also be used with table types, again using SQL_SOPT_SS_NAME_SCOPE.</span></span>  
  
 <span data-ttu-id="2a2b1-169">このシナリオのサンプルコードは、「 `demo_metadata_from_catalog_APIs` [テーブル値パラメーター &#40;ODBC&#41;に使用する](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md)」のルーチンに含まれています。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-169">Sample code for this scenario is in the routine `demo_metadata_from_catalog_APIs` in [Use Table-Valued Parameters &#40;ODBC&#41;](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md).</span></span>  
  
## <a name="retrieving-table-valued-parameter-metadata-for-a-prepared-statement"></a><span data-ttu-id="2a2b1-170">準備されたステートメント用にテーブル値パラメーターのメタデータを取得</span><span class="sxs-lookup"><span data-stu-id="2a2b1-170">Retrieving Table-Valued Parameter Metadata for a Prepared Statement</span></span>  
 <span data-ttu-id="2a2b1-171">このシナリオでは、アプリケーションは SQLNumParameters と SQLDescribeParam を使用して、テーブル値パラメーターのメタデータを取得します。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-171">In this scenario, an application uses SQLNumParameters and SQLDescribeParam to retrieve metadata for table-valued parameters.</span></span>  
  
 <span data-ttu-id="2a2b1-172">IPD フィールド SQL_CA_SS_TYPE_NAME は、テーブル値パラメーターの型名を取得するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-172">The IPD field SQL_CA_SS_TYPE_NAME is used to retrieve the type name for the table-valued parameter.</span></span> <span data-ttu-id="2a2b1-173">IPD フィールド SQL_CA_SS_TYPE_SCHEMA_NAME と SQL_CA_SS_TYPE_CATALOG_NAME は、それぞれスキーマとカタログを取得するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-173">The IPD fields SQL_CA_SS_TYPE_SCHEMA_NAME and SQL_CA_SS_TYPE_CATALOG_NAME are used to retrieve its catalog and schema, respectively.</span></span>  
  
 <span data-ttu-id="2a2b1-174">テーブル型の定義とテーブル値パラメーターは同じデータベースに存在する必要があります。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-174">Table type definitions and table-valued parameters must be in the same database.</span></span> <span data-ttu-id="2a2b1-175">SQLSetDescField は、テーブル値パラメーターの使用時にアプリケーションが SQL_CA_SS_TYPE_CATALOG_NAME を設定した場合にエラーを報告します。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-175">SQLSetDescField will report an error if an application sets SQL_CA_SS_TYPE_CATALOG_NAME when using table-valued parameters.</span></span>  
  
 <span data-ttu-id="2a2b1-176">SQL_CA_SS_TYPE_CATALOG_NAME および SQL_CA_SS_TYPE_SCHEMA_NAME を使用すると、CLR ユーザー定義型パラメーターに関連付けられたカタログとスキーマも取得できます。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-176">SQL_CA_SS_TYPE_CATALOG_NAME and SQL_CA_SS_TYPE_SCHEMA_NAME can also be used to retrieve the catalog and schema associated with CLR user-defined type parameters.</span></span> <span data-ttu-id="2a2b1-177">SQL_CA_SS_TYPE_CATALOG_NAME および SQL_CA_SS_TYPE_SCHEMA_NAME は、CLR UDT 型の既存の型固有のカタログ スキーマの属性の代わりに使用します。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-177">SQL_CA_SS_TYPE_CATALOG_NAME and SQL_CA_SS_TYPE_SCHEMA_NAME are alternatives to the existing type specific catalog schema attributes for CLR UDT types.</span></span>  
  
 <span data-ttu-id="2a2b1-178">このシナリオでは、SQLDescribeParam がテーブル値パラメーター列の列のメタデータを返さないため、アプリケーションは SQLColumns を使用してテーブル値パラメーターの列メタデータを取得します。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-178">An application uses SQLColumns to retrieve column metadata for a table-valued parameter in this scenario, too, because SQLDescribeParam does not return metadata for the columns of a table-valued parameter column.</span></span>  
  
 <span data-ttu-id="2a2b1-179">このユースケースのサンプルコードは、「 `demo_metadata_from_prepared_statement` [テーブル値パラメーター &#40;ODBC&#41;に使用する](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md)」のルーチンに含まれています。</span><span class="sxs-lookup"><span data-stu-id="2a2b1-179">Sample code for this use case is in the routine `demo_metadata_from_prepared_statement` in [Use Table-Valued Parameters &#40;ODBC&#41;](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="2a2b1-180">参照</span><span class="sxs-lookup"><span data-stu-id="2a2b1-180">See Also</span></span>  
 [<span data-ttu-id="2a2b1-181">テーブル値パラメーター &#40;ODBC&#41;</span><span class="sxs-lookup"><span data-stu-id="2a2b1-181">Table-Valued Parameters &#40;ODBC&#41;</span></span>](table-valued-parameters-odbc.md)  
  
  
