---
title: 結果データをフェッチしています |Microsoft Docs
ms.custom: ''
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: native-client
ms.topic: reference
helpviewer_keywords:
- SQLFetchScroll function
- SQL Server Native Client ODBC driver, result sets
- ODBC applications, result sets
- data types [ODBC], fetching
- SQLBindCol function
- result sets [ODBC], fetching
- fetching [ODBC]
- ODBC data types, fetching
- SQLFetch function
- SQL Server Native Client ODBC driver, data types
- SQLGetData function
ms.assetid: b289c7fb-5017-4d7e-a2d3-19401e9fc4cd
author: rothja
ms.author: jroth
ms.openlocfilehash: 7eb038d431dd7f733c36e5913d72cdc6a161acad
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/04/2020
ms.locfileid: "87741973"
---
# <a name="fetching-result-data"></a><span data-ttu-id="3a8ac-102">結果データのフェッチ</span><span class="sxs-lookup"><span data-stu-id="3a8ac-102">Fetching Result Data</span></span>
  <span data-ttu-id="3a8ac-103">ODBC アプリケーションでは、結果データのフェッチを 3 つの方法で実行できます。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-103">An ODBC application has three options for fetching result data.</span></span>  
  
 <span data-ttu-id="3a8ac-104">最初のオプションは、 [SQLBindCol](../native-client-odbc-api/sqlbindcol.md)に基づいています。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-104">The first option is based on [SQLBindCol](../native-client-odbc-api/sqlbindcol.md).</span></span> <span data-ttu-id="3a8ac-105">アプリケーションでは、結果セットをフェッチする前に**SQLBindCol**を使用して、結果セット内の各列をプログラム変数にバインドします。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-105">Before fetching the result set, the application uses **SQLBindCol** to bind each column in the result set to a program variable.</span></span> <span data-ttu-id="3a8ac-106">列がバインドされると、ドライバーは、アプリケーションが**sqlfetch**または[sqlfetchscroll](../native-client-odbc-api/sqlfetchscroll.md)を呼び出すたびに、結果セットの列にバインドされた変数に現在の行のデータを転送します。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-106">After the columns have been bound, the driver transfers the data of the current row into the variables bound to the result set columns each time the application calls **SQLFetch** or [SQLFetchScroll](../native-client-odbc-api/sqlfetchscroll.md).</span></span> <span data-ttu-id="3a8ac-107">結果セット列のデータ型とプログラム変数のデータ型が異なる場合、ドライバーによってデータ変換が処理されます。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-107">The driver handles data conversions if the result set column and program variable have different data types.</span></span> <span data-ttu-id="3a8ac-108">アプリケーションの設定 SQL_ATTR_ROW_ARRAY_SIZE が1より大きい場合は、結果列を変数の配列にバインドできます。これは、 **Sqlfetchscroll**を呼び出すたびにすべて入力されます。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-108">If the application has SQL_ATTR_ROW_ARRAY_SIZE set greater than 1, it can bind result columns to arrays of variables, which will all be filled on each call to **SQLFetchScroll**.</span></span>  
  
 <span data-ttu-id="3a8ac-109">2番目のオプションは、 [SQLGetData](../native-client-odbc-api/sqlgetdata.md)に基づいています。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-109">The second option is based on [SQLGetData](../native-client-odbc-api/sqlgetdata.md).</span></span> <span data-ttu-id="3a8ac-110">アプリケーションでは、結果セット列をプログラム変数にバインドするために**SQLBindCol**を使用しません。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-110">The application does not use **SQLBindCol** to bind result set columns to program variables.</span></span> <span data-ttu-id="3a8ac-111">**Sqlfetch**を呼び出すたびに、アプリケーションは、結果セットの各列に対して**SQLGetData**を1回呼び出します。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-111">After each call to **SQLFetch**, the application calls **SQLGetData** once for each column in the result set.</span></span> <span data-ttu-id="3a8ac-112">**SQLGetData**は、特定の結果セット列から特定のプログラム変数にデータを転送するようにドライバーに指示し、列と変数のデータ型を指定します。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-112">**SQLGetData** instructs the driver to transfer data from a specific result set column to a specific program variable and specifies the data types of the column and variable.</span></span> <span data-ttu-id="3a8ac-113">そのため、結果列のデータ型とプログラム変数のデータ型が異なる場合は、ドライバーでデータを変換できます。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-113">This allows the driver to convert data if the result column and program variable have different data types.</span></span> <span data-ttu-id="3a8ac-114">**Text**型、 **ntext**型、および**image**型の列は、通常は大きすぎてプログラム変数には収まりませんが、 **SQLGetData**を使用して取得することはできます。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-114">**Text**, **ntext**, and **image** columns are typically too large to fit into a program variable but can still be retrieved using **SQLGetData**.</span></span> <span data-ttu-id="3a8ac-115">結果列の**text**、 **ntext**、または**image**データがプログラム変数よりも大きい場合、 **SQLGetData**は SQL_SUCCESS_WITH_INFO と SQLSTATE 01004 (文字列データ、右側が切り捨てられます) を返します。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-115">If the **text**, **ntext**, or **image** data in the result column is larger than the program variable, **SQLGetData** returns SQL_SUCCESS_WITH_INFO and SQLSTATE 01004 (string data, right truncated).</span></span> <span data-ttu-id="3a8ac-116">**SQLGetData**を連続して呼び出すと、**テキスト**または**イメージ**データの連続するチャンクが返されます。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-116">Successive calls to **SQLGetData** return successive chunks of the **text** or **image** data.</span></span> <span data-ttu-id="3a8ac-117">データの末尾に到達すると、 **SQLGetData**は SQL_SUCCESS を返します。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-117">When the end of the data is reached, **SQLGetData** returns SQL_SUCCESS.</span></span> <span data-ttu-id="3a8ac-118">SQL_ATTR_ROW_ARRAY_SIZE に 1 よりも大きい値を指定すると、フェッチのたびに行セットが返されます。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-118">Each fetch returns a set of rows, or rowset, if SQL_ATTR_ROW_ARRAY_SIZE is greater than 1.</span></span> <span data-ttu-id="3a8ac-119">**SQLGetData**を使用する前に、まず**SQLSetPos**を使用して、行セット内の特定の行を現在の行として指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-119">Before using **SQLGetData**, you must first use **SQLSetPos** to specify a specific row within the rowset as the current row.</span></span>  
  
 <span data-ttu-id="3a8ac-120">3番目のオプションは、 **SQLBindCol**と**SQLGetData**を組み合わせて使用する方法です。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-120">The third option is to use a mix of **SQLBindCol** and **SQLGetData**.</span></span> <span data-ttu-id="3a8ac-121">たとえば、アプリケーションでは、結果セットの最初の10列をバインドしてから、各フェッチで**SQLGetData**を3回呼び出して、バインドされていない3つの列からデータを取得することができます。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-121">An application could, for example, bind the first ten columns of a result set and then, on each fetch, call **SQLGetData** three times to retrieve the data from three unbound columns.</span></span> <span data-ttu-id="3a8ac-122">これは通常、結果セットに1つ以上の**text**列または**image**列が含まれている場合に使用されます。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-122">This would typically be used when a result set contains one or more **text** or **image** columns.</span></span>  
  
 <span data-ttu-id="3a8ac-123">結果セットに設定されているカーソルオプションによっては、アプリケーションは**Sqlfetchscroll**のスクロールオプションを使用して、結果セットをスクロールすることもできます。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-123">Depending on the cursor options set for the result set, an application can also use the scrolling options of **SQLFetchScroll** to scroll around the result set.</span></span>  
  
 <span data-ttu-id="3a8ac-124">**SQLBindCol**を使用して結果セット列をプログラム変数にバインドすると、 **SQLBindCol**によって ODBC ドライバーによってメモリが割り当てられるため、コストが高くなります。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-124">Excess use of **SQLBindCol** to bind a result set column to a program variable is expensive because **SQLBindCol** causes an ODBC driver to allocate memory.</span></span> <span data-ttu-id="3a8ac-125">結果列を変数にバインドすると、 [Sqlfreehandle](../native-client-odbc-api/sqlfreehandle.md)を呼び出してステートメントハンドルを解放するか、 *foption*を SQL_UNBIND に設定して[SQLFreeStmt](../native-client-odbc-api/sqlfreestmt.md)を呼び出すまで、そのバインドは有効のままになります。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-125">When you bind a result column to a variable, that binding remains in effect until you either call [SQLFreeHandle](../native-client-odbc-api/sqlfreehandle.md) to free the statement handle or call [SQLFreeStmt](../native-client-odbc-api/sqlfreestmt.md) with *fOption* set to SQL_UNBIND.</span></span> <span data-ttu-id="3a8ac-126">バインドは、ステートメントが完了しても自動的には元に戻りません。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-126">The bindings are not automatically undone when the statement completes.</span></span>  
  
 <span data-ttu-id="3a8ac-127">このロジックにより、異なるパラメーターを指定して同じ SELECT ステートメントを何度も実行することで、効率を上げることができます。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-127">This logic allows you to effectively deal with executing the same SELECT statement several times with different parameters.</span></span> <span data-ttu-id="3a8ac-128">結果セットは同じ構造を保持するので、結果セットを1回バインドし、すべての SELECT ステートメントを処理し、最後の実行後に SQL_UNBIND に*Foption*を設定して**SQLFreeStmt**を呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-128">Because the result set keeps the same structure, you can bind the result set once, process all the SELECT statements, then call **SQLFreeStmt** with *fOption* set to SQL_UNBIND after the last execution.</span></span> <span data-ttu-id="3a8ac-129">*Foption*を SQL_UNBIND に設定して**SQLFreeStmt**を呼び出して、以前のバインドをすべて解放しないで、結果セットの列をバインドするために**SQLBindCol**を呼び出さないでください。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-129">You should not call **SQLBindCol** to bind the columns in a result set without first calling **SQLFreeStmt** with *fOption* set to SQL_UNBIND to free any previous bindings.</span></span>  
  
 <span data-ttu-id="3a8ac-130">**SQLBindCol**を使用する場合は、行方向または列方向のバインドを行うことができます。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-130">When using **SQLBindCol**, you can either do row-wise or column-wise binding.</span></span> <span data-ttu-id="3a8ac-131">行方向のバインドの方が、列方向のバインドよりも処理がやや高速になります。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-131">Row-wise binding is somewhat faster than column-wise binding.</span></span>  
  
 <span data-ttu-id="3a8ac-132">**SQLGetData**を使用すると、 **SQLBindCol**を使用して結果セット列をバインドするのではなく、列ごとにデータを取得できます。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-132">You can use **SQLGetData** to retrieve data on a column-by-column basis instead of binding result set columns using **SQLBindCol**.</span></span> <span data-ttu-id="3a8ac-133">結果セットに含まれる行が少ない場合は、 **SQLBindCol**ではなく**SQLGetData**を使用する方が高速です。それ以外の場合は、 **SQLBindCol**によって最適なパフォーマンスが得られます。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-133">If a result set contains only a few rows, using **SQLGetData** instead of **SQLBindCol** is faster; otherwise, **SQLBindCol** gives the best performance.</span></span> <span data-ttu-id="3a8ac-134">常に同じ変数セットにデータを格納しない場合は、常に再バインドするのではなく、 **SQLGetData**を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-134">If you do not always put the data in the same set of variables, you should use **SQLGetData** instead of constantly rebinding.</span></span> <span data-ttu-id="3a8ac-135">**SQLGetData**は、すべての列が**SQLBindCol**にバインドされた後に、選択リスト内の列に対してのみ使用できます。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-135">You can only use **SQLGetData** on columns that are in the select list after all columns are bound with **SQLBindCol**.</span></span> <span data-ttu-id="3a8ac-136">また、 **SQLGetData**を既に使用している列の後にも列が表示されます。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-136">The column must also appear after any columns on which you have already used **SQLGetData**.</span></span>  
  
 <span data-ttu-id="3a8ac-137">**SQLGetData**、 **SQLBindCol**、 [SQLBindParameter](../native-client-odbc-api/sqlbindparameter.md)などのプログラム変数へのデータの移動を処理する ODBC 関数は、暗黙的なデータ型変換をサポートしています。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-137">The ODBC functions that deal with moving data into or out of program variables, such as **SQLGetData**, **SQLBindCol**, and [SQLBindParameter](../native-client-odbc-api/sqlbindparameter.md), support implicit data type conversion.</span></span> <span data-ttu-id="3a8ac-138">たとえば、整数列を文字列プログラム変数にバインドするアプリケーションでは、プログラム変数にデータを格納する前に、ドライバーが自動的にそのデータを整数から文字に変換します。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-138">For example, if an application binds an integer column to a character string program variable, the driver automatically converts the data from integer to character before placing it into the program variable.</span></span>  
  
 <span data-ttu-id="3a8ac-139">アプリケーションでのデータ変換は最小限に抑える必要があります。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-139">Data conversion in applications should be minimized.</span></span> <span data-ttu-id="3a8ac-140">列やパラメーターは、アプリケーションでの処理にデータ変換が必要な場合を除き、同じデータ型のプログラム変数にバインドする必要があります。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-140">Unless data conversion is required for the processing done by the application, applications should bind columns and parameters to program variables of the same data type.</span></span> <span data-ttu-id="3a8ac-141">ただし、あるデータ型から別のデータ型に変換する必要がある場合は、アプリケーションでのデータ変換よりもドライバーによるデータ変換の方が効率的です。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-141">If the data must be converted from one type to another, however, it is more efficient to have the driver do the conversion than doing it in the application.</span></span> <span data-ttu-id="3a8ac-142">通常、[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native Client ODBC ドライバーは、ネットワーク バッファーからアプリケーションの変数にデータを直接転送します。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-142">The [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native Client ODBC driver normally just transfers data directly from the network buffers to the variables of the application.</span></span> <span data-ttu-id="3a8ac-143">データ変換を行うようにドライバーに要求すると、ドライバーはデータをバッファーに格納し、CPU サイクルを使用してデータを変換します。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-143">Requesting the driver to do data conversion forces the driver to buffer the data and use CPU cycles to convert the data.</span></span>  
  
 <span data-ttu-id="3a8ac-144">プログラム変数は、 **text**、 **ntext**、および**image**型のデータを除く、列から転送されるデータを保持するのに十分な大きさにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-144">Program variables should be large enough to hold data transferred in from a column, except for **text**, **ntext**, and **image** data.</span></span> <span data-ttu-id="3a8ac-145">結果セットのデータを取得してそのデータを変数に格納するときに、その変数が小さすぎてデータを保持できない場合、ドライバーは警告を生成します。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-145">If an application attempts to retrieve result set data and place it into a variable that is too small to hold it, the driver generates a warning.</span></span> <span data-ttu-id="3a8ac-146">その結果、ドライバーでは警告メッセージ用のメモリを割り当て、ドライバーとアプリケーションの両方で、警告メッセージの処理やエラーの処理に CPU サイクルが必要になります。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-146">This forces the driver to allocate memory for the message, and the driver and application both have to spend CPU cycles processing the message and doing error handling.</span></span> <span data-ttu-id="3a8ac-147">アプリケーションでは、取得するデータを保持するのに十分なサイズの変数を割り当てるか、選択リストで SUBSTRING 関数を使用して結果セット内の列のサイズを小さくする必要があります。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-147">The application should either allocate a variable large enough to hold the data being retrieved or use the SUBSTRING function in the select list to reduce the size of the column in the result set.</span></span>  
  
 <span data-ttu-id="3a8ac-148">SQL_C_DEFAULT を使用して C 変数のデータ型を指定する場合は注意が必要です。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-148">Care must be taken when using SQL_C_DEFAULT to specify the type of the C variable.</span></span> <span data-ttu-id="3a8ac-149">SQL_C_DEFAULT は、C 変数のデータ型と、列やパラメーターの SQL データ型を一致させることを指定します。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-149">SQL_C_DEFAULT specifies that the type of the C variable matches the SQL data type of the column or parameter.</span></span> <span data-ttu-id="3a8ac-150">SQL_C_DEFAULT が**ntext**、 **nchar**、または**nvarchar**列に対して指定されている場合、Unicode データがアプリケーションに返されます。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-150">If SQL_C_DEFAULT is specified for an **ntext**, **nchar**, or **nvarchar** column, Unicode data is returned to the application.</span></span> <span data-ttu-id="3a8ac-151">そのため、アプリケーションが Unicode データを処理するようにコーディングされていないと、さまざまな問題が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-151">This can cause various problems if the application has not been coded to handle Unicode data.</span></span> <span data-ttu-id="3a8ac-152">**Uniqueidentifier** (SQL_GUID) データ型でも、同じ種類の問題が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-152">The same types of problems can occur with the **uniqueidentifier** (SQL_GUID) data type.</span></span>  
  
 <span data-ttu-id="3a8ac-153">通常、 **text**、 **ntext**、および**image**型のデータは、1つのプログラム変数に格納するには大きすぎるため、通常は**SQLBindCol**ではなく**SQLGetData**を使用して処理されます。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-153">**text**, **ntext**, and **image** data is typically too large to fit into a single program variable, and is usually processed with **SQLGetData** instead of **SQLBindCol**.</span></span> <span data-ttu-id="3a8ac-154">サーバーカーソルを使用する場合、 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native CLIENT ODBC ドライバーは、行がフェッチされるときに、バインドされていない**text**、 **ntext**、または**image**型の列のデータを転送しないように最適化されています。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-154">When using server cursors, the [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native Client ODBC driver is optimized to not transmit the data for unbound **text**, **ntext**, or **image** columns at the time the row is fetched.</span></span> <span data-ttu-id="3a8ac-155">**Text**型、 **ntext**型、または**image**型のデータは、アプリケーションが列に対して**SQLGetData**を発行するまで、実際にはサーバーから取得されません。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-155">The **text**, **ntext**, or **image** data is not actually retrieved from the server until the application issues **SQLGetData** for the column.</span></span>  
  
 <span data-ttu-id="3a8ac-156">この最適化をアプリケーションに適用すると、ユーザーがカーソルを上下にスクロールしている間に**text**、 **ntext**、または**image**データが表示されないようにすることができます。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-156">This optimization can be applied to applications so that no **text**, **ntext**, or **image** data is displayed while a user is scrolling up and down a cursor.</span></span> <span data-ttu-id="3a8ac-157">ユーザーが行を選択すると、アプリケーションは**SQLGetData**を呼び出して、 **text**、 **ntext**、または**image**型のデータを取得できます。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-157">After the user selects a row, the application can call **SQLGetData** to retrieve the **text**, **ntext**, or **image** data.</span></span> <span data-ttu-id="3a8ac-158">これにより、ユーザーが選択していない行の**text**型、 **ntext**型、または**image**型のデータが送信され、大量のデータの転送を保存できるようになります。</span><span class="sxs-lookup"><span data-stu-id="3a8ac-158">This saves transmitting the **text**, **ntext**, or **image** data for any of the rows the user does not select and can save the transmission of very large amounts of data.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="3a8ac-159">参照</span><span class="sxs-lookup"><span data-stu-id="3a8ac-159">See Also</span></span>  
 [<span data-ttu-id="3a8ac-160">ODBC&#41;&#40;結果の処理</span><span class="sxs-lookup"><span data-stu-id="3a8ac-160">Processing Results &#40;ODBC&#41;</span></span>](processing-results-odbc.md)  
  
  
