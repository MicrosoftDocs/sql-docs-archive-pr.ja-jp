---
title: プラン表示の論理操作と物理操作のリファレンス | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: ''
ms.topic: conceptual
f1_keywords:
- sql12.swb.showplan.nestedloops.f1
- sql12.swb.showplan.dynamic.f1
- sql12.swb.showplan.tableinsert.f1
- sql12.swb.showplan.remoteinsert.f1
- sql12.swb.showplan.lazyspool.f1
- sql12.swb.showplan.RIDLookup
- sql12.swb.showplan.hashmatchteam.f1
- sql12.swb.showplan.tablespool.f1
- sql12.swb.showplan.print.f1
- sql12.swb.showplan.clusteredindexupdate.f1
- sql12.swb.showplan.assert.f1
- sql12.swb.showplan.columnstoreindexscan.f1
- sql12.swb.showplan.tablevaluedfunction.f1
- sql12.swb.showplan.split.f1
- sql12.swb.showplan.union.f1
- sql12.swb.showplan.clusteredindexseek.f1
- sql12.swb.showplan.indexspool.f1
- sql12.swb.showplan.indexinsert.f1
- sql12.swb.showplan.clusteredindexscan.f1
- sql12.swb.showplan.buildhash.f1
- sql12.swb.showplan.clusteredindexmerge.f1
- sql12.swb.showplan.sequence.f1
- sql12.swb.showplan.hashmatchroot.f1
- sql12.swb.showplan.columnstoreindexupdate.f1
- sql12.swb.showplan.rightsemijoin.f1
- sql12.swb.showplan.fetchquery.f1
- sql12.swb.showplan.distinct.f1
- sql12.swb.showplan.hashmatch.f1
- sql12.swb.showplan.segment.f1
- sql12.swb.showplan.top.f1
- sql12.swb.showplan.columnstoreindexdelete.f1
- sql12.swb.showplan.gatherstreams.f1
- sql12.swb.showplan.remotedelete.f1
- sql12.swb.showplan.insert.f1
- sql12.swb.showplan.declare.f1
- sql12.swb.showplan.snapshot.f1
- sql12.swb.showplan.assign.f1
- sql12.swb.showplan.intrinsic.f1
- sql12.swb.showplan.mergejoin.f1
- sql12.swb.showplan.concatenation.f1
- sql12.swb.showplan.rowcountspool.f1
- sql12.swb.showplan.parametertablescan.f1
- sql12.swb.showplan.indexscan.f1
- sql12.swb.showplan.while.f1
- sql12.swb.showplan.columnstoreindexinsert.f1
- sql12.swb.showplan.tablemerge.f1
- sql12.swb.showplan.spool.f1
- sql12.swb.showplan.streamaggregate.f1
- sql12.swb.showplan.update.f1
- sql12.swb.showplan.innerjoin.f1
- sql12.swb.showplan.flowdistinct.f1
- sql12.swb.showplan.tableupdate.f1
- sql12.swb.showplan.result.f1
- sql12.swb.showplan.bitmap.f1
- sql12.swb.showplan.remoteindexseek.f1
- sql12.swb.showplan.populationquery.f1
- sql12.swb.showplan.rightouterjoin.f1
- sql12.swb.showplan.columnstoreindexmerge.f1
- sql12.swb.showplan.remotescan.f1
- sql12.swb.showplan.remoteupdate.f1
- sql12.swb.showplan.keyset.f1
- sql12.swb.showplan.collapse.f1
- sql12.swb.showplan.arithmeticexpression.f1
- sql12.swb.showplan.clusteredindexinsert.f1
- sql12.swb.showplan.computescalar
- sql12.swb.showplan.sort.f1
- sql12.swb.showplan.locate.f1
- sql12.swb.showplan.constantscan.f1
- sql12.swb.showplan.computescalar.f1
- sql12.swb.showplan.indexseek.f1
- sql12.swb.showplan.leftsemijoin.f1
- sql12.swb.showplan.leftantisemijoin.f1
- sql12.swb.showplan.fullouterjoin.f1
- sql12.swb.showplan.filter.f1
- sql12.swb.showplan.indexdelete.f1
- sql12.swb.showplan.repartitionstreams.f1
- sql12.swb.showplan.crossjoin.f1
- sql12.swb.showplan.mergeinterval.f1
- sql12.swb.showplan.bookmarklookup.f1
- sql12.swb.showplan.convert.f1
- sql12.swb.showplan.refreshquery.f1
- sql12.swb.showplan.distinctsort.f1
- sql12.swb.showplan.leftouterjoin.f1
- sql12.swb.showplan.rightantisemijoin.f1
- sql12.swb.showplan.deletedscan.f1
- sql12.swb.showplan.udx.f1
- sql12.swb.showplan.broadcast.f1
- sql12.swb.showplan.delete.f1
- sql12.swb.showplan.aggregate.f1
- sql12.swb.showplan.setfunction.f1
- sql12.swb.showplan.switch.f1
- sql12.swb.showplan.remoteindexscan.f1
- sql12.swb.showplan.eagerspool.f1
- sql12.swb.showplan.indexupdate.f1
- sql12.swb.showplan.keylookup.f1
- sql12.swb.showplan.branchrepartition.f1
- sql12.swb.showplan.rank.f1
- sql12.swb.showplan.tablescan.f1
- sql12.swb.showplan.distributestreams.f1
- sql12.swb.showplan.logrowscan.f1
- sql12.swb.showplan.parallelism.f1
- sql12.swb.showplan.bitmapcreate.f1
- sql12.swb.showplan.insertedscan.f1
- sql12.swb.showplan.tabledelete.f1
- sql12.swb.showplan.clusteredindexdelete.f1
- sql12.swb.showplan.remotequery.f1
- sql12.swb.showplan.if.f1
- sql12.swb.showplan.cache.f1
- sql12.swb.showplan.partialaggregate.f1
- sql12.swb.showplan.sql.f1
helpviewer_keywords:
- execution plans [SQL Server], operators
- ActualRows attribute
- reading execution plan output
- ActualRewinds attribute
- ActualEndOfScans attribute
- query tuning [SQL Server]
- mapping operators [SQL Server]
- operators [Database Engine query tuning]
- logical operators [SQL Server], execution plans
- logical operators [SQL Server], listed
- physical operators [SQL Server]
- ActualRebinds attribute
- execution plans [SQL Server], reading output
ms.assetid: e43fd0fe-5ea7-4ffe-8d52-759ef6a7c361
author: rothja
ms.author: jroth
ms.openlocfilehash: bc45a5fa14785294093385e6f90b47a8bdb6dff3
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/04/2020
ms.locfileid: "87717690"
---
# <a name="showplan-logical-and-physical-operators-reference"></a><span data-ttu-id="c4cd0-102">プラン表示の論理操作と物理操作のリファレンス</span><span class="sxs-lookup"><span data-stu-id="c4cd0-102">Showplan Logical and Physical Operators Reference</span></span>
  <span data-ttu-id="c4cd0-103">操作は、 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] でクエリやデータ操作言語 (DML) ステートメントを実行する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-103">Operators describe how [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] executes a query or a Data Manipulation Language (DML) statement.</span></span> <span data-ttu-id="c4cd0-104">クエリ オプティマイザーでは、操作を使用して、クエリで指定された結果を作成するクエリ プラン、または DML ステートメントで指定された操作を実行するクエリ プランが構築されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-104">The query optimizer uses operators to build a query plan to create the result specified in the query, or to perform the operation specified in the DML statement.</span></span> <span data-ttu-id="c4cd0-105">クエリ プランは、物理操作をツリー構成で表現したものです。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-105">The query plan is a tree consisting of physical operators.</span></span> <span data-ttu-id="c4cd0-106">クエリ プランを表示するには、SET SHOWPLAN ステートメント、 [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)]のグラフィカル実行プラン オプション、または SQL Server Profiler Showplan イベント クラスを使用します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-106">You can view the query plan by using the SET SHOWPLAN statements, the graphical execution plan options in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)], or the SQL Server Profiler Showplan event classes.</span></span>  
  
 <span data-ttu-id="c4cd0-107">操作は、論理操作と物理操作に分類されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-107">Operators are classified as logical and physical operators.</span></span>  
  
 <span data-ttu-id="c4cd0-108">**論理演算子**</span><span class="sxs-lookup"><span data-stu-id="c4cd0-108">**Logical Operators**</span></span>  
 <span data-ttu-id="c4cd0-109">論理操作は、ステートメントの処理に使用される関係代数操作を表します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-109">Logical operators describe the relational algebraic operation used to process a statement.</span></span> <span data-ttu-id="c4cd0-110">つまり、論理操作は、どのような操作を実行する必要があるかを、概念的に示します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-110">In other words, logical operators describe conceptually what operation needs to be performed.</span></span>  
  
 <span data-ttu-id="c4cd0-111">**物理操作**</span><span class="sxs-lookup"><span data-stu-id="c4cd0-111">**Physical Operators**</span></span>  
 <span data-ttu-id="c4cd0-112">物理操作では、論理操作によって示される操作が実装されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-112">Physical operators implement the operation described by logical operators.</span></span> <span data-ttu-id="c4cd0-113">それぞれの物理操作は、操作を実行するオブジェクトまたはルーチンです。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-113">Each physical operator is an object or routine that performs an operation.</span></span> <span data-ttu-id="c4cd0-114">たとえば、一部の物理操作は、テーブル、インデックス、またはビューから、列や行にアクセスします。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-114">For example, some physical operators access columns or rows from a table, index or view.</span></span> <span data-ttu-id="c4cd0-115">他の物理操作は、計算、集計、データ整合性チェック、結合などの他の操作を実行します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-115">Other physical operators perform other operations such as calculations, aggregations, data integrity checks or joins.</span></span> <span data-ttu-id="c4cd0-116">物理操作には、それぞれ関連するコストがかかります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-116">Physical operators have costs associated with them.</span></span>  
  
 <span data-ttu-id="c4cd0-117">物理操作では、初期化、データの収集が行われた後に終了されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-117">The physical operators initialize, collect data, and close.</span></span> <span data-ttu-id="c4cd0-118">具体的には、物理操作は次の 3 つのメソッド呼び出しに応答できます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-118">Specifically, the physical operator can answer the following three method calls:</span></span>  
  
-   <span data-ttu-id="c4cd0-119">**Init()** :**Init()** メソッドは、物理操作自体を初期化し、必要なデータ構造を設定します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-119">**Init()**: The **Init()** method causes a physical operator to initialize itself and set up any required data structures.</span></span> <span data-ttu-id="c4cd0-120">通常、物理操作が受け取る **Init()** 呼び出しは 1 つだけですが、多くの Init() 呼び出しを受け取る場合もあります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-120">The physical operator may receive many **Init()** calls, though typically a physical operator receives only one.</span></span>  
  
-   <span data-ttu-id="c4cd0-121">**GetNext()** :**GetNext()** メソッドにより、物理操作がデータの最初の行または後続の行を取得します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-121">**GetNext()**: The **GetNext()** method causes a physical operator to get the first, or subsequent row of data.</span></span> <span data-ttu-id="c4cd0-122">物理操作が受け取る **GetNext()** 呼び出しは、多数の場合もゼロの場合もあります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-122">The physical operator may receive zero or many **GetNext()** calls.</span></span>  
  
-   <span data-ttu-id="c4cd0-123">**Close()** :**Close()** メソッドにより、物理操作はクリーンアップ操作を実行し、物理操作自体がシャットダウンされます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-123">**Close()**: The **Close()** method causes a physical operator to perform some clean-up operations and shut itself down.</span></span> <span data-ttu-id="c4cd0-124">物理操作は、 **Close()** 呼び出しを 1 つだけ受け取ります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-124">A physical operator only receives one **Close()** call.</span></span>  
  
 <span data-ttu-id="c4cd0-125">**GetNext()** メソッドは、データ行を 1 行返します。このメソッドが呼び出された回数は、SET STATISTICS PROFILE ON または SET STATISTICS XML ON を使用して生成されるプラン表示出力で **ActualRows** として表示されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-125">The **GetNext()** method returns one row of data, and the number of times it is called appears as **ActualRows** in the Showplan output that is produced by using SET STATISTICS PROFILE ON or SET STATISTICS XML ON.</span></span> <span data-ttu-id="c4cd0-126">これらの SET オプションの詳細については、「[SET STATISTICS PROFILE &#40;Transact-SQL&#41;](/sql/t-sql/statements/set-statistics-profile-transact-sql)」および「[SET STATISTICS XML &#40;Transact-SQL&#41;](/sql/t-sql/statements/set-statistics-xml-transact-sql)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-126">For more information about these SET options, see [SET STATISTICS PROFILE &#40;Transact-SQL&#41;](/sql/t-sql/statements/set-statistics-profile-transact-sql) and [SET STATISTICS XML &#40;Transact-SQL&#41;](/sql/t-sql/statements/set-statistics-xml-transact-sql).</span></span>  
  
 <span data-ttu-id="c4cd0-127">プラン表示出力に表示される **ActualRebinds** および **ActualRewinds** の数は、**Init()** メソッドが呼び出された回数を示します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-127">The **ActualRebinds** and **ActualRewinds** counts that appear in Showplan output refer to the number of times that the **Init()** method is called.</span></span> <span data-ttu-id="c4cd0-128">ループ結合内部での操作でなければ、 **ActualRebinds** は 1、 **ActualRewinds** は 0 になります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-128">Unless an operator is on the inner side of a loop join, **ActualRebinds** equals one and **ActualRewinds** equals zero.</span></span> <span data-ttu-id="c4cd0-129">ループ結合内部での操作の場合、再バインドと巻き戻しの合計数は、結合外部で処理された行数に等しくなる必要があります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-129">If an operator is on the inner side of a loop join, the sum of the number of rebinds and rewinds should equal the number of rows processed on the outer side of the join.</span></span> <span data-ttu-id="c4cd0-130">再バインドとは、結合の変更された相関パラメーターと、内側部分の相関パラメーターの 1 つ以上を再評価する必要があることを意味します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-130">A rebind means that one or more of the correlated parameters of the join changed and the inner side must be reevaluated.</span></span> <span data-ttu-id="c4cd0-131">巻き戻しとは、変更された相関パラメーターを使用せず、前の内部の結果セットを再利用することを意味します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-131">A rewind means that none of the correlated parameters changed and the prior inner result set may be reused.</span></span>  
  
 <span data-ttu-id="c4cd0-132">**ActualRebinds** および **ActualRewinds** は、SET STATISTICS XML ON を使用して生成された XML プラン表示出力に存在します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-132">**ActualRebinds** and **ActualRewinds** are present in XML Showplan output produced by using SET STATISTICS XML ON.</span></span> <span data-ttu-id="c4cd0-133">これらの値は、**非クラスター化インデックススプール**、 `Remote Query` 、**行カウントスプール**、 `Sort` 、**テーブルスプール**、および**テーブル値関数**の各演算子に対してのみ設定されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-133">They are only populated for the **Nonclustered Index Spool**, `Remote Query`, **Row Count Spool**, `Sort`, **Table Spool**, and **Table-valued Function** operators.</span></span> <span data-ttu-id="c4cd0-134">また、Startupexpression 属性が TRUE に設定されている場合は、とフィルター演算子に対して**Actualrebinds バインド**と**actualrebinds 戻し**を設定することもでき `Assert` ます。 **Filter** **StartupExpression**</span><span class="sxs-lookup"><span data-stu-id="c4cd0-134">**ActualRebinds** and **ActualRewinds** may also be populated for the `Assert` and **Filter** operators when the **StartupExpression** attribute is set to TRUE.</span></span>  
  
 <span data-ttu-id="c4cd0-135">**ActualRebinds** および **ActualRewinds** が XML プラン表示に存在する場合、これらの値が **EstimateRebinds** および **EstimateRewinds**に相当します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-135">When **ActualRebinds** and **ActualRewinds** are present in an XML Showplan, they are comparable to **EstimateRebinds** and **EstimateRewinds**.</span></span> <span data-ttu-id="c4cd0-136">存在しない場合、予測行数 (**EstimateRows**) が実際の行数 (**ActualRows**) に相当します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-136">When they are absent, the estimated number of rows (**EstimateRows**) is comparable to the actual number of rows (**ActualRows**).</span></span> <span data-ttu-id="c4cd0-137">この場合、実際のグラフィカルなプラン表示出力では、実際の再バインド数と実際の巻き戻し数としてゼロが表示されることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-137">Note that actual graphical Showplan output displays zeros for the actual rebinds and actual rewinds when they are absent.</span></span>  
  
 <span data-ttu-id="c4cd0-138">関連するカウンター **ActualEndOfScans**は、プラン表示出力が SET STATISTICS XML ON を使用して生成されている場合のみ使用できます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-138">A related counter, **ActualEndOfScans**, is available only when Showplan output is produced by using SET STATISTICS XML ON.</span></span> <span data-ttu-id="c4cd0-139">物理操作がデータ ストリームの最後に達するたびに、このカウンターの値は 1 ずつ増加します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-139">Whenever a physical operator reaches the end of its data stream, this counter is incremented by one.</span></span> <span data-ttu-id="c4cd0-140">物理操作がデータ ストリームの最後に達することのできる回数は、0 回、1 回、あるいは複数回です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-140">A physical operator can reach the end of its data stream zero, one, or multiple times.</span></span> <span data-ttu-id="c4cd0-141">再バインドおよび巻き戻しと同様に、スキャンの終了回数は、ループ結合内部での操作の場合のみ 2 回以上になります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-141">As with rebinds and rewinds, the number of end of scans can be more than one only if the operator is on the inner side of a loop join.</span></span> <span data-ttu-id="c4cd0-142">スキャンの終了回数は、再バインドおよび巻き戻しの合計数以下になる必要があります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-142">The number of end of scans should be less than or equal to the sum of the number of rebinds and rewinds.</span></span>  
  
## <a name="mapping-physical-and-logical-operators"></a><span data-ttu-id="c4cd0-143">物理操作と論理操作の対応関係</span><span class="sxs-lookup"><span data-stu-id="c4cd0-143">Mapping Physical and Logical Operators</span></span>  
 <span data-ttu-id="c4cd0-144">クエリ オプティマイザーでは、ツリー構成の論理操作としてクエリ プランが作成されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-144">The query optimizer creates a query plan as a tree consisting of logical operators.</span></span> <span data-ttu-id="c4cd0-145">クエリ オプティマイザーでは、プランが作成されると、各論理操作にとって最も効率的な物理操作が選択されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-145">After the query optimizer creates the plan, the query optimizer chooses the most efficient physical operator for each logical operator.</span></span> <span data-ttu-id="c4cd0-146">クエリ オプティマイザーでは、論理操作をどの物理操作から実装するかを判断するために、コストベースの手法が使用されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-146">The query optimizer uses a cost-based approach to determine which physical operator will implement a logical operator.</span></span>  
  
 <span data-ttu-id="c4cd0-147">通常、複数の物理操作で 1 つの論理操作を実装できます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-147">Usually, a logical operation can be implemented by multiple physical operators.</span></span> <span data-ttu-id="c4cd0-148">ただし、めったにないケースですが、1 つの物理操作で複数の論理操作を実装することもできます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-148">However, in rare cases, a physical operator can implement multiple logical operations as well.</span></span>  
  
## <a name="operator-descriptions"></a><span data-ttu-id="c4cd0-149">操作の説明</span><span class="sxs-lookup"><span data-stu-id="c4cd0-149">Operator Descriptions</span></span>  
 <span data-ttu-id="c4cd0-150">このセクションには、論理演算子と物理演算子の説明が含まれています。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-150">This section contains descriptions of the logical and physical operators.</span></span>  
  
|<span data-ttu-id="c4cd0-151">グラフィカルな実行プランのアイコン</span><span class="sxs-lookup"><span data-stu-id="c4cd0-151">Graphical Execution Plan Icon</span></span>|<span data-ttu-id="c4cd0-152">プラン表示操作</span><span class="sxs-lookup"><span data-stu-id="c4cd0-152">Showplan Operator</span></span>|<span data-ttu-id="c4cd0-153">説明</span><span class="sxs-lookup"><span data-stu-id="c4cd0-153">Description</span></span>|  
|-----------------------------------|-----------------------|-----------------|  
|<span data-ttu-id="c4cd0-154">なし</span><span class="sxs-lookup"><span data-stu-id="c4cd0-154">None</span></span>|`Aggregate`|<span data-ttu-id="c4cd0-155">`Aggregate` 操作は、MIN、MAX、SUM、COUNT、AVG のいずれかが含まれた式を計算します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-155">The `Aggregate` operator calculates an expression containing MIN, MAX, SUM, COUNT or AVG.</span></span> <span data-ttu-id="c4cd0-156">`Aggregate` は、論理操作または物理操作です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-156">The `Aggregate` operator can be a logical operator or a physical operator.</span></span>|  
|<span data-ttu-id="c4cd0-157">![Arithmetic Expression 操作アイコン](../../2014/database-engine/media/arithmetic-expression-32x-2.gif "Arithmetic Expression 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-157">![Arithmetic expression operator icon](../../2014/database-engine/media/arithmetic-expression-32x-2.gif "Arithmetic expression operator icon")</span></span>|`Arithmetic Expression`|<span data-ttu-id="c4cd0-158">`Arithmetic Expression` 操作は、行の既存の値から新しい値を計算します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-158">The `Arithmetic Expression` operator computes a new value from existing values in a row.</span></span> <span data-ttu-id="c4cd0-159">`Arithmetic Expression` は [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)] では使用されません。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-159">`Arithmetic Expression` is not used in [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].</span></span>|  
|<span data-ttu-id="c4cd0-160">![Assert 操作アイコン](../../2014/database-engine/media/assert-32x.gif "Assert 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-160">![Assert operator icon](../../2014/database-engine/media/assert-32x.gif "Assert operator icon")</span></span>|`Assert`|<span data-ttu-id="c4cd0-161">`Assert` 操作は、状態の検証を行います。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-161">The `Assert` operator verifies a condition.</span></span> <span data-ttu-id="c4cd0-162">たとえば、参照整合性の検証や、スカラー サブクエリによって 1 行返されることの確認を行います。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-162">For example, it validates referential integrity or ensures that a scalar subquery returns one row.</span></span> <span data-ttu-id="c4cd0-163">演算子は、各入力行に対して、 `Assert` 実行プランの列の式を評価し `Argument` ます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-163">For each input row, the `Assert` operator evaluates the expression in the `Argument` column of the execution plan.</span></span> <span data-ttu-id="c4cd0-164">この式が NULL であると評価されると、行は `Assert` 操作を通過して、クエリの実行が継続されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-164">If this expression evaluates to NULL, the row is passed through the `Assert` operator and the query execution continues.</span></span> <span data-ttu-id="c4cd0-165">式が NULL 以外の値に評価されると、相応のエラーが発生します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-165">If this expression evaluates to a nonnull value, the appropriate error will be raised.</span></span> <span data-ttu-id="c4cd0-166">`Assert` 操作は物理操作です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-166">The `Assert` operator is a physical operator.</span></span>|  
|<span data-ttu-id="c4cd0-167">![Assign 言語要素アイコン](../../2014/database-engine/media/assign-32.gif "Assign 言語要素アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-167">![Assign language element icon](../../2014/database-engine/media/assign-32.gif "Assign language element icon")</span></span>|`Assign`|<span data-ttu-id="c4cd0-168">`Assign` 操作は、変数に式の値または定数値を代入します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-168">The `Assign` operator assigns the value of an expression or a constant to a variable.</span></span> <span data-ttu-id="c4cd0-169">`Assign` は言語要素です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-169">`Assign` is a language element.</span></span>|  
|<span data-ttu-id="c4cd0-170">なし</span><span class="sxs-lookup"><span data-stu-id="c4cd0-170">None</span></span>|`Asnyc Concat`|<span data-ttu-id="c4cd0-171">`Asnyc Concat` 操作は、リモート クエリ (分散クエリ) でのみ使用されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-171">The `Asnyc Concat` operator is used only in remote queries (distributed queries).</span></span> <span data-ttu-id="c4cd0-172">Async Concat には *n* 個の子ノードと 1 個の親ノードが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-172">It has *n* children and one parent node.</span></span> <span data-ttu-id="c4cd0-173">通常、子ノードのいくつかはリモート コンピューターで、分散クエリに参加しています。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-173">Usually, some of the children are remote computers that participate in a distributed query.</span></span> <span data-ttu-id="c4cd0-174">`Asnyc Concat` は、すべての子ノードに同時に `open()` 呼び出しを行い、各子ノードにビットマップを適用します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-174">`Asnyc Concat` issues `open()` calls to all of the children simultaneously and then applies a bitmap to each child.</span></span> <span data-ttu-id="c4cd0-175">`Async Concat` では、1 に設定されているビットごとに、要求時に出力行が親ノードに送信されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-175">For each bit that is a 1, `Async Concat` sends the output rows to the parent node on demand.</span></span>|  
|<span data-ttu-id="c4cd0-176">![Bitmap 操作アイコン](../../2014/database-engine/media/bitmap-32x.gif "Bitmap 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-176">![Bitmap operator icon](../../2014/database-engine/media/bitmap-32x.gif "Bitmap operator icon")</span></span>|`Bitmap`|[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]<span data-ttu-id="c4cd0-177">演算子を使用して、 `Bitmap` 並列クエリプランでビットマップフィルターを実装します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-177">uses the `Bitmap` operator to implement bitmap filtering in parallel query plans.</span></span> <span data-ttu-id="c4cd0-178">ビットマップフィルターは、演算子などの別の演算子を使用して行を渡す前に、結合レコードを生成できないキー値を持つ行を削除することで、クエリの実行を高速化し `Parallelism` ます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-178">Bitmap filtering speeds up query execution by eliminating rows with key values that cannot produce any join records before passing rows through another operator such as the `Parallelism` operator.</span></span> <span data-ttu-id="c4cd0-179">ビットマップ フィルターは、操作ツリーの特定の部分にあるテーブルから得られた一連の値の圧縮表現を使用して、同じツリーの別の部分にある 2 つ目のテーブルから行を抽出します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-179">A bitmap filter uses a compact representation of a set of values from a table in one part of the operator tree to filter rows from a second table in another part of the tree.</span></span> <span data-ttu-id="c4cd0-180">不要な行をクエリの初期段階で排除することにより、それ以降の操作に渡される行数が減り、その結果、クエリの全体的なパフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-180">By removing unnecessary rows early in the query, subsequent operators have fewer rows to work with, and the overall performance of the query improves.</span></span> <span data-ttu-id="c4cd0-181">オプティマイザーは、どのような場合にビットマップの選択度が効果を期待できる程度に高くなるか、また、どのような操作にフィルターを適用すべきかを判断します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-181">The optimizer determines when a bitmap is selective enough to be useful and in which operators to apply the filter.</span></span> <span data-ttu-id="c4cd0-182">`Bitmap` は物理操作です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-182">`Bitmap` is a physical operator.</span></span>|  
|<span data-ttu-id="c4cd0-183">![Bitmap 操作アイコン](../../2014/database-engine/media/bitmap-32x.gif "Bitmap 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-183">![Bitmap operator icon](../../2014/database-engine/media/bitmap-32x.gif "Bitmap operator icon")</span></span>|`Bitmap Create`|<span data-ttu-id="c4cd0-184">`Bitmap Create` 操作は、ビットマップが作成されるプラン表示の出力に使用されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-184">The `Bitmap Create` operator appears in the Showplan output where bitmaps are built.</span></span> <span data-ttu-id="c4cd0-185">`Bitmap Create` は論理操作です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-185">`Bitmap Create` is a logical operator.</span></span>|  
|<span data-ttu-id="c4cd0-186">![Bookmark Lookup 操作アイコン](../../2014/database-engine/media/bookmark-lookup-32x.gif "Bookmark Lookup 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-186">![Bookmark lookup operator icon](../../2014/database-engine/media/bookmark-lookup-32x.gif "Bookmark lookup operator icon")</span></span>|`Bookmark Lookup`|<span data-ttu-id="c4cd0-187">`Bookmark Lookup` 操作は、ブックマーク (行 ID またはクラスター化キー) を使用してテーブルまたはクラスター化インデックスの対応行を参照します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-187">The `Bookmark Lookup` operator uses a bookmark (row ID or clustering key) to look up the corresponding row in the table or clustered index.</span></span> <span data-ttu-id="c4cd0-188">列には、 `Argument` テーブルまたはクラスター化インデックスの行を検索するために使用されるブックマークラベルが含まれています。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-188">The `Argument` column contains the bookmark label used to look up the row in the table or clustered index.</span></span> <span data-ttu-id="c4cd0-189">列には、 `Argument` 行が検索されるテーブルまたはクラスター化インデックスの名前も含まれます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-189">The `Argument` column also contains the name of the table or clustered index in which the row is looked up.</span></span> <span data-ttu-id="c4cd0-190">列に WITH プリフェッチ句が含まれている場合 `Argument` 、クエリプロセッサは、テーブルまたはクラスター化インデックスでブックマークを検索するときに、非同期プリフェッチ (先読み) を使用するのが最適であると判断しました。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-190">If the WITH PREFETCH clause appears in the `Argument` column, the query processor has determined that it is optimal to use asynchronous prefetching (read-ahead) when looking up bookmarks in the table or clustered index.</span></span><br /><br /> <span data-ttu-id="c4cd0-191">`Bookmark Lookup` は [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)] では使用されません。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-191">`Bookmark Lookup` is not used in [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].</span></span> <span data-ttu-id="c4cd0-192">代わりに、`Clustered Index Seek` および `RID Lookup` によってブックマーク参照機能が提供されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-192">Instead, `Clustered Index Seek` and `RID Lookup` provide bookmark lookup functionality.</span></span> <span data-ttu-id="c4cd0-193">`Key Lookup` 操作でもこの機能が提供されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-193">The `Key Lookup` operator also provides this functionality.</span></span>|  
|<span data-ttu-id="c4cd0-194">なし</span><span class="sxs-lookup"><span data-stu-id="c4cd0-194">None</span></span>|`Branch Repartition`|<span data-ttu-id="c4cd0-195">並列クエリ プランでは、反復子に概念上の領域が存在する場合があります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-195">In a parallel query plan, sometimes there are conceptual regions of iterators.</span></span> <span data-ttu-id="c4cd0-196">このような領域内にある反復子はすべて、並列スレッドにより実行できます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-196">All of the iterators within such a region can be executed by parallel threads.</span></span> <span data-ttu-id="c4cd0-197">領域自体は、順次実行される必要があります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-197">The regions themselves must be executed serially.</span></span> <span data-ttu-id="c4cd0-198">個別の領域内の `Parallelism` 反復子のいくつかは、`Branch Repartition` と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-198">Some of the `Parallelism` iterators within an individual region are called `Branch Repartition`.</span></span> <span data-ttu-id="c4cd0-199">このような 2 つの領域間の境界にある `Parallelism` 反復子は、`Segment Repartition` と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-199">The `Parallelism` iterator at the boundary of two such regions is called `Segment Repartition`.</span></span> <span data-ttu-id="c4cd0-200">`Branch Repartition` と `Segment Repartition` は論理操作です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-200">`Branch Repartition` and `Segment Repartition` are logical operators.</span></span>|  
|<span data-ttu-id="c4cd0-201">なし</span><span class="sxs-lookup"><span data-stu-id="c4cd0-201">None</span></span>|`Broadcast`|<span data-ttu-id="c4cd0-202">`Broadcast`には、1つの子ノードと*n 個*の親ノードがあります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-202">`Broadcast` has one child node and *n* parent nodes.</span></span> <span data-ttu-id="c4cd0-203">`Broadcast` では、要求時に複数のコンシューマーに入力行が送信されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-203">`Broadcast` sends its input rows to multiple consumers on demand.</span></span> <span data-ttu-id="c4cd0-204">各コンシューマーがすべての行を取得します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-204">Each consumer gets all of the rows.</span></span> <span data-ttu-id="c4cd0-205">たとえば、すべてのコンシューマーがハッシュ結合のビルド側の場合、ハッシュ テーブルの *n* 個のコピーがビルドされます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-205">For example, if all of the consumers are build sides of a hash join, then *n* copies of the hash tables will be built.</span></span>|  
|<span data-ttu-id="c4cd0-206">![Build Hash 操作アイコン](../../2014/database-engine/media/build-hash.gif "Build Hash 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-206">![Build hash operator icon](../../2014/database-engine/media/build-hash.gif "Build hash operator icon")</span></span>|`Build Hash`|<span data-ttu-id="c4cd0-207">xVelocity メモリ最適化列ストア インデックスのバッチ ハッシュ テーブルの作成を示します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-207">Indicates the build of a batch hash table for an xVelocity memory optimized columnstore index.</span></span>|  
|<span data-ttu-id="c4cd0-208">なし</span><span class="sxs-lookup"><span data-stu-id="c4cd0-208">None</span></span>|`Cache`|<span data-ttu-id="c4cd0-209">`Cache`は、 **Spool**操作の特殊なバージョンです。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-209">`Cache` is a specialized version of the **Spool** operator.</span></span> <span data-ttu-id="c4cd0-210">データは 1 行分しか格納されません。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-210">It stores only one row of data.</span></span> <span data-ttu-id="c4cd0-211">`Cache` は論理操作です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-211">`Cache` is a logical operator.</span></span> <span data-ttu-id="c4cd0-212">`Cache` は [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)] では使用されません。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-212">`Cache` is not used in [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].</span></span>|  
|<span data-ttu-id="c4cd0-213">![Clustered Index Delete 操作アイコン](../../2014/database-engine/media/clustered-index-delete-32x.gif "Clustered Index Delete 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-213">![Clustered index delete operator icon](../../2014/database-engine/media/clustered-index-delete-32x.gif "Clustered index delete operator icon")</span></span>|`Clustered Index Delete`|<span data-ttu-id="c4cd0-214">`Clustered Index Delete` 操作は、クエリ実行プランの Argument 列 (引数) で指定されているクラスター化インデックスから行を削除します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-214">The `Clustered Index Delete` operator deletes rows from the clustered index specified in the Argument column of the query execution plan.</span></span> <span data-ttu-id="c4cd0-215">Argument 列に WHERE:() 述語がある場合、その述語に適合する行だけが削除されます。`Clustered Index Delete`</span><span class="sxs-lookup"><span data-stu-id="c4cd0-215">If a WHERE:() predicate is present in the Argument column, then only those rows that satisfy the predicate are deleted.`Clustered Index Delete`</span></span> <span data-ttu-id="c4cd0-216"> は物理操作です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-216">is a physical operator.</span></span>|  
|<span data-ttu-id="c4cd0-217">![Clustered Index Insert 操作アイコン](../../2014/database-engine/media/clustered-index-insert-32x.gif "Clustered Index Insert 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-217">![Clustered index insert operator icon](../../2014/database-engine/media/clustered-index-insert-32x.gif "Clustered index insert operator icon")</span></span>|`Clustered Index Insert`|<span data-ttu-id="c4cd0-218">`Clustered Index Insert` プラン表示操作では、Argument 列で指定されているクラスター化インデックスに、入力からの行が挿入されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-218">The `Clustered Index Insert` Showplan operator inserts rows from its input into the clustered index specified in the Argument column.</span></span> <span data-ttu-id="c4cd0-219">また、Argument 列には、各列に設定する値を示す SET:() 述語も含まれます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-219">The Argument column also contains a SET:() predicate, which indicates the value to which each column is set.</span></span> <span data-ttu-id="c4cd0-220">に `Clustered Index Insert` 挿入値の子がない場合、挿入された行は演算子自体から取得され `Insert` ます。`Clustered Index Insert`</span><span class="sxs-lookup"><span data-stu-id="c4cd0-220">If `Clustered Index Insert` has no children for insert values, the row inserted is taken from the `Insert` operator itself.`Clustered Index Insert`</span></span> <span data-ttu-id="c4cd0-221"> は物理操作です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-221">is a physical operator.</span></span>|  
|<span data-ttu-id="c4cd0-222">![Clustered Index Merge 操作アイコン](../../2014/database-engine/media/clustered-index-merge-32x.gif "Clustered Index Merge 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-222">![Clustered index merge operator](../../2014/database-engine/media/clustered-index-merge-32x.gif "Clustered index merge operator")</span></span>|<span data-ttu-id="c4cd0-223">**Clustered Index Merge**</span><span class="sxs-lookup"><span data-stu-id="c4cd0-223">**Clustered Index Merge**</span></span>|<span data-ttu-id="c4cd0-224">**Clustered Index Merge** 操作は、マージ データ ストリームをクラスター化インデックスに適用します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-224">The **Clustered Index Merge** operator applies a merge data stream to a clustered index.</span></span> <span data-ttu-id="c4cd0-225">操作は、演算子の列に指定されているクラスター化インデックスから行を削除、更新、または挿入し `Argument` ます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-225">The operator deletes, updates, or inserts rows from the clustered index specified in the `Argument` column of the operator.</span></span> <span data-ttu-id="c4cd0-226">実際に実行される操作は、演算子の列に指定された**アクション**列のランタイム値によって異なり `Argument` ます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-226">The actual operation performed depends on the runtime value of the **ACTION** column specified in the `Argument` column of the operator.</span></span> <span data-ttu-id="c4cd0-227">**Clustered Index Merge** は物理操作です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-227">**Clustered Index Merge** is a physical operator.</span></span>|  
|<span data-ttu-id="c4cd0-228">![Clustered Index Scan 操作アイコン](../../2014/database-engine/media/clustered-index-scan-32x.gif "Clustered Index Scan 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-228">![Clustered index scan operator icon](../../2014/database-engine/media/clustered-index-scan-32x.gif "Clustered index scan operator icon")</span></span>|`Clustered Index Scan`|<span data-ttu-id="c4cd0-229">`Clustered Index Scan` 操作は、クエリ実行プランの Argument 列 (引数) に指定されたクラスター化インデックスをスキャンします。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-229">The `Clustered Index Scan` operator scans the clustered index specified in the Argument column of the query execution plan.</span></span> <span data-ttu-id="c4cd0-230">オプションの WHERE:() 述語がある場合、この述語に適合する行だけが返されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-230">When an optional WHERE:() predicate is present, only those rows that satisfy the predicate are returned.</span></span> <span data-ttu-id="c4cd0-231">Argument 列 (引数) に ORDERED 句が含まれている場合は、クラスター化インデックスの並べ替え順での行出力が要求されています。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-231">If the Argument column contains the ORDERED clause, the query processor has requested that the output of the rows be returned in the order in which the clustered index has sorted it.</span></span> <span data-ttu-id="c4cd0-232">ORDERED 句がない場合は、ストレージ エンジンが最適な方法でインデックスをスキャンします。出力の並べ替えは必ずしも行われません。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-232">If the ORDERED clause is not present, the storage engine scans the index in the optimal way, without necessarily sorting the output.</span></span> <span data-ttu-id="c4cd0-233">`Clustered Index Scan` は論理操作でもあり、物理操作でもあります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-233">`Clustered Index Scan` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="c4cd0-234">![Clustered Index Seek 操作アイコン](../../2014/database-engine/media/clustered-index-seek-32x.gif "Clustered Index Seek 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-234">![Clustered index seek operator icon](../../2014/database-engine/media/clustered-index-seek-32x.gif "Clustered index seek operator icon")</span></span>|`Clustered Index Seek`|<span data-ttu-id="c4cd0-235">`Clustered Index Seek` 操作は、インデックスのシーク機能を使用してクラスター化インデックスから行を取得します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-235">The `Clustered Index Seek` operator uses the seeking ability of indexes to retrieve rows from a clustered index.</span></span> <span data-ttu-id="c4cd0-236">列には、使用され `Argument` ているクラスター化インデックスの名前と SEEK:() 述語が含まれています。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-236">The `Argument` column contains the name of the clustered index being used and the SEEK:() predicate.</span></span> <span data-ttu-id="c4cd0-237">ストレージ エンジンはインデックスを使用して、この SEEK:() 述語に適合する行だけを処理します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-237">The storage engine uses the index to process only those rows that satisfy this SEEK:() predicate.</span></span> <span data-ttu-id="c4cd0-238">また、WHERE:() 述語を含めることもできます。この場合、ストレージ エンジンは、SEEK:() 述語に適合するすべての行が WHERE:() 述語に適合するかどうかを評価します。ただし、WHERE:() 述語は省略可能であり、処理を行うときにインデックスを使用しません。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-238">It can also include a WHERE:() predicate where the storage engine evaluates against all rows that satisfy the SEEK:() predicate, but this is optional and does not use indexes to complete this process.</span></span><br /><br /> <span data-ttu-id="c4cd0-239">列に `Argument` ORDERED 句が含まれている場合、クエリプロセッサは、クラスター化インデックスが並べ替えられた順序で行を返す必要があると判断しました。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-239">If the `Argument` column contains the ORDERED clause, the query processor has determined that the rows must be returned in the order in which the clustered index has sorted them.</span></span> <span data-ttu-id="c4cd0-240">ORDERED 句がない場合、ストレージ エンジンが最適な方法でインデックスを検索します。ただし、出力が並べ替えられるとは限りません。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-240">If the ORDERED clause is not present, the storage engine searches the index in the optimal way, without necessarily sorting the output.</span></span> <span data-ttu-id="c4cd0-241">出力で行の順序を保持する場合、並べ替えられていない出力に比べて効率が低下することがあります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-241">Allowing the output to retain its ordering can be less efficient than producing nonsorted output.</span></span> <span data-ttu-id="c4cd0-242">LOOKUP キーワードを指定すると、ブックマーク参照が行われます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-242">When the keyword LOOKUP appears, then a bookmark lookup is being performed.</span></span> <span data-ttu-id="c4cd0-243">以降のバージョンでは [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] 、 `Key Lookup` 演算子によってブックマーク参照機能が提供されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-243">In [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] and later versions, the `Key Lookup` operator provides bookmark lookup functionality.</span></span> <span data-ttu-id="c4cd0-244">`Clustered Index Seek` は論理操作でもあり、物理操作でもあります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-244">`Clustered Index Seek` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="c4cd0-245">![Clustered Index Update 操作アイコン](../../2014/database-engine/media/clustered-index-update-32x.gif "Clustered Index Update 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-245">![Clustered index update operator icon](../../2014/database-engine/media/clustered-index-update-32x.gif "Clustered index update operator icon")</span></span>|`Clustered Index Update`|<span data-ttu-id="c4cd0-246">操作は、 `Clustered Index Update` 列に指定されているクラスター化インデックスの入力行を更新し `Argument` ます。WHERE:() 述語がある場合、この述語に適合する行だけが更新されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-246">The `Clustered Index Update` operator updates input rows in the clustered index specified in the `Argument` column.If a WHERE:() predicate is present, only those rows that satisfy this predicate are updated.</span></span> <span data-ttu-id="c4cd0-247">SET:() 述語がある場合、更新される各列がこの値に設定されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-247">If a SET:() predicate is present, each updated column is set to this value.</span></span> <span data-ttu-id="c4cd0-248">DEFINE:() 述語がある場合、この操作によって定義される値が一覧表示されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-248">If a DEFINE:() predicate is present, the values that this operator defines are listed.</span></span> <span data-ttu-id="c4cd0-249">これらの値は、SET 句、またはこの操作内かこのクエリ内で参照されることがあります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-249">These values may be referenced in the SET clause or elsewhere within this operator and elsewhere within this query.</span></span> <span data-ttu-id="c4cd0-250">`Clustered Index Update` は論理操作でもあり、物理操作でもあります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-250">`Clustered Index Update` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="c4cd0-251">![Collapse 操作アイコン](../../2014/database-engine/media/collapse-32x.gif "Collapse 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-251">![Collapse operator icon](../../2014/database-engine/media/collapse-32x.gif "Collapse operator icon")</span></span>|`Collapse`|<span data-ttu-id="c4cd0-252">`Collapse` 操作により、更新処理が最適化されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-252">The `Collapse` operator optimizes update processing.</span></span> <span data-ttu-id="c4cd0-253">更新が実行されると、(`Split` 操作を使用して) 削除と挿入に分割されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-253">When an update is performed, it can be split (using the `Split` operator) into a delete and an insert.</span></span> <span data-ttu-id="c4cd0-254">列には、 `Argument` キー列の一覧を指定する GROUP BY:() 句が含まれています。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-254">The `Argument` column contains a GROUP BY:() clause that specifies a list of key columns.</span></span> <span data-ttu-id="c4cd0-255">クエリ プロセッサでは、同じキー値を削除して挿入する操作が隣接する行で検出されると、これらの個別の操作を 1 つのより効率的な更新操作に置き換えます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-255">If the query processor encounters adjacent rows that delete and insert the same key values, it replaces these separate operations with a single more efficient update operation.</span></span> <span data-ttu-id="c4cd0-256">`Collapse` は論理操作でもあり、物理操作でもあります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-256">`Collapse` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="c4cd0-257">![Columnstore インデックス スキャン](../../2014/database-engine/media/columnstoreindexscan.gif "Columnstore インデックス スキャン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-257">![Columnstore Index Scan](../../2014/database-engine/media/columnstoreindexscan.gif "Columnstore Index Scan")</span></span>|`Columnstore Index Scan`|<span data-ttu-id="c4cd0-258">操作は、 `Columnstore Index Scan` `Argument` クエリ実行プランの列に指定されている列ストアインデックスをスキャンします。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-258">The `Columnstore Index Scan` operator scans the columnstore index specified in the `Argument` column of the query execution plan.</span></span>|  
|<span data-ttu-id="c4cd0-259">![Compute Scalar 操作アイコン](../../2014/database-engine/media/compute-scalar-32x.gif "Compute Scalar 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-259">![Compute scalar operator icon](../../2014/database-engine/media/compute-scalar-32x.gif "Compute scalar operator icon")</span></span>|`Compute Scalar`|<span data-ttu-id="c4cd0-260">演算子は、式を評価して、 `Compute Scalar` 計算されたスカラー値を生成します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-260">The `Compute Scalar` operator evaluates an expression to produce a computed scalar value.</span></span> <span data-ttu-id="c4cd0-261">この値は、ユーザー、クエリの参照先、またはその両方に返されることがあります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-261">This may then be returned to the user, referenced elsewhere in the query, or both.</span></span> <span data-ttu-id="c4cd0-262">両方に返される例としては、フィルター述語や結合述語があります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-262">An example of both is in a filter predicate or join predicate.</span></span> <span data-ttu-id="c4cd0-263">`Compute Scalar` は論理操作でもあり、物理操作でもあります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-263">`Compute Scalar` is a logical and physical operator.</span></span><br /><br /> <span data-ttu-id="c4cd0-264">`Compute Scalar`SET STATISTICS XML によって生成されたプラン表示に表示される演算子には、要素が含まれていない場合があり `RunTimeInformation` ます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-264">`Compute Scalar` operators that appear in Showplans generated by SET STATISTICS XML might not contain the `RunTimeInformation` element.</span></span> <span data-ttu-id="c4cd0-265">**で**[実際の実行プランを含める] **オプションが選択されているときは、グラフィカルなプラン表示の**[プロパティ] **ウィンドウに** [実際の行数] **、** [実際の再バインド数] **、および** [実際の巻き戻し数] [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)]が表示されないことがあります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-265">In graphical Showplans, **Actual Rows**, **Actual Rebinds**, and **Actual Rewinds** might be absent from the **Properties** window when the **Include Actual Execution Plan** option is selected in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)].</span></span> <span data-ttu-id="c4cd0-266">その場合、コンパイルされたクエリ プランでは Compute Scalar 操作が使用されていたのに、実行時のクエリ プランではこの操作の作業が別の操作によって行われたことを意味します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-266">When this occurs, it means that although these operators were used in the compiled query plan, their work was performed by other operators in the run-time query plan.</span></span> <span data-ttu-id="c4cd0-267">また、SET STATISTICS PROFILE によって生成されるプラン表示出力の実行の数は、SET STATISTICS XML によって生成されるプラン表示の再バインドと巻き戻しの合計と同じになります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-267">Also note that the number of executes in Showplan output generated by SET STATISTICS PROFILE is equivalent to the sum of rebinds and rewinds in Showplans generated by SET STATISTICS XML.</span></span>|  
|<span data-ttu-id="c4cd0-268">![Concatenation 操作アイコン](../../2014/database-engine/media/concatenation-32x.gif "Concatenation 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-268">![Concatenation operator icon](../../2014/database-engine/media/concatenation-32x.gif "Concatenation operator icon")</span></span>|<span data-ttu-id="c4cd0-269">**Concatenation**</span><span class="sxs-lookup"><span data-stu-id="c4cd0-269">**Concatenation**</span></span>|<span data-ttu-id="c4cd0-270">**Concatenation** 操作は複数の入力をスキャンし、スキャンした各行を返します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-270">The **Concatenation** operator scans multiple inputs, returning each row scanned.</span></span> <span data-ttu-id="c4cd0-271">**Concatenation** は、主に [!INCLUDE[tsql](../includes/tsql-md.md)] UNION ALL コンストラクトの実装に使用します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-271">**Concatenation** is typically used to implement the [!INCLUDE[tsql](../includes/tsql-md.md)] UNION ALL construct.</span></span> <span data-ttu-id="c4cd0-272">**Concatenation** 物理操作は入力が複数で出力が 1 つです。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-272">The **Concatenation** physical operator has two or more inputs and one output.</span></span> <span data-ttu-id="c4cd0-273">この操作では、最初の入力ストリームの行が出力ストリームにコピーされ、同じ動作が以降の各入力ストリームに対して行われます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-273">Concatenation copies rows from the first input stream to the output stream, then repeats this operation for each additional input stream.</span></span> <span data-ttu-id="c4cd0-274">**Concatenation** は論理操作でもあり、物理操作でもあります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-274">**Concatenation** is a logical and physical operator.</span></span>|  
|<span data-ttu-id="c4cd0-275">![Constant Scan 操作アイコン](../../2014/database-engine/media/constant-scan-32x.gif "Constant Scan 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-275">![Constant scan operator icon](../../2014/database-engine/media/constant-scan-32x.gif "Constant scan operator icon")</span></span>|`Constant Scan`|<span data-ttu-id="c4cd0-276">演算子は、 `Constant Scan` 1 つ以上の定数行をクエリに導入します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-276">The `Constant Scan` operator introduces one or more constant rows into a query.</span></span> <span data-ttu-id="c4cd0-277">演算子は `Compute Scalar` 、 `Constant Scan` 演算子によって生成された行に列を追加するために、の後に使用されることがよくあり `Constant Scan` ます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-277">A `Compute Scalar` operator is often used after a `Constant Scan` to add columns to a row produced by the `Constant Scan` operator.</span></span>|  
|<span data-ttu-id="c4cd0-278">![Convert (データベース エンジン) 言語要素アイコン](../../2014/database-engine/media/convert-32x.gif "Convert (データベース エンジン) 言語要素アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-278">![Convert (Database Engine) language element icon](../../2014/database-engine/media/convert-32x.gif "Convert (Database Engine) language element icon")</span></span>|`Convert`|<span data-ttu-id="c4cd0-279">`Convert` 操作は、スカラー データ型間の変換を行います。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-279">The `Convert` operator converts one scalar data type to another.</span></span> <span data-ttu-id="c4cd0-280">`Convert` は言語要素です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-280">`Convert` is a language element.</span></span>|  
|<span data-ttu-id="c4cd0-281">なし</span><span class="sxs-lookup"><span data-stu-id="c4cd0-281">None</span></span>|`Cross Join`|<span data-ttu-id="c4cd0-282">`Cross Join` 操作は、最初 (上部) の入力の各行と 2 番目 (下部) の入力の各行を結合します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-282">The `Cross Join` operator joins each row from the first (top) input with each row from the second (bottom) input.</span></span> <span data-ttu-id="c4cd0-283">`Cross Join` は論理操作です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-283">`Cross Join` is a logical operator.</span></span>|  
|<span data-ttu-id="c4cd0-284">![Cursor Catchall カーソル操作アイコン](../../2014/database-engine/media/cursor-catch-all.gif "Cursor Catchall カーソル操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-284">![Cursor catchall cursor operator icon](../../2014/database-engine/media/cursor-catch-all.gif "Cursor catchall cursor operator icon")</span></span>|`catchall`|<span data-ttu-id="c4cd0-285">汎用アイコンは、グラフィカルなプラン表示を生成するロジックで、反復子に適したアイコンが見つからない場合に表示されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-285">The catchall icon is displayed when a suitable icon for the iterator cannot be found by the logic that produces graphical showplans.</span></span> <span data-ttu-id="c4cd0-286">汎用アイコンは、必ずしもエラー状態を示しているわけではありません。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-286">The catchall icon does not necessarily indicate an error condition.</span></span> <span data-ttu-id="c4cd0-287">汎用アイコンには、青 (反復子)、オレンジ (カーソル)、緑 ( [!INCLUDE[tsql](../includes/tsql-md.md)] 言語要素) の 3 種類があります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-287">There are three catchall icons: blue (for iterators), orange (for cursors), and green (for [!INCLUDE[tsql](../includes/tsql-md.md)] language elements).</span></span>|  
|<span data-ttu-id="c4cd0-288">なし</span><span class="sxs-lookup"><span data-stu-id="c4cd0-288">None</span></span>|<span data-ttu-id="c4cd0-289">**カーソル**</span><span class="sxs-lookup"><span data-stu-id="c4cd0-289">**Cursor**</span></span>|<span data-ttu-id="c4cd0-290">**カーソル** 論理操作および物理操作は、カーソル操作に関するクエリまたは更新処理がどのように実行されたかを示すために使用されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-290">The **Cursor** logical and physical operators are used to describe how a query or update involving cursor operations is executed.</span></span> <span data-ttu-id="c4cd0-291">カーソル物理操作は、キーセット ドリブン カーソルの使用など、カーソルの処理に使用される物理的な実装アルゴリズムを示します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-291">The physical operators describe the physical implementation algorithm used to process the cursor; for example, using a keyset-driven cursor.</span></span> <span data-ttu-id="c4cd0-292">カーソル実行の各ステップは、物理操作に関係します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-292">Each step in the execution of a cursor involves a physical operator.</span></span> <span data-ttu-id="c4cd0-293">カーソル論理操作は、カーソルが読み取り専用であるなどの、カーソルのプロパティを示します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-293">The logical operators describe a property of the cursor, such as the cursor is read only.</span></span><br /><br /> <span data-ttu-id="c4cd0-294">論理操作には、Asynchronous、Optimistic、Primary、Read Only、Scroll Locks、Secondary、および Synchronous があります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-294">Logical operators include Asynchronous, Optimistic, Primary, Read Only, Scroll Locks, and Secondary and Synchronous.</span></span><br /><br /> <span data-ttu-id="c4cd0-295">物理操作には、Dynamic、Fetch Query、Keyset、Population Query、Refresh Query、および Snapshot があります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-295">Physical operators include Dynamic, Fetch Query, Keyset, Population Query, Refresh Query and Snapshot.</span></span>|  
|<span data-ttu-id="c4cd0-296">![Declare 言語要素アイコン](../../2014/database-engine/media/declare-32x.gif "Declare 言語要素アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-296">![Declare language element icon](../../2014/database-engine/media/declare-32x.gif "Declare language element icon")</span></span>|`Declare`|<span data-ttu-id="c4cd0-297">操作は、 `Declare` クエリプランにローカル変数を割り当てます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-297">The `Declare`  operator allocates a local variable in the query plan.</span></span> <span data-ttu-id="c4cd0-298">`Declare` は言語要素です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-298">`Declare` is a language element.</span></span>|  
|<span data-ttu-id="c4cd0-299">![Delete (データベース エンジン) 操作アイコン](../../2014/database-engine/media/delete-32x.gif "Delete (データベース エンジン) 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-299">![Delete (Database Engine) operator icon](../../2014/database-engine/media/delete-32x.gif "Delete (Database Engine) operator icon")</span></span>|`Delete`|<span data-ttu-id="c4cd0-300">操作は、 `Delete` 列のオプションの述語を満たすオブジェクト行からを削除し `Argument` ます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-300">The `Delete` operator deletes from an object rows that satisfy the optional predicate in the `Argument` column.</span></span>|  
|<span data-ttu-id="c4cd0-301">![Delete Scan 操作アイコン](../../2014/database-engine/media/delete-scan-32x.gif "Delete Scan 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-301">![Delete scan operator icon](../../2014/database-engine/media/delete-scan-32x.gif "Delete scan operator icon")</span></span>|`Deleted Scan`|<span data-ttu-id="c4cd0-302">`Deleted Scan` 操作は、削除されたテーブルをトリガー内でスキャンします。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-302">The `Deleted Scan` operator scans the deleted table within a trigger.</span></span>|  
|<span data-ttu-id="c4cd0-303">なし</span><span class="sxs-lookup"><span data-stu-id="c4cd0-303">None</span></span>|`Distinct`|<span data-ttu-id="c4cd0-304">`Distinct` 操作は、行セットや値のコレクションから重複部分を削除します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-304">The `Distinct` operator removes duplicates from a rowset or from a collection of values.</span></span> <span data-ttu-id="c4cd0-305">`Distinct` は論理操作です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-305">`Distinct` is a logical operator.</span></span>|  
|<span data-ttu-id="c4cd0-306">なし</span><span class="sxs-lookup"><span data-stu-id="c4cd0-306">None</span></span>|`Distinct Sort`|<span data-ttu-id="c4cd0-307">`Distinct Sort`論理操作は、入力をスキャンし、重複部分を削除し、列の DISTINCT ORDER by:() 述語に指定されている列で並べ替え `Argument` ます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-307">The `Distinct Sort` logical operator scans the input, removing duplicates and sorting by the columns specified in the DISTINCT ORDER BY:() predicate of the `Argument` column.</span></span> <span data-ttu-id="c4cd0-308">`Distinct Sort` は論理操作です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-308">`Distinct Sort` is a logical operator.</span></span>|  
|<span data-ttu-id="c4cd0-309">![Distribute Streams 並列処理操作アイコン](../../2014/database-engine/media/parallelism-distribute-stream.gif "Distribute Streams 並列処理操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-309">![Distribute streams parallelism operator icon](../../2014/database-engine/media/parallelism-distribute-stream.gif "Distribute streams parallelism operator icon")</span></span>|<span data-ttu-id="c4cd0-310">**Distribute Streams**</span><span class="sxs-lookup"><span data-stu-id="c4cd0-310">**Distribute Streams**</span></span>|<span data-ttu-id="c4cd0-311">**Distribute Streams** 操作は、並列クエリ プランのみで使用されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-311">The **Distribute Streams** operator is used only in parallel query plans.</span></span> <span data-ttu-id="c4cd0-312">**Distribute Streams** 操作は、レコードの 1 つの入力ストリームを使用して複数の出力ストリームを生成します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-312">The **Distribute Streams** operator takes a single input stream of records and produces multiple output streams.</span></span> <span data-ttu-id="c4cd0-313">レコードの内容と形式は変更されません。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-313">The record contents and format are not changed.</span></span> <span data-ttu-id="c4cd0-314">入力ストリームの各レコードは、出力ストリームのいずれかに含まれます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-314">Each record from the input stream appears in one of the output streams.</span></span> <span data-ttu-id="c4cd0-315">この操作では、出力ストリーム内で入力レコードの相対順序が自動的に保持されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-315">This operator automatically preserves the relative order of the input records in the output streams.</span></span> <span data-ttu-id="c4cd0-316">通常、特定の入力レコードが属する出力ストリームを判断するにはハッシュ操作が使用されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-316">Usually, hashing is used to decide to which output stream a particular input record belongs.</span></span><br /><br /> <span data-ttu-id="c4cd0-317">出力がパーティション分割されている場合、列には `Argument` パーティション列:() 述語とパーティション分割列が含まれます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-317">If the output is partitioned, then the `Argument` column contains a PARTITION COLUMNS:() predicate and the partitioning columns.</span></span> <span data-ttu-id="c4cd0-318">**Distribute Streams** は論理操作です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-318">**Distribute Streams** is a logical operator</span></span>|  
|<span data-ttu-id="c4cd0-319">![Dynamic カーソル操作アイコン](../../2014/database-engine/media/dynamic-32x.gif "Dynamic カーソル操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-319">![Dynamic cursor operator icon](../../2014/database-engine/media/dynamic-32x.gif "Dynamic cursor operator icon")</span></span>|`Dynamic`|<span data-ttu-id="c4cd0-320">`Dynamic` 操作は、他のユーザーによる変更をすべて表示できるカーソルを使用します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-320">The `Dynamic` operator uses a cursor that can see all changes made by others.</span></span>|  
|<span data-ttu-id="c4cd0-321">![Spool 操作アイコン](../../2014/database-engine/media/spool-32x.gif "Spool 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-321">![Spool operator icon](../../2014/database-engine/media/spool-32x.gif "Spool operator icon")</span></span>|<span data-ttu-id="c4cd0-322">**Eager Spool**</span><span class="sxs-lookup"><span data-stu-id="c4cd0-322">**Eager Spool**</span></span>|<span data-ttu-id="c4cd0-323">**一括スプール**操作は、入力全体を受け取り、データベースに格納されている非表示の一時オブジェクトに各行を格納 `tempdb` します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-323">The **Eager Spool** operator takes the entire input, storing each row in a hidden temporary object stored in the `tempdb` database.</span></span> <span data-ttu-id="c4cd0-324">演算子が巻き戻し (たとえば、演算子によって) されていても、再バインドが不要な場合は、入力を再 `Nested Loops` スキャンする代わりにスプールされたデータが使用されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-324">If the operator is rewound (for example, by a `Nested Loops` operator) but no rebinding is needed, the spooled data is used instead of rescanning the input.</span></span> <span data-ttu-id="c4cd0-325">再バインドが必要な場合は、スプールされたデータが破棄され、(再バインドされる) 入力の再スキャンによりスプール オブジェクトが再構築されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-325">If rebinding is needed, the spooled data is discarded and the spool object is rebuilt by rescanning the (rebound) input.</span></span> <span data-ttu-id="c4cd0-326">**Eager Spool** 操作では、操作のスプール ファイルが "集中的" に構築されます。たとえば、スプールの親操作によって最初の行が要求されると、スプール操作によって入力操作からのすべての行が使用され、それらの行がスプールに格納されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-326">The **Eager Spool** operator builds its spool file in an "eager" manner: when the spool's parent operator asks for the first row, the spool operator consumes all rows from its input operator and stores them in the spool.</span></span> <span data-ttu-id="c4cd0-327">**Eager Spool** は論理操作です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-327">**Eager Spool** is a logical operator.</span></span>|  
|<span data-ttu-id="c4cd0-328">![Fetch Query カーソル操作アイコン](../../2014/database-engine/media/fetch-query-32x.gif "Fetch Query カーソル操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-328">![Fetch query cursor operator icon](../../2014/database-engine/media/fetch-query-32x.gif "Fetch query cursor operator icon")</span></span>|`Fetch Query`|<span data-ttu-id="c4cd0-329">`Fetch Query` 操作は、カーソルに対してフェッチが実行されたときに行を取得します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-329">The `Fetch Query` operator retrieves rows when a fetch is issued against a cursor.</span></span>|  
|<span data-ttu-id="c4cd0-330">![Filter (データベース エンジン) 操作アイコン](../../2014/database-engine/media/filter-32x.gif "Filter (データベース エンジン) 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-330">![Filter (Database Engine) operator icon](../../2014/database-engine/media/filter-32x.gif "Filter (Database Engine) operator icon")</span></span>|<span data-ttu-id="c4cd0-331">**Assert**</span><span class="sxs-lookup"><span data-stu-id="c4cd0-331">**Filter**</span></span>|<span data-ttu-id="c4cd0-332">**Filter**操作は、入力をスキャンし、列に表示されるフィルター式 (述語) に適合する行だけを返し `Argument` ます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-332">The **Filter** operator scans the input, returning only those rows that satisfy the filter expression (predicate) that appears in the `Argument` column.</span></span>|  
|<span data-ttu-id="c4cd0-333">なし</span><span class="sxs-lookup"><span data-stu-id="c4cd0-333">None</span></span>|`Flow Distinct`|<span data-ttu-id="c4cd0-334">`Flow Distinct` 論理操作は入力をスキャンし、重複部分を削除します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-334">The `Flow Distinct` logical operator scans the input, removing duplicates.</span></span> <span data-ttu-id="c4cd0-335">演算子は、 `Distinct` 出力を生成する前にすべての入力を使用しますが、 **flowdistinct**操作は、入力から取得された各行を返します (行が重複する場合は破棄されます)。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-335">Whereas the `Distinct` operator consumes all input before producing any output, the **FlowDistinct** operator returns each row as it is obtained from the input (unless that row is a duplicate, in which case it is discarded).</span></span>|  
|<span data-ttu-id="c4cd0-336">なし</span><span class="sxs-lookup"><span data-stu-id="c4cd0-336">None</span></span>|`Full Outer Join`|<span data-ttu-id="c4cd0-337">`Full Outer Join` 論理操作は、最初 (上部) の入力で結合述語に適合し、2 番目 (下部) の入力の各行と結合された各行を返します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-337">The `Full Outer Join` logical operator returns each row satisfying the join predicate from the first (top) input joined with each row from the second (bottom) input.</span></span> <span data-ttu-id="c4cd0-338">また、以下の行も返します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-338">It also returns rows from:</span></span><br /><br /> <span data-ttu-id="c4cd0-339">\- 2 番目の入力に一致する行がない最初の入力の行。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-339">-The first input that had no matches in the second input.</span></span><br /><br /> <span data-ttu-id="c4cd0-340">\- 最初の入力に一致する行がない 2 番目の入力の行。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-340">-The second input that had no matches in the first input.</span></span><br /><br /> <br /><br /> <span data-ttu-id="c4cd0-341">一致する値がない入力は NULL 値として返されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-341">The input that does not contain the matching values is returned as a null value.</span></span> <span data-ttu-id="c4cd0-342">`Full Outer Join` は論理操作です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-342">`Full Outer Join` is a logical operator.</span></span>|  
|<span data-ttu-id="c4cd0-343">![Gather Streams 並列処理操作アイコン](../../2014/database-engine/media/parallelism-32x.gif "Gather Streams 並列処理操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-343">![Gather streams parallelism operator icon](../../2014/database-engine/media/parallelism-32x.gif "Gather streams parallelism operator icon")</span></span>|<span data-ttu-id="c4cd0-344">**Gather Streams**</span><span class="sxs-lookup"><span data-stu-id="c4cd0-344">**Gather Streams**</span></span>|<span data-ttu-id="c4cd0-345">**Gather Streams** 操作は、並列クエリ プランでのみ使用されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-345">The **Gather Streams** operator is only used in parallel query plans.</span></span> <span data-ttu-id="c4cd0-346">**Gather Streams** 操作は複数の入力ストリームを使用し、入力ストリームを組み合わせてレコードの単一出力ストリームを作成します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-346">The **Gather Streams** operator consumes several input streams and produces a single output stream of records by combining the input streams.</span></span> <span data-ttu-id="c4cd0-347">レコードの内容と形式は変更されません。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-347">The record contents and format are not changed.</span></span> <span data-ttu-id="c4cd0-348">この操作で順序を保持する場合は、すべての入力ストリームが並べ替えられている必要があります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-348">If this operator is order preserving, all input streams must be ordered.</span></span> <span data-ttu-id="c4cd0-349">出力が順序付けされている場合、この列には `Argument` ORDER BY:() 述語と順序付けされている列の名前が含まれます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-349">If the output is ordered, the `Argument` column contains an ORDER BY:() predicate and the names of columns being ordered.</span></span> <span data-ttu-id="c4cd0-350">**Gather Streams** は論理操作です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-350">**Gather Streams** is a logical operator.</span></span>|  
|<span data-ttu-id="c4cd0-351">![Hash Match 操作アイコン](../../2014/database-engine/media/hash-match-32x.gif "Hash Match 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-351">![Hash match operator icon](../../2014/database-engine/media/hash-match-32x.gif "Hash match operator icon")</span></span>|`Hash Match`|<span data-ttu-id="c4cd0-352">`Hash Match` 操作は、ビルド入力の行ごとにハッシュ値を計算してハッシュ テーブルを作成します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-352">The `Hash Match` operator builds a hash table by computing a hash value for each row from its build input.</span></span> <span data-ttu-id="c4cd0-353">ハッシュ値の作成に使用される列の一覧を含む HASH:() 述語が列に表示され `Argument` ます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-353">A HASH:() predicate with a list of columns used to create a hash value appears in the `Argument` column.</span></span> <span data-ttu-id="c4cd0-354">次に、該当するプローブ行ごとに同じハッシュ関数を使用してハッシュ値が計算され、ハッシュ テーブル内で一致検索が行われます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-354">Then, for each probe row (as applicable), it computes a hash value (using the same hash function) and looks in the hash table for matches.</span></span> <span data-ttu-id="c4cd0-355">残余述語が存在する場合 (列の残余:() によって識別され `Argument` ます)、行が一致と見なされるためにもその述語が満たされている必要があります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-355">If a residual predicate is present (identified by RESIDUAL:() in the `Argument` column), that predicate must also be satisfied for rows to be considered a match.</span></span> <span data-ttu-id="c4cd0-356">動作は、次に示すように、実行している論理操作によって異なります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-356">Behavior depends on the logical operation being performed:</span></span><br /><br /> <span data-ttu-id="c4cd0-357">すべての結合では、最初 (上部) の入力を使用してハッシュ テーブルを作成し、2 番目 (下部) の入力を使用してハッシュ テーブルを探索します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-357">For any joins, use the first (top) input to build the hash table and the second (bottom) input to probe the hash table.</span></span> <span data-ttu-id="c4cd0-358">出力は、結合の種類で指定されているとおりに一致します (または一致しません)。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-358">Output matches (or nonmatches) as dictated by the join type.</span></span> <span data-ttu-id="c4cd0-359">複数の結合が同じ結合列を使用する場合、これらの操作はハッシュ チームにグループ化されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-359">If multiple joins use the same join column, these operations are grouped into a hash team.</span></span><br /><br /> <span data-ttu-id="c4cd0-360">Distinct 操作または Aggregate 操作の場合、入力を使用してハッシュ テーブルを作成します (重複部分を削除し、集計式を計算します)。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-360">For the distinct or aggregate operators, use the input to build the hash table (removing duplicates and computing any aggregate expressions).</span></span> <span data-ttu-id="c4cd0-361">ハッシュ テーブルを作成したら、テーブルをスキャンしすべてのエントリを出力します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-361">When the hash table is built, scan the table and output all entries.</span></span><br /><br /> <span data-ttu-id="c4cd0-362">Union 操作の場合、最初の入力を使用してハッシュ テーブルを作成します (重複部分は削除します)。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-362">For the union operator, use the first input to build the hash table (removing duplicates).</span></span> <span data-ttu-id="c4cd0-363">2 番目の入力 (重複部分はありません) を使用して、ハッシュ テーブルを探索して一致しないすべての行を返します。次に、ハッシュ テーブルをスキャンし、すべてのエントリを返します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-363">Use the second input (which must have no duplicates) to probe the hash table, returning all rows that have no matches, then scan the hash table and return all entries.</span></span><br /><br /> <br /><br /> <span data-ttu-id="c4cd0-364">`Hash Match` は物理操作です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-364">`Hash Match` is a physical operator.</span></span>|  
|<span data-ttu-id="c4cd0-365">![If 言語要素アイコン](../../2014/database-engine/media/if-32x.gif "If 言語要素アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-365">![If language element icon](../../2014/database-engine/media/if-32x.gif "If language element icon")</span></span>|`If`|<span data-ttu-id="c4cd0-366">`If` 操作では、式に基づく条件処理を実行します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-366">The `If` operator carries out conditional processing based on an expression.</span></span> <span data-ttu-id="c4cd0-367">`If` は言語要素です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-367">`If` is a language element.</span></span>|  
|<span data-ttu-id="c4cd0-368">なし</span><span class="sxs-lookup"><span data-stu-id="c4cd0-368">None</span></span>|`Inner Join`|<span data-ttu-id="c4cd0-369">`Inner Join` 論理操作は、最初 (上部) の入力と 2 番目 (下部) の入力の結合に適合する各行を返します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-369">The `Inner Join` logical operator returns each row that satisfies the join of the first (top) input with the second (bottom) input.</span></span>|  
|<span data-ttu-id="c4cd0-370">![Insert (データベース エンジン) 操作アイコン](../../2014/database-engine/media/insert-32x.gif "Insert (データベース エンジン) 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-370">![Insert (Database Engine) operator icon](../../2014/database-engine/media/insert-32x.gif "Insert (Database Engine) operator icon")</span></span>|`Insert`|<span data-ttu-id="c4cd0-371">`Insert`論理操作は、列に指定されたオブジェクトに入力から各行を挿入し `Argument` ます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-371">The `Insert` logical operator inserts each row from its input into the object specified in the `Argument` column.</span></span> <span data-ttu-id="c4cd0-372">物理操作は、`Table Insert` 操作、`Index Insert` 操作、または `Clustered Index Insert` 操作のいずれかです。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-372">The physical operator is either the `Table Insert`, `Index Insert`, or `Clustered Index Insert` operator.</span></span>|  
|<span data-ttu-id="c4cd0-373">![Inserted Scan 操作アイコン](../../2014/database-engine/media/inserted-scan-32x.gif "Inserted Scan 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-373">![Inserted scan operator icon](../../2014/database-engine/media/inserted-scan-32x.gif "Inserted scan operator icon")</span></span>|<span data-ttu-id="c4cd0-374">**Inserted Scan**</span><span class="sxs-lookup"><span data-stu-id="c4cd0-374">**Inserted Scan**</span></span>|<span data-ttu-id="c4cd0-375">**Inserted Scan** 操作は、 **inserted** テーブルをスキャンします。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-375">The **Inserted Scan** operator scans the **inserted** table.</span></span> <span data-ttu-id="c4cd0-376">**Inserted Scan** 操作は論理操作でもあり、物理操作でもあります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-376">**Inserted Scan** is a logical and physical operator.</span></span>|  
|<span data-ttu-id="c4cd0-377">![Intrinsic 言語要素アイコン](../../2014/database-engine/media/intrinsic-32x.gif "Intrinsic 言語要素アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-377">![Intrinsic language element icon](../../2014/database-engine/media/intrinsic-32x.gif "Intrinsic language element icon")</span></span>|`Intrinsic`|<span data-ttu-id="c4cd0-378">`Intrinsic` 操作では、内部 [!INCLUDE[tsql](../includes/tsql-md.md)] 関数が呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-378">The `Intrinsic` operator invokes an internal [!INCLUDE[tsql](../includes/tsql-md.md)] function.</span></span> <span data-ttu-id="c4cd0-379">`Intrinsic` は言語要素です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-379">`Intrinsic` is a language element.</span></span>|  
|<span data-ttu-id="c4cd0-380">![Iterator Catchall 操作アイコン](../../2014/database-engine/media/iterator-catch-all.gif "Iterator Catchall 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-380">![Iterator catchall operator icon](../../2014/database-engine/media/iterator-catch-all.gif "Iterator catchall operator icon")</span></span>|`Iterator`|<span data-ttu-id="c4cd0-381">`Iterator` 汎用アイコンは、グラフィカルなプラン表示を生成するロジックで、反復子に適したアイコンが見つからない場合に表示されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-381">The `Iterator` catchall icon is displayed when a suitable icon for the iterator cannot be found by the logic that produces graphical Showplans.</span></span> <span data-ttu-id="c4cd0-382">汎用アイコンは、必ずしもエラー状態を示しているわけではありません。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-382">The catchall icon does not necessarily indicate an error condition.</span></span> <span data-ttu-id="c4cd0-383">汎用アイコンには、青 (反復子)、オレンジ (カーソル)、緑 ( [!INCLUDE[tsql](../includes/tsql-md.md)] 言語コンストラクト) の 3 種類があります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-383">There are three catchall icons: blue (for iterators), orange (for cursors), and green (for [!INCLUDE[tsql](../includes/tsql-md.md)] language constructs).</span></span>|  
|<span data-ttu-id="c4cd0-384">![Bookmark Lookup 操作アイコン](../../2014/database-engine/media/bookmark-lookup-32x.gif "Bookmark Lookup 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-384">![Bookmark lookup operator icon](../../2014/database-engine/media/bookmark-lookup-32x.gif "Bookmark lookup operator icon")</span></span>|`Key Lookup`|<span data-ttu-id="c4cd0-385">`Key Lookup`演算子は、クラスター化インデックスを持つテーブルのブックマーク参照です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-385">The `Key Lookup` operator is a bookmark lookup on a table with a clustered index.</span></span> <span data-ttu-id="c4cd0-386">この列には、クラスター化インデックス `Argument` の名前と、クラスター化インデックスの行を検索するために使用されるクラスター化キーが含まれています。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-386">The `Argument` column contains the name of the clustered index and the clustering key used to look up the row in the clustered index.</span></span> <span data-ttu-id="c4cd0-387">`Key Lookup`常に演算子を伴い `Nested Loops` ます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-387">`Key Lookup` is always accompanied by a `Nested Loops` operator.</span></span> <span data-ttu-id="c4cd0-388">列に WITH プリフェッチ句がある場合 `Argument` 、クエリプロセッサは、クラスター化インデックスでブックマークを検索するときに、非同期プリフェッチ (先行読み取り) を使用することが最適であると判断しました。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-388">If the WITH PREFETCH clause appears in the `Argument` column, the query processor has determined that it is optimal to use asynchronous prefetching (read-ahead) when looking up bookmarks in the clustered index.</span></span><br /><br /> <span data-ttu-id="c4cd0-389">クエリプランで演算子を使用することは、 `Key Lookup` クエリがパフォーマンスチューニングの恩恵を受ける可能性があることを示しています。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-389">The use of a `Key Lookup` operator in a query plan indicates that the query might benefit from performance tuning.</span></span> <span data-ttu-id="c4cd0-390">たとえば、カバリング インデックスを追加することにより、クエリ パフォーマンスが向上する場合があります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-390">For example, query performance might be improved by adding a covering index.</span></span>|  
|<span data-ttu-id="c4cd0-391">![Keyset カーソル操作アイコン](../../2014/database-engine/media/keyset-32x.gif "Keyset カーソル操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-391">![Keyset cursor operator icon](../../2014/database-engine/media/keyset-32x.gif "Keyset cursor operator icon")</span></span>|`Keyset`|<span data-ttu-id="c4cd0-392">`Keyset` 操作では、カーソルを使用して更新内容を参照できます。ただし、他のユーザーが挿入した内容は参照できません。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-392">The `Keyset` operator uses a cursor that can see updates, but not inserts made by others.</span></span>|  
|<span data-ttu-id="c4cd0-393">![言語要素の汎用アイコン](../../2014/database-engine/media/language-construct-catch-all.gif "言語要素の汎用アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-393">![Language element catchall icon](../../2014/database-engine/media/language-construct-catch-all.gif "Language element catchall icon")</span></span>|`Language Element`|<span data-ttu-id="c4cd0-394">`Language Element` 汎用アイコンは、グラフィカルなプラン表示を生成するロジックで、反復子に適したアイコンが見つからない場合に表示されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-394">The `Language Element` catchall icon is displayed when a suitable icon for the iterator cannot be found by the logic that produces graphical Showplans.</span></span> <span data-ttu-id="c4cd0-395">汎用アイコンは、必ずしもエラー状態を示しているわけではありません。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-395">The catchall icon does not necessarily indicate an error condition.</span></span> <span data-ttu-id="c4cd0-396">汎用アイコンには、青 (反復子)、オレンジ (カーソル)、緑 ( [!INCLUDE[tsql](../includes/tsql-md.md)] 言語コンストラクト) の 3 種類があります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-396">There are three catchall icons: blue (for iterators), orange (for cursors), and green (for [!INCLUDE[tsql](../includes/tsql-md.md)] language constructs).</span></span>|  
|<span data-ttu-id="c4cd0-397">![Spool 操作アイコン](../../2014/database-engine/media/spool-32x.gif "Spool 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-397">![Spool operator icon](../../2014/database-engine/media/spool-32x.gif "Spool operator icon")</span></span>|<span data-ttu-id="c4cd0-398">**Lazy Spool**</span><span class="sxs-lookup"><span data-stu-id="c4cd0-398">**Lazy Spool**</span></span>|<span data-ttu-id="c4cd0-399">**Lazy Spool**論理操作は、データベースに格納されている非表示の一時オブジェクトに入力から各行を格納し `tempdb` ます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-399">The **Lazy Spool** logical operator stores each row from its input in a hidden temporary object stored in the `tempdb` database.</span></span> <span data-ttu-id="c4cd0-400">演算子が巻き戻し (たとえば、演算子によって) されていても、再バインドが不要な場合は、入力を再 `Nested Loops` スキャンする代わりにスプールされたデータが使用されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-400">If the operator is rewound (for example, by a `Nested Loops` operator) but no rebinding is needed, the spooled data is used instead of rescanning the input.</span></span> <span data-ttu-id="c4cd0-401">再バインドが必要な場合は、スプールされたデータが破棄され、(再バインドされる) 入力の再スキャンによりスプール オブジェクトが再構築されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-401">If rebinding is needed, the spooled data is discarded and the spool object is rebuilt by rescanning the (rebound) input.</span></span> <span data-ttu-id="c4cd0-402">**Lazy Spool** 操作のスプール ファイルは "レイジー" 手法で構築されます。つまり、1 回にすべての行を処理するのではなく、スプールの親操作から行が要求されるたびに入力操作から行を取得し、その行をスプールに格納します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-402">The **Lazy Spool** operator builds its spool file in a "lazy" manner, that is, each time the spool's parent operator asks for a row, the spool operator gets a row from its input operator and stores it in the spool, rather than consuming all rows at once.</span></span> <span data-ttu-id="c4cd0-403">Lazy Spool は論理操作です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-403">Lazy Spool is a logical operator.</span></span>|  
|<span data-ttu-id="c4cd0-404">なし</span><span class="sxs-lookup"><span data-stu-id="c4cd0-404">None</span></span>|`Left Anti Semi Join`|<span data-ttu-id="c4cd0-405">`Left Anti Semi Join` 操作は、最初 (上部) の入力の中に 2 番目 (下部) の入力に一致する行がない場合に該当する行を返します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-405">The `Left Anti Semi Join` operator returns each row from the first (top) input when there is no matching row in the second (bottom) input.</span></span> <span data-ttu-id="c4cd0-406">列に結合述語が存在しない場合は `Argument` 、各行が一致する行になります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-406">If no join predicate exists in the `Argument` column, each row is a matching row.</span></span> <span data-ttu-id="c4cd0-407">`Left Anti Semi Join` は論理操作です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-407">`Left Anti Semi Join` is a logical operator.</span></span>|  
|<span data-ttu-id="c4cd0-408">なし</span><span class="sxs-lookup"><span data-stu-id="c4cd0-408">None</span></span>|`Left Outer Join`|<span data-ttu-id="c4cd0-409">`Left Outer Join` 操作は、最初 (上部) の入力と 2 番目 (下部) の入力の結合に適合する各行を返します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-409">The `Left Outer Join` operator returns each row that satisfies the join of the first (top) input with the second (bottom) input.</span></span> <span data-ttu-id="c4cd0-410">また、最初 (上部) の入力の中で 2 番目 (下部) の入力に一致する行がない行も返します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-410">It also returns any rows from the first input that had no matching rows in the second input.</span></span> <span data-ttu-id="c4cd0-411">2 番目の入力の一致しない行は NULL 値として返されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-411">The nonmatching rows in the second input are returned as null values.</span></span> <span data-ttu-id="c4cd0-412">列に結合述語が存在しない場合は `Argument` 、各行が一致する行になります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-412">If no join predicate exists in the `Argument` column, each row is a matching row.</span></span> <span data-ttu-id="c4cd0-413">`Left Outer Join` は論理操作です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-413">`Left Outer Join` is a logical operator.</span></span>|  
|<span data-ttu-id="c4cd0-414">なし</span><span class="sxs-lookup"><span data-stu-id="c4cd0-414">None</span></span>|`Left Semi Join`|<span data-ttu-id="c4cd0-415">`Left Semi Join` 操作は、最初 (上部) の入力の中に 2 番目 (下部) の入力に一致する行がある場合に該当する行を返します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-415">The `Left Semi Join` operator returns each row from the first (top) input when there is a matching row in the second (bottom) input.</span></span> <span data-ttu-id="c4cd0-416">列に結合述語が存在しない場合は `Argument` 、各行が一致する行になります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-416">If no join predicate exists in the `Argument` column, each row is a matching row.</span></span> <span data-ttu-id="c4cd0-417">`Left Semi Join` は論理操作です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-417">`Left Semi Join` is a logical operator.</span></span>|  
|<span data-ttu-id="c4cd0-418">![Log Row Scan 操作アイコン](../../2014/database-engine/media/log-row-scan-32x.gif "Log Row Scan 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-418">![Log row scan operator icon](../../2014/database-engine/media/log-row-scan-32x.gif "Log row scan operator icon")</span></span>|`Log Row Scan`|<span data-ttu-id="c4cd0-419">`Log Row Scan` 操作は、トランザクション ログをスキャンします。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-419">The `Log Row Scan` operator scans the transaction log.</span></span> <span data-ttu-id="c4cd0-420">`Log Row Scan` は論理操作でもあり、物理操作でもあります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-420">`Log Row Scan` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="c4cd0-421">![Merge Interval 操作アイコン](../../2014/database-engine/media/merge-interval-32x.gif "Merge Interval 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-421">![Merge interval operator icon](../../2014/database-engine/media/merge-interval-32x.gif "Merge interval operator icon")</span></span>|`Merge Interval`|<span data-ttu-id="c4cd0-422">`Merge Interval` 操作は、重複している可能性のある複数の間隔をマージして、重複しない最小限の間隔を作成します。この間隔は、インデックス エントリのシークに使用されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-422">The `Merge Interval` operator merges multiple (potentially overlapping) intervals to produce minimal, nonoverlapping intervals that are then used to seek index entries.</span></span> <span data-ttu-id="c4cd0-423">通常、この演算子は、演算子を介して1つ以上の演算子の上に表示され `Compute Scalar` `Constant Scan` ます。この演算子は、この演算子がマージする間隔 (行内の列として表される) を構築します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-423">This operator typically appears above one or more `Compute Scalar` operators over `Constant Scan` operators, which construct the intervals (represented as columns in a row) that this operator merges.</span></span> <span data-ttu-id="c4cd0-424">`Merge Interval` は論理操作でもあり、物理操作でもあります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-424">`Merge Interval` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="c4cd0-425">![Merge Join 操作アイコン](../../2014/database-engine/media/merge-join-32x.gif "Merge Join 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-425">![Merge join operator icon](../../2014/database-engine/media/merge-join-32x.gif "Merge join operator icon")</span></span>|<span data-ttu-id="c4cd0-426">**マージ結合**</span><span class="sxs-lookup"><span data-stu-id="c4cd0-426">**Merge Join**</span></span>|<span data-ttu-id="c4cd0-427">**Merge Join** 操作は Inner Join、Left Outer Join、Left Semi Join、Left Anti Semi Join、Right Outer Join、Right Semi Join、Right Anti Semi Join、Union の各論理操作を実行します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-427">The **Merge Join** operator performs the inner join, left outer join, left semi join, left anti semi join, right outer join, right semi join, right anti semi join, and union logical operations.</span></span><br /><br /> <span data-ttu-id="c4cd0-428">この列では、 `Argument` **マージ結合**演算子に merge:() 述語が含まれています。操作が一対多の結合を実行している場合、または操作が多対多の結合を実行している場合は多対多の merge:() 述語を含みます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-428">In the `Argument` column, the **Merge Join** operator contains a MERGE:() predicate if the operation is performing a one-to-many join, or a MANY-TO-MANY MERGE:() predicate if the operation is performing a many-to-many join.</span></span> <span data-ttu-id="c4cd0-429">この列には、 `Argument` 操作の実行に使用される列のコンマ区切りの一覧も含まれています。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-429">The `Argument` column also includes a comma-separated list of columns used to perform the operation.</span></span> <span data-ttu-id="c4cd0-430">**Merge Join** 操作には、それぞれの列を基準に並べ替えられた 2 つの入力が必要です。この並べ替えを行うときは、クエリ プランに明示的な並べ替え操作を挿入することが可能です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-430">The **Merge Join** operator requires two inputs sorted on their respective columns, possibly by inserting explicit sort operations into the query plan.</span></span> <span data-ttu-id="c4cd0-431">明示的な並べ替えが必要でない場合、Merge Join 操作は特に効果的です。たとえば、データベースに適切な B ツリー インデックスがある場合、またはマージ結合とロール アップを含むグループ化など、複数の操作で並べ替え順序を利用できる場合などです。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-431">Merge join is particularly effective if explicit sorting is not required, for example, if there is a suitable B-tree index in the database or if the sort order can be exploited for multiple operations, such as a merge join and grouping with roll up.</span></span> <span data-ttu-id="c4cd0-432">**Merge Join** は物理操作です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-432">**Merge Join** is a physical operator.</span></span>|  
|<span data-ttu-id="c4cd0-433">![Nested Loops 操作アイコン](../../2014/database-engine/media/nested-loops-32x.gif "Nested Loops 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-433">![Nested loops operator icon](../../2014/database-engine/media/nested-loops-32x.gif "Nested loops operator icon")</span></span>|`Nested Loops`|<span data-ttu-id="c4cd0-434">`Nested Loops` 操作は、内部結合、左外部結合、左半結合、左反半結合の各論理操作を実行します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-434">The `Nested Loops` operator performs the inner join, left outer join, left semi join, and left anti semi join logical operations.</span></span> <span data-ttu-id="c4cd0-435">ネステッド ループ結合では、外部テーブルの行ごとに内部テーブルが検索されます。検索には、通常はインデックスが使用されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-435">Nested loops joins perform a search on the inner table for each row of the outer table, typically using an index.</span></span> <span data-ttu-id="c4cd0-436">クエリ プロセッサにより、予想コストに基づいて、内部入力でインデックスを検索する場所の絞り込みを向上するために、外部入力を並べ替えるかどうかが判断されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-436">The query processor decides, based on anticipated costs, whether to sort the outer input in order to improve locality of the searches on the index over the inner input.</span></span> <span data-ttu-id="c4cd0-437">列の (省略可能な) 述語を満たす行 `Argument` は、実行されている論理操作に基づいて、該当するものとして返されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-437">Any rows that satisfy the (optional) predicate in the `Argument` column are returned as applicable, based on the logical operation being performed.</span></span> <span data-ttu-id="c4cd0-438">`Nested Loops` は物理操作です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-438">`Nested Loops` is a physical operator.</span></span>|  
|<span data-ttu-id="c4cd0-439">![Nonclustered Index Delete 操作アイコン](../../2014/database-engine/media/nonclust-index-delete-32x.gif "Nonclustered Index Delete 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-439">![Nonclustered index delete operator icon](../../2014/database-engine/media/nonclust-index-delete-32x.gif "Nonclustered index delete operator icon")</span></span>|`Nonclustered Index Delete`|<span data-ttu-id="c4cd0-440">操作は、 `Nonclustered Index Delete` 列に指定された非クラスター化インデックスから入力行を削除し `Argument` ます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-440">The `Nonclustered Index Delete` operator deletes input rows from the nonclustered index specified in the `Argument` column.</span></span> <span data-ttu-id="c4cd0-441">`Nonclustered Index Delete` は物理操作です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-441">`Nonclustered Index Delete` is a physical operator.</span></span>|  
|<span data-ttu-id="c4cd0-442">![Nonclustered Index Insert 操作アイコン](../../2014/database-engine/media/nonclust-index-insert-32x.gif "Nonclustered Index Insert 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-442">![Nonclustered index insert operator icon](../../2014/database-engine/media/nonclust-index-insert-32x.gif "Nonclustered index insert operator icon")</span></span>|`Index Insert`|<span data-ttu-id="c4cd0-443">操作は、 `Index Insert` 列に指定された非クラスター化インデックスに、入力からの行を挿入し `Argument` ます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-443">The `Index Insert` operator inserts rows from its input into the nonclustered index specified in the `Argument` column.</span></span> <span data-ttu-id="c4cd0-444">また、`Argument` 列には、各列に設定する値を示す SET:() 述語も含まれます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-444">The `Argument` column also contains a SET:() predicate, which indicates the value to which each column is set.</span></span> <span data-ttu-id="c4cd0-445">`Index Insert` は物理操作です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-445">`Index Insert` is a physical operator.</span></span>|  
|<span data-ttu-id="c4cd0-446">![Nonclustered Index Scan 操作アイコン](../../2014/database-engine/media/nonclustered-index-scan-32x.gif "Nonclustered Index Scan 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-446">![Nonclustered index scan operator icon](../../2014/database-engine/media/nonclustered-index-scan-32x.gif "Nonclustered index scan operator icon")</span></span>|`Index Scan`|<span data-ttu-id="c4cd0-447">演算子は、 `Index Scan` 列に指定された非クラスター化インデックスからすべての行を取得し `Argument` ます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-447">The `Index Scan` operator retrieves all rows from the nonclustered index specified in the `Argument` column.</span></span> <span data-ttu-id="c4cd0-448">列にオプションの WHERE:() 述語がある場合 `Argument` 、その述語に適合する行だけが返されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-448">If an optional WHERE:() predicate appears in the `Argument` column, only those rows that satisfy the predicate are returned.</span></span> <span data-ttu-id="c4cd0-449">`Index Scan` は論理操作でもあり、物理操作でもあります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-449">`Index Scan` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="c4cd0-450">![Nonclustered Index Seek 操作アイコン](../../2014/database-engine/media/index-seek-32x.gif "Nonclustered Index Seek 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-450">![Nonclustered index seek operator icon](../../2014/database-engine/media/index-seek-32x.gif "Nonclustered index seek operator icon")</span></span>|`Index Seek`|<span data-ttu-id="c4cd0-451">`Index Seek` 操作は、インデックスのシーク機能を使用して非クラスター化インデックスから行を取得します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-451">The `Index Seek` operator uses the seeking ability of indexes to retrieve rows from a nonclustered index.</span></span> <span data-ttu-id="c4cd0-452">列には、使用され `Argument` ている非クラスター化インデックスの名前が含まれます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-452">The `Argument` column contains the name of the nonclustered index being used.</span></span> <span data-ttu-id="c4cd0-453">また、SEEK:() 述語も含まれます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-453">It also contains the SEEK:() predicate.</span></span> <span data-ttu-id="c4cd0-454">ストレージ エンジンはインデックスを使用して、SEEK:() 述語に適合する行だけを処理します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-454">The storage engine uses the index to process only those rows that satisfy the SEEK:() predicate.</span></span> <span data-ttu-id="c4cd0-455">必要に応じて、この列には WHERE:() 述語が含まれることがあります。この述語は、ストレージ エンジンによって SEEK:() 述語に適合するすべての行に対して評価されます (この処理を行うのにインデックスは使用されません)。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-455">It optionally may include a WHERE:() predicate, which the storage engine will evaluate against all rows that satisfy the SEEK:() predicate (it does not use the indexes to do this).</span></span> <span data-ttu-id="c4cd0-456">列に `Argument` ORDERED 句が含まれている場合、クエリプロセッサは、非クラスター化インデックスが並べ替えられた順序で行を返す必要があると判断しました。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-456">If the `Argument` column contains the ORDERED clause, the query processor has determined that the rows must be returned in the order in which the nonclustered index has sorted them.</span></span> <span data-ttu-id="c4cd0-457">ORDERED 句がない場合は、ストレージ エンジンにより、最適な方法でインデックスが検索されます (出力が並べ替えられるとは限りません)。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-457">If the ORDERED clause is not present, the storage engine searches the index in the optimal way (which does not guarantee that the output will be sorted).</span></span> <span data-ttu-id="c4cd0-458">出力順序が保持されるようにすると、並べ替えずに出力する場合よりも効率が低下する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-458">Allowing the output to retain its ordering may be less efficient than producing nonsorted output.</span></span> <span data-ttu-id="c4cd0-459">`Index Seek` は論理操作でもあり、物理操作でもあります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-459">`Index Seek` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="c4cd0-460">![Nonclustered Index Spool 操作アイコン](../../2014/database-engine/media/index-spool-32x.gif "Nonclustered Index Spool 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-460">![Nonclustered index spool operator icon](../../2014/database-engine/media/index-spool-32x.gif "Nonclustered index spool operator icon")</span></span>|<span data-ttu-id="c4cd0-461">**Index Spool**</span><span class="sxs-lookup"><span data-stu-id="c4cd0-461">**Index Spool**</span></span>|<span data-ttu-id="c4cd0-462">**Index Spool**物理操作には、列に SEEK:() 述語が含まれてい `Argument` ます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-462">The **Index Spool** physical operator contains a SEEK:() predicate in the `Argument` column.</span></span> <span data-ttu-id="c4cd0-463">**Index Spool**操作は、入力行をスキャンし、隠しスプールファイル (データベースに格納され、 `tempdb` クエリの有効期間だけ存在する) に各行のコピーを配置し、行に非クラスター化インデックスを作成します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-463">The **Index Spool** operator scans its input rows, placing a copy of each row in a hidden spool file (stored in the `tempdb` database and existing only for the lifetime of the query), and builds a nonclustered index on the rows.</span></span> <span data-ttu-id="c4cd0-464">さらに、インデックスのシーク機能を使用して、SEEK:() 述語に適合する行だけを出力します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-464">This allows you to use the seeking capability of indexes to output only those rows that satisfy the SEEK:() predicate.</span></span> <span data-ttu-id="c4cd0-465">演算子が巻き戻し (たとえば、演算子によって) されていても、再バインドが不要な場合は、入力を再 `Nested Loops` スキャンする代わりにスプールされたデータが使用されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-465">If the operator is rewound (for example, by a `Nested Loops` operator) but no rebinding is needed, the spooled data is used instead of rescanning the input.</span></span>|  
|<span data-ttu-id="c4cd0-466">![Nonclustered Index Update 操作アイコン](../../2014/database-engine/media/nonclust-index-update-32x.gif "Nonclustered Index Update 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-466">![Nonclustered index update operator icon](../../2014/database-engine/media/nonclust-index-update-32x.gif "Nonclustered index update operator icon")</span></span>|`Nonclustered Index Update`|<span data-ttu-id="c4cd0-467">`Nonclustered Index Update`物理操作は、列に指定された非クラスター化インデックスの入力から行を更新し `Argument` ます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-467">The `Nonclustered Index Update` physical operator updates rows from its input in the nonclustered index specified in the `Argument` column.</span></span> <span data-ttu-id="c4cd0-468">SET:() 述語がある場合、更新される各列がこの値に設定されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-468">If a SET:() predicate is present, each updated column is set to this value.</span></span> <span data-ttu-id="c4cd0-469">`Nonclustered Index Update` は物理操作です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-469">`Nonclustered Index Update` is a physical operator.</span></span>|  
|<span data-ttu-id="c4cd0-470">![Online Index Insert 操作アイコン](../../2014/database-engine/media/online-index-32x.gif "Online Index Insert 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-470">![Online index insert operator icon](../../2014/database-engine/media/online-index-32x.gif "Online index insert operator icon")</span></span>|<span data-ttu-id="c4cd0-471">**Online Index Insert**</span><span class="sxs-lookup"><span data-stu-id="c4cd0-471">**Online Index Insert**</span></span>|<span data-ttu-id="c4cd0-472">**Online Index Insert** 物理操作は、インデックスの作成操作、変更操作、または削除操作がオンラインで実行されることを示します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-472">The **Online Index Insert** physical operator indicates that an index create, alter, or drop operation is performed online.</span></span> <span data-ttu-id="c4cd0-473">つまり、インデックス操作の実行中に、基になるテーブル データをユーザーが利用することができます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-473">That is, the underlying table data remains available to users during the index operation.</span></span>|  
|<span data-ttu-id="c4cd0-474">なし</span><span class="sxs-lookup"><span data-stu-id="c4cd0-474">None</span></span>|`Parallelism`|<span data-ttu-id="c4cd0-475">操作は、ストリームの `Parallelism` 分散、収集ストリーム、および再パーティション分割の論理操作を実行します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-475">The `Parallelism` operator performs the distribute streams, gather streams, and repartition streams logical operations.</span></span> <span data-ttu-id="c4cd0-476">列には、 `Argument` パーティション分割される列のコンマ区切りリストを使用して、PARTITION columns:() 述語を含めることができます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-476">The `Argument` columns can contain a PARTITION COLUMNS:() predicate with a comma-separated list of the columns being partitioned.</span></span> <span data-ttu-id="c4cd0-477">`Argument`列に ORDER BY:() 述語を含めることもできます。これは、パーティション分割中の並べ替え順序を保持するための列の一覧です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-477">The `Argument` columns can also contain an ORDER BY:() predicate, listing the columns to preserve the sort order for during partitioning.</span></span> <span data-ttu-id="c4cd0-478">`Parallelism` は物理操作です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-478">`Parallelism` is a physical operator.</span></span><br /><br /> <span data-ttu-id="c4cd0-479">注: クエリが並列クエリとしてコンパイルされている場合、実行時にはシリアルクエリとして実行されますが、SET STATISTICS XML またはの [**実際の実行プランを含める**] オプションを使用して生成された Showplan 出力には、 [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)] `RunTimeInformation` 演算子の要素が含まれません `Parallelism` 。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-479">Note: If a query has been compiled as a parallel query, but at run time it is run as a serial query, the Showplan output generated by SET STATISTICS XML or by using the **Include Actual Execution Plan** option in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)] will not contain the `RunTimeInformation` element for the `Parallelism` operator.</span></span> <span data-ttu-id="c4cd0-480">SET STATISTICS PROFILE の出力では、実際の行数と実際の実行数によって、演算子の0が表示され `Parallelism` ます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-480">In SET STATISTICS PROFILE output, the actual row counts and actual number of executes will display zeroes for the `Parallelism` operator.</span></span> <span data-ttu-id="c4cd0-481">いずれかの条件が発生した場合、演算子は、 `Parallelism` 実行時のクエリプランではなく、クエリのコンパイル中にのみ使用されたことを意味します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-481">When either condition occurs, it means that the `Parallelism` operator was only used during query compilation and not in the run-time query plan.</span></span> <span data-ttu-id="c4cd0-482">サーバー上での同時実行の負荷が高い場合は、並列クエリ プランが直列に実行されることがあります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-482">Note that sometimes parallel query plans are run in serial if there is a high concurrent load on the server.</span></span>|  
|<span data-ttu-id="c4cd0-483">![Parameter Table Scan 操作アイコン](../../2014/database-engine/media/parameter-table-scan-32x.gif "Parameter Table Scan 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-483">![Parameter table scan operator icon](../../2014/database-engine/media/parameter-table-scan-32x.gif "Parameter table scan operator icon")</span></span>|`Parameter Table Scan`|<span data-ttu-id="c4cd0-484">`Parameter Table Scan` 操作により、現在のクエリのパラメーターとして機能しているテーブルをスキャンします。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-484">The `Parameter Table Scan` operator scans a table that is acting as a parameter in the current query.</span></span> <span data-ttu-id="c4cd0-485">通常、この操作は、ストアド プロシージャ内の INSERT クエリに対して使用されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-485">Typically, this is used for INSERT queries within a stored procedure.</span></span> <span data-ttu-id="c4cd0-486">`Parameter Table Scan` は論理操作でもあり、物理操作でもあります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-486">`Parameter Table Scan` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="c4cd0-487">なし</span><span class="sxs-lookup"><span data-stu-id="c4cd0-487">None</span></span>|<span data-ttu-id="c4cd0-488">**Partial Aggregate**</span><span class="sxs-lookup"><span data-stu-id="c4cd0-488">**Partial Aggregate**</span></span>|<span data-ttu-id="c4cd0-489">**Partial Aggregate** は、並列プランで使用されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-489">**Partial Aggregate** is used in parallel plans.</span></span> <span data-ttu-id="c4cd0-490">ディスクへの書き込み ("スピル" と呼ばれます) が必要にならないように、できるだけ多くの入力行に集計関数が適用されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-490">It applies an aggregation function to as many input rows as possible so that writing to disk (known as a "spill") is not necessary.</span></span> <span data-ttu-id="c4cd0-491">`Hash Match`は、パーティションの集計を実装する唯一の物理操作 (iterator) です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-491">`Hash Match` is the only physical operator (iterator) that implements partition aggregation.</span></span> <span data-ttu-id="c4cd0-492">**Partial Aggregate** は論理操作です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-492">**Partial Aggregate** is a logical operator.</span></span>|  
|<span data-ttu-id="c4cd0-493">![Population Query カーソル操作アイコン](../../2014/database-engine/media/poulation-query-32x.gif "Population Query カーソル操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-493">![Population query cursor operator icon](../../2014/database-engine/media/poulation-query-32x.gif "Population query cursor operator icon")</span></span>|`Population Query`|<span data-ttu-id="c4cd0-494">`Population Query` 操作によって、カーソルが開かれたときにカーソルの作業テーブルを作成します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-494">The `Population Query` operator populates the work table of a cursor when the cursor is opened.</span></span>|  
|<span data-ttu-id="c4cd0-495">![Refresh Query カーソル操作アイコン](../../2014/database-engine/media/refresh-query-32x.gif "Refresh Query カーソル操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-495">![Refresh query cursor operator icon](../../2014/database-engine/media/refresh-query-32x.gif "Refresh query cursor operator icon")</span></span>|`Refresh Query`|<span data-ttu-id="c4cd0-496">`Refresh Query` 操作は、フェッチ バッファーから行の現在のデータをフェッチします。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-496">The `Refresh Query` operator fetches current data for rows in the fetch buffer.</span></span>|  
|<span data-ttu-id="c4cd0-497">![Remote Delete 操作アイコン](../../2014/database-engine/media/remote-delete-32x.gif "Remote Delete 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-497">![Remote delete operator icon](../../2014/database-engine/media/remote-delete-32x.gif "Remote delete operator icon")</span></span>|`Remote Delete`|<span data-ttu-id="c4cd0-498">`Remote Delete` 操作は、リモート オブジェクトから入力行を削除します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-498">The `Remote Delete` operator deletes the input rows from a remote object.</span></span> <span data-ttu-id="c4cd0-499">`Remote Delete` は論理操作でもあり、物理操作でもあります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-499">`Remote Delete` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="c4cd0-500">![remote index seek プラン表示操作](../../2014/database-engine/media/remote-index-scan-32x.gif "Remote Index Seek プラン表示操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-500">![remote index seek showplan operator](../../2014/database-engine/media/remote-index-scan-32x.gif "remote index seek showplan operator")</span></span>|<span data-ttu-id="c4cd0-501">**Remote Index Scan**</span><span class="sxs-lookup"><span data-stu-id="c4cd0-501">**Remote Index Scan**</span></span>|<span data-ttu-id="c4cd0-502">**Remote Index Scan** 操作は、Argument 列に指定されたリモート インデックスをスキャンします。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-502">The **Remote Index Scan** operator scans the remote index specified in the Argument column.</span></span> <span data-ttu-id="c4cd0-503">**Remote Index Scan** は論理操作でもあり、物理操作でもあります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-503">**Remote Index Scan** is a logical and physical operator.</span></span>|  
|<span data-ttu-id="c4cd0-504">![remote index seek プラン表示操作](../../2014/database-engine/media/remote-index-seek-32x.gif "Remote Index Seek プラン表示操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-504">![remote index seek showplan operator](../../2014/database-engine/media/remote-index-seek-32x.gif "remote index seek showplan operator")</span></span>|<span data-ttu-id="c4cd0-505">**Remote Index Seek**</span><span class="sxs-lookup"><span data-stu-id="c4cd0-505">**Remote Index Seek**</span></span>|<span data-ttu-id="c4cd0-506">**Remote Index Seek** 操作は、リモート インデックス オブジェクトのシーク機能を使用して行を取得します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-506">The **Remote Index Seek** operator uses the seeking ability of a remote index object to retrieve rows.</span></span> <span data-ttu-id="c4cd0-507">列には、使用され `Argument` ているリモートインデックスの名前と SEEK:() 述語が含まれています。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-507">The `Argument` column contains the name of the remote index being used and the SEEK:() predicate.</span></span> <span data-ttu-id="c4cd0-508">**Remote Index Seek** は論理操作でもあり、物理操作でもあります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-508">**Remote Index Seek** is a logical physical operator.</span></span>|  
|<span data-ttu-id="c4cd0-509">![Remote Insert 操作アイコン](../../2014/database-engine/media/remote-insert-32x.gif "Remote Insert 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-509">![Remote insert operator icon](../../2014/database-engine/media/remote-insert-32x.gif "Remote insert operator icon")</span></span>|<span data-ttu-id="c4cd0-510">**Remote Insert**</span><span class="sxs-lookup"><span data-stu-id="c4cd0-510">**Remote Insert**</span></span>|<span data-ttu-id="c4cd0-511">**Remote Insert** 操作では、入力行がリモート オブジェクトに挿入されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-511">The **Remote Insert** operator inserts the input rows into a remote object.</span></span> <span data-ttu-id="c4cd0-512">**Remote Insert** は論理操作でもあり、物理操作でもあります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-512">**Remote Insert** is a logical and physical operator.</span></span>|  
|<span data-ttu-id="c4cd0-513">![Remote Query 操作アイコン](../../2014/database-engine/media/remote-query-32x.gif "Remote Query 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-513">![Remote query operator icon](../../2014/database-engine/media/remote-query-32x.gif "Remote query operator icon")</span></span>|`Remote Query`|<span data-ttu-id="c4cd0-514">`Remote Query` 操作では、リモート ソースにクエリを送信します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-514">The `Remote Query` operator submits a query to a remote source.</span></span> <span data-ttu-id="c4cd0-515">リモートサーバーに送信されるクエリのテキストが列に表示され `Argument` ます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-515">The text of the query sent to the remote server appears in the `Argument` column.</span></span> <span data-ttu-id="c4cd0-516">`Remote Query` は論理操作でもあり、物理操作でもあります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-516">`Remote Query` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="c4cd0-517">![Remote Scan 操作アイコン](../../2014/database-engine/media/remote-scan-32x.gif "Remote Scan 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-517">![Remote scan operator icon](../../2014/database-engine/media/remote-scan-32x.gif "Remote scan operator icon")</span></span>|`Remote Scan`|<span data-ttu-id="c4cd0-518">`Remote Scan` 操作は、リモート オブジェクトをスキャンします。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-518">The `Remote Scan` operator scans a remote object.</span></span> <span data-ttu-id="c4cd0-519">リモートオブジェクトの名前が列に表示され `Argument` ます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-519">The name of the remote object appears in the `Argument` column.</span></span> <span data-ttu-id="c4cd0-520">`Remote Scan` は論理操作でもあり、物理操作でもあります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-520">`Remote Scan` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="c4cd0-521">![Remote Update 操作アイコン](../../2014/database-engine/media/remote-update-32x.gif "Remote Update 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-521">![Remote update operator icon](../../2014/database-engine/media/remote-update-32x.gif "Remote update operator icon")</span></span>|`Remote Update`|<span data-ttu-id="c4cd0-522">`Remote Update` 操作は、リモート オブジェクトの入力行を更新します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-522">The `Remote Update` operator updates the input rows in a remote object.</span></span> <span data-ttu-id="c4cd0-523">`Remote Update` は論理操作でもあり、物理操作でもあります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-523">`Remote Update` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="c4cd0-524">![Repartition Streams 並列処理操作アイコン](../../2014/database-engine/media/parallelism-repartition-stream.gif "Repartition Streams 並列処理操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-524">![Repartition streams parallelism operator icon](../../2014/database-engine/media/parallelism-repartition-stream.gif "Repartition streams parallelism operator icon")</span></span>|<span data-ttu-id="c4cd0-525">**Repartition Streams**</span><span class="sxs-lookup"><span data-stu-id="c4cd0-525">**Repartition Streams**</span></span>|<span data-ttu-id="c4cd0-526">**Repartition Streams** 操作では、複数のストリームを使用して、複数のレコードのストリームが生成されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-526">The **Repartition Streams** operator consumes multiple streams and produces multiple streams of records.</span></span> <span data-ttu-id="c4cd0-527">レコードの内容と形式は変更されません。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-527">The record contents and format are not changed.</span></span> <span data-ttu-id="c4cd0-528">クエリ オプティマイザーでビットマップ フィルターが使用される場合は、出力ストリームの行数が少なくなります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-528">If the query optimizer uses a bitmap filter, the number of rows in the output stream is reduced.</span></span> <span data-ttu-id="c4cd0-529">入力ストリームの各レコードは、1 つの出力ストリームに配置されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-529">Each record from an input stream is placed into one output stream.</span></span> <span data-ttu-id="c4cd0-530">この操作で順序を保持する場合、すべての入力ストリームが並べ替えられ、いくつかの並べ替え済みの出力ストリームにマージされる必要があります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-530">If this operator is order preserving, all input streams must be ordered and merged into several ordered output streams.</span></span> <span data-ttu-id="c4cd0-531">出力がパーティション分割されている場合、列には `Argument` PARTITION columns:() 述語とパーティション分割列が含まれます。出力が順序付けされている場合、この列には `Argument` ORDER BY:() 述語と順序付けされている列が含まれます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-531">If the output is partitioned, the `Argument` column contains a PARTITION COLUMNS:() predicate and the partitioning columns.If the output is ordered, the `Argument` column contains an ORDER BY:() predicate and the columns being ordered.</span></span> <span data-ttu-id="c4cd0-532">**Repartition Streams** は論理操作です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-532">**Repartition Streams** is a logical operator.</span></span> <span data-ttu-id="c4cd0-533">この操作は、並列クエリ プランのみで使用されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-533">The operator is used only in parallel query plans.</span></span>|  
|<span data-ttu-id="c4cd0-534">![Result 言語要素アイコン](../../2014/database-engine/media/result-32x.gif "Result 言語要素アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-534">![Result language element icon](../../2014/database-engine/media/result-32x.gif "Result language element icon")</span></span>|`Result`|<span data-ttu-id="c4cd0-535">`Result` 操作は、クエリ プランの最後に返されるデータです。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-535">The `Result` operator is the data returned at the end of a query plan.</span></span> <span data-ttu-id="c4cd0-536">これは通常、プラン表示のルート要素です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-536">This is usually the root element of a Showplan.</span></span> <span data-ttu-id="c4cd0-537">`Result` は言語要素です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-537">`Result` is a language element.</span></span>|  
|<span data-ttu-id="c4cd0-538">![RID Lookup 操作アイコン](../../2014/database-engine/media/rid-nonclust-locate-32x.gif "RID Lookup 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-538">![RID lookup operator icon](../../2014/database-engine/media/rid-nonclust-locate-32x.gif "RID lookup operator icon")</span></span>|`RID Lookup`|<span data-ttu-id="c4cd0-539">`RID Lookup` は、指定された行識別子 (RID) を使用する、ヒープ上のブックマーク参照です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-539">`RID Lookup` is a bookmark lookup on a heap using a supplied row identifier (RID).</span></span> <span data-ttu-id="c4cd0-540">列には、 `Argument` テーブル内の行を検索するために使用されるブックマークラベルと、行が検索されるテーブルの名前が含まれています。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-540">The `Argument` column contains the bookmark label used to look up the row in the table and the name of the table in which the row is looked up.</span></span> <span data-ttu-id="c4cd0-541">`RID Lookup` は、常に NESTED LOOP JOIN を伴います。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-541">`RID Lookup` is always accompanied by a NESTED LOOP JOIN.</span></span> <span data-ttu-id="c4cd0-542">`RID Lookup` は物理操作です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-542">`RID Lookup` is a physical operator.</span></span> <span data-ttu-id="c4cd0-543">ブックマーク参照の詳細については、MSDN の SQL Server ブログの「[ブックマーク参照](https://go.microsoft.com/fwlink/?LinkId=132568)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-543">For more information about bookmark lookups, see "[Bookmark Lookup](https://go.microsoft.com/fwlink/?LinkId=132568)" on the MSDN SQL Server blog.</span></span>|  
|<span data-ttu-id="c4cd0-544">なし</span><span class="sxs-lookup"><span data-stu-id="c4cd0-544">None</span></span>|`Right Anti Semi Join`|<span data-ttu-id="c4cd0-545">`Right Anti Semi Join` 操作は、2 番目 (下部) の入力の中で最初 (上部) の入力に一致する行がない各行を出力します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-545">The `Right Anti Semi Join` operator outputs each row from the second (bottom) input when a matching row in the first (top) input does not exist.</span></span> <span data-ttu-id="c4cd0-546">一致する行は、列の述語に適合する行として定義され `Argument` ます (述語が存在しない場合は、各行が一致する行になります)。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-546">A matching row is defined as a row that satisfies the predicate in the `Argument` column (if no predicate exists, each row is a matching row).</span></span> <span data-ttu-id="c4cd0-547">`Right Anti Semi Join` は論理操作です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-547">`Right Anti Semi Join` is a logical operator.</span></span>|  
|<span data-ttu-id="c4cd0-548">なし</span><span class="sxs-lookup"><span data-stu-id="c4cd0-548">None</span></span>|`Right Outer Join`|<span data-ttu-id="c4cd0-549">`Right Outer Join` 操作は、2 番目 (下部) の入力と最初 (上部) の入力の一致行との結合に適合する各行を返します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-549">The `Right Outer Join` operator returns each row that satisfies the join of the second (bottom) input with each matching row from the first (top) input.</span></span> <span data-ttu-id="c4cd0-550">また、2 番目の入力に最初の入力に一致する行がない場合は、2 番目の入力が NULL と結合された行も返します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-550">It also returns any rows from the second input that had no matching rows in the first input, joined with NULL.</span></span> <span data-ttu-id="c4cd0-551">列に結合述語が存在しない場合は `Argument` 、各行が一致する行になります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-551">If no join predicate exists in the `Argument` column, each row is a matching row.</span></span> <span data-ttu-id="c4cd0-552">`Right Outer Join` は論理操作です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-552">`Right Outer Join` is a logical operator.</span></span>|  
|<span data-ttu-id="c4cd0-553">なし</span><span class="sxs-lookup"><span data-stu-id="c4cd0-553">None</span></span>|`Right Semi Join`|<span data-ttu-id="c4cd0-554">`Right Semi Join` 操作は、2 番目 (下部) の入力の中に最初 (上部) の入力と一致する行があれば、該当する行を返します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-554">The `Right Semi Join` operator returns each row from the second (bottom) input when there is a matching row in the first (top) input.</span></span> <span data-ttu-id="c4cd0-555">列に結合述語が存在しない場合は `Argument` 、各行が一致する行になります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-555">If no join predicate exists in the `Argument` column, each row is a matching row.</span></span> <span data-ttu-id="c4cd0-556">`Right Semi Join` は論理操作です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-556">`Right Semi Join` is a logical operator.</span></span>|  
|<span data-ttu-id="c4cd0-557">![Row Count Spool 操作アイコン](../../2014/database-engine/media/remote-count-spool-32x.gif "Row Count Spool 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-557">![Row count spool operator icon](../../2014/database-engine/media/remote-count-spool-32x.gif "Row count spool operator icon")</span></span>|<span data-ttu-id="c4cd0-558">**Row Count Spool**</span><span class="sxs-lookup"><span data-stu-id="c4cd0-558">**Row Count Spool**</span></span>|<span data-ttu-id="c4cd0-559">**Row Count Spool** 操作では入力がスキャンされて存在する行数がカウントされ、同数の行がデータなしで返されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-559">The **Row Count Spool** operator scans the input, counting how many rows are present and returning the same number of rows without any data in them.</span></span> <span data-ttu-id="c4cd0-560">この操作は、行に含まれているデータではなく、行の存在チェックが重要な場合に使用されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-560">This operator is used when it is important to check for the existence of rows, rather than the data contained in the rows.</span></span> <span data-ttu-id="c4cd0-561">たとえば、 `Nested Loops` 演算子が左半結合演算を実行し、結合述語が内部入力に適用される場合、演算子の内部入力の先頭に行カウントスプールが配置されることがあり `Nested Loops` ます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-561">For example, if a `Nested Loops` operator performs a left semi join operation and the join predicate applies to inner input, a row count spool may be placed at the top of the inner input of the `Nested Loops` operator.</span></span> <span data-ttu-id="c4cd0-562">次 `Nested Loops` に、行カウントスプールによって出力される行数 (内部側の実際のデータが不要であるため) を指定して、外側の行を返すかどうかを判断できます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-562">Then the `Nested Loops` operator can determine how many rows are output by the row count spool (because the actual data from the inner side is not needed) to determine whether to return the outer row.</span></span> <span data-ttu-id="c4cd0-563">**Row Count Spool** は物理操作です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-563">**Row Count Spool** is a physical operator.</span></span>|  
|<span data-ttu-id="c4cd0-564">![Segment 操作アイコン](../../2014/database-engine/media/segment-32x.gif "Segment 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-564">![Segment operator icon](../../2014/database-engine/media/segment-32x.gif "Segment operator icon")</span></span>|<span data-ttu-id="c4cd0-565">**Segment**</span><span class="sxs-lookup"><span data-stu-id="c4cd0-565">**Segment**</span></span>|<span data-ttu-id="c4cd0-566">**Segment** は論理操作でもあり、物理操作でもあります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-566">**Segment** is a physical and a logical operator.</span></span> <span data-ttu-id="c4cd0-567">この操作は、1 つまたは複数の列の値に基づいて入力セットをセグメントに分割します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-567">It divides the input set into segments based on the value of one or more columns.</span></span> <span data-ttu-id="c4cd0-568">これらの列は、 **Segment** 操作に引数として表示されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-568">These columns are shown as arguments in the **Segment** operator.</span></span> <span data-ttu-id="c4cd0-569">この操作では、セグメントは 1 つずつ出力されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-569">The operator then outputs one segment at a time.</span></span>|  
|<span data-ttu-id="c4cd0-570">なし</span><span class="sxs-lookup"><span data-stu-id="c4cd0-570">None</span></span>|`Segment Repartition`|<span data-ttu-id="c4cd0-571">並列クエリ プランでは、反復子に概念上の領域が存在する場合があります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-571">In a parallel query plan, sometimes there are conceptual regions of iterators.</span></span> <span data-ttu-id="c4cd0-572">このような領域内にある反復子はすべて、並列スレッドにより実行できます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-572">All of the iterators within such a region can be executed by parallel threads.</span></span> <span data-ttu-id="c4cd0-573">領域自体は、順次実行される必要があります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-573">The regions themselves must be executed serially.</span></span> <span data-ttu-id="c4cd0-574">個別の領域内の `Parallelism` 反復子のいくつかは、`Branch Repartition` と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-574">Some of the `Parallelism` iterators within an individual region are called `Branch Repartition`.</span></span> <span data-ttu-id="c4cd0-575">このような 2 つの領域間の境界にある `Parallelism` 反復子は、`Segment Repartition` と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-575">The `Parallelism` iterator at the boundary of two such regions is called `Segment Repartition`.</span></span> <span data-ttu-id="c4cd0-576">`Branch Repartition` と `Segment Repartition` は論理操作です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-576">`Branch Repartition` and `Segment Repartition` are logical operators.</span></span>|  
|<span data-ttu-id="c4cd0-577">![Sequence 操作アイコン](../../2014/database-engine/media/sequence-32x.gif "Sequence 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-577">![Sequence operator icon](../../2014/database-engine/media/sequence-32x.gif "Sequence operator icon")</span></span>|`Sequence`|<span data-ttu-id="c4cd0-578">`Sequence` 操作によって、広範な更新プランを実行します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-578">The `Sequence` operator drives wide update plans.</span></span> <span data-ttu-id="c4cd0-579">機能的には、各入力を順次 (上から下へ) 実行します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-579">Functionally, it executes each input in sequence (top to bottom).</span></span> <span data-ttu-id="c4cd0-580">通常、各入力は異なるオブジェクトの更新です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-580">Each input is usually an update of a different object.</span></span> <span data-ttu-id="c4cd0-581">最後の (下部の) 入力からの行のみを返します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-581">It returns only those rows that come from its last (bottom) input.</span></span> <span data-ttu-id="c4cd0-582">`Sequence` は論理操作でもあり、物理操作でもあります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-582">`Sequence` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="c4cd0-583">![Sequence Project 操作アイコン](../../2014/database-engine/media/sequence-project-32x.gif "Sequence Project 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-583">![Sequence project operator icon](../../2014/database-engine/media/sequence-project-32x.gif "Sequence project operator icon")</span></span>|`Sequence Project`|<span data-ttu-id="c4cd0-584">`Sequence Project` 操作は、列を追加し、順序付けされたセットに対する計算を実行します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-584">The `Sequence Project` operator adds columns to perform computations over an ordered set.</span></span> <span data-ttu-id="c4cd0-585">この操作は、1 つまたは複数の列の値に基づいて入力セットをセグメントに分割します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-585">It divides the input set into segments based on the value of one or more columns.</span></span> <span data-ttu-id="c4cd0-586">この操作では、セグメントは 1 つずつ出力されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-586">The operator then outputs one segment at a time.</span></span> <span data-ttu-id="c4cd0-587">これらの列は、`Sequence Project` 操作の引数として表示されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-587">These columns are shown as arguments in the `Sequence Project` operator.</span></span> <span data-ttu-id="c4cd0-588">`Sequence Project` は論理操作でもあり、物理操作でもあります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-588">`Sequence Project` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="c4cd0-589">![Snapshot カーソル操作アイコン](../../2014/database-engine/media/snapshot-32x.gif "Snapshot カーソル操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-589">![Snapshot cursor operator icon](../../2014/database-engine/media/snapshot-32x.gif "Snapshot cursor operator icon")</span></span>|<span data-ttu-id="c4cd0-590">**スナップショット**</span><span class="sxs-lookup"><span data-stu-id="c4cd0-590">**Snapshot**</span></span>|<span data-ttu-id="c4cd0-591">**Snapshot** 操作は、他のユーザーによる変更を表示しないカーソルを作成します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-591">The **Snapshot** operator creates a cursor that does not see changes made by others.</span></span>|  
|<span data-ttu-id="c4cd0-592">![Sort 操作アイコン](../../2014/database-engine/media/sort-32x.gif "Sort 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-592">![Sort operator icon](../../2014/database-engine/media/sort-32x.gif "Sort operator icon")</span></span>|`Sort`|<span data-ttu-id="c4cd0-593">操作は、 `Sort` すべての受信行を並べ替えます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-593">The `Sort` operator sorts all incoming rows.</span></span> <span data-ttu-id="c4cd0-594">この列には、 `Argument` この操作によって重複が削除される場合は DISTINCT ORDER by:() 述語が含まれています。また、並べ替えられる列のコンマ区切りリストを含む ORDER by:() 述語が含まれています。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-594">The `Argument` column contains either a DISTINCT ORDER BY:() predicate if duplicates are removed by this operation, or an ORDER BY:() predicate with a comma-separated list of the columns being sorted.</span></span> <span data-ttu-id="c4cd0-595">列を昇順に並べ替える場合は、列名の前に値 ASC が付きます。降順に並べ替える場合は、列名の前に値 DESC が付きます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-595">The columns are prefixed with the value ASC if the columns are sorted in ascending order, or the value DESC if the columns are sorted in descending order.</span></span> <span data-ttu-id="c4cd0-596">`Sort` は論理操作でもあり、物理操作でもあります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-596">`Sort` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="c4cd0-597">![Split 操作アイコン](../../2014/database-engine/media/split-32x.gif "Split 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-597">![Split operator icon](../../2014/database-engine/media/split-32x.gif "Split operator icon")</span></span>|`Split`|<span data-ttu-id="c4cd0-598">`Split`操作は、更新処理を最適化するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-598">The `Split` operator is used to optimize update processing.</span></span> <span data-ttu-id="c4cd0-599">この操作により、各更新操作が削除操作と挿入操作に分割されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-599">It splits each update operation into a delete and an insert operation.</span></span> <span data-ttu-id="c4cd0-600">`Split` は論理操作でもあり、物理操作でもあります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-600">`Split` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="c4cd0-601">![Spool 操作アイコン](../../2014/database-engine/media/spool-32x.gif "Spool 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-601">![Spool operator icon](../../2014/database-engine/media/spool-32x.gif "Spool operator icon")</span></span>|<span data-ttu-id="c4cd0-602">**Spool**</span><span class="sxs-lookup"><span data-stu-id="c4cd0-602">**Spool**</span></span>|<span data-ttu-id="c4cd0-603">**Spool**操作は、クエリの中間結果をデータベースに保存し `tempdb` ます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-603">The **Spool** operator saves an intermediate query result to the `tempdb` database.</span></span>|  
|<span data-ttu-id="c4cd0-604">![Stream Aggregate 操作アイコン](../../2014/database-engine/media/stream-aggregate-32x.gif "Stream Aggregate 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-604">![Stream aggregate operator icon](../../2014/database-engine/media/stream-aggregate-32x.gif "Stream aggregate operator icon")</span></span>|`Stream Aggregate`|<span data-ttu-id="c4cd0-605">`Stream Aggregate` 操作は、1 つ以上の列を基準にして行をグループ化し、クエリから返される 1 つ以上の集計式を計算します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-605">The `Stream Aggregate` operator groups rows by one or more columns and then calculates one or more aggregate expressions returned by the query.</span></span> <span data-ttu-id="c4cd0-606">この操作の出力は、クエリ内のその後の操作から参照することも、クライアントに返すことも、あるいはその両方を行うこともできます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-606">The output of this operator can be referenced by later operators in the query, returned to the client, or both.</span></span> <span data-ttu-id="c4cd0-607">`Stream Aggregate` 操作を使用するには、グループ内で列を基準にして入力を並べ替えておく必要があります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-607">The `Stream Aggregate` operator requires input ordered by the columns within its groups.</span></span> <span data-ttu-id="c4cd0-608">並べ替えられたインデックスのシークやスキャンまたは前の `Sort` 操作が原因でデータがまだ並べ替えられていない場合は、オプティマイザーによって、この操作の前に `Sort` 操作が使用されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-608">The optimizer will use a `Sort` operator prior to this operator if the data is not already sorted due to a prior `Sort` operator or due to an ordered index seek or scan.</span></span> <span data-ttu-id="c4cd0-609">の SHOWPLAN_ALL ステートメントまたはグラフィカルな実行プランでは、 [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)] GROUP BY 述語の列が列に一覧表示され、 `Argument` 集計式が [**定義済みの値**] 列に一覧表示されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-609">In the SHOWPLAN_ALL statement or the graphical execution plan in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)], the columns in the GROUP BY predicate are listed in the `Argument` column, and the aggregate expressions are listed in the **Defined Values** column.</span></span> <span data-ttu-id="c4cd0-610">`Stream Aggregate` は物理操作です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-610">`Stream Aggregate` is a physical operator.</span></span>|  
|<span data-ttu-id="c4cd0-611">![Switch 操作アイコン](../../2014/database-engine/media/switch-32x.gif "Switch 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-611">![Switch operator icon](../../2014/database-engine/media/switch-32x.gif "Switch operator icon")</span></span>|<span data-ttu-id="c4cd0-612">**スイッチ**</span><span class="sxs-lookup"><span data-stu-id="c4cd0-612">**Switch**</span></span>|<span data-ttu-id="c4cd0-613">**Switch** は、 *n* 個の入力を取得する特殊な連結反復子です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-613">**Switch** is a special type of concatenation iterator that has *n* inputs.</span></span> <span data-ttu-id="c4cd0-614">個々の **Switch** 操作には式が 1 つ関連付けられます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-614">An expression is associated with each **Switch** operator.</span></span> <span data-ttu-id="c4cd0-615">*Switch*操作は式の戻り値 (0 から **n** -1 までの範囲) に応じて、適切な入力ストリームを出力ストリームにコピーします。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-615">Depending on the return value of the expression (between 0 and *n*-1), **Switch** copies the appropriate input stream to the output stream.</span></span> <span data-ttu-id="c4cd0-616">**Switch** 操作の用途の 1 つは、高速順方向専用カーソルを使用するクエリ プランに **TOP** などの特定の操作を実装することです。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-616">One use of **Switch** is to implement query plans involving fast forward cursors with certain operators such as the **TOP** operator.</span></span> <span data-ttu-id="c4cd0-617">**Switch** は論理操作でもあり、物理操作でもあります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-617">**Switch** is both a logical and physical operator.</span></span>|  
|<span data-ttu-id="c4cd0-618">![Table Delete 操作アイコン](../../2014/database-engine/media/table-delete-32x.gif "Table Delete 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-618">![Table delete operator icon](../../2014/database-engine/media/table-delete-32x.gif "Table delete operator icon")</span></span>|`Table Delete`|<span data-ttu-id="c4cd0-619">`Table Delete`物理操作は、 `Argument` クエリ実行プランの列に指定されているテーブルから行を削除します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-619">The `Table Delete` physical operator deletes rows from the table specified in the `Argument` column of the query execution plan.</span></span>|  
|<span data-ttu-id="c4cd0-620">![Table Insert 操作アイコン](../../2014/database-engine/media/table-insert-32x.gif "Table Insert 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-620">![Table insert operator icon](../../2014/database-engine/media/table-insert-32x.gif "Table insert operator icon")</span></span>|`Table Insert`|<span data-ttu-id="c4cd0-621">操作は、 `Table Insert` `Argument` クエリ実行プランの列に指定されたテーブルに、入力から行を挿入します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-621">The `Table Insert` operator inserts rows from its input into the table specified in the `Argument` column of the query execution plan.</span></span> <span data-ttu-id="c4cd0-622">また、`Argument` 列には、各列に設定する値を示す SET:() 述語も含まれます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-622">The `Argument` column also contains a SET:() predicate, which indicates the value to which each column is set.</span></span> <span data-ttu-id="c4cd0-623">`Table Insert` に挿入値の子がない場合、挿入される行は、Insert 操作自体から取得されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-623">If `Table Insert` has no children for insert values, then the row inserted is taken from the Insert operator itself.</span></span> <span data-ttu-id="c4cd0-624">`Table Insert` は物理操作です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-624">`Table Insert` is a physical operator.</span></span>|  
|<span data-ttu-id="c4cd0-625">![Table Merge 操作アイコン](../../2014/database-engine/media/table-merge-32x.gif "Table Merge 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-625">![Table merge operator](../../2014/database-engine/media/table-merge-32x.gif "Table merge operator")</span></span>|<span data-ttu-id="c4cd0-626">**Table Merge**</span><span class="sxs-lookup"><span data-stu-id="c4cd0-626">**Table Merge**</span></span>|<span data-ttu-id="c4cd0-627">**Table Merge** 操作は、マージ データ ストリームをヒープに適用します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-627">The **Table Merge** operator applies a merge data stream to a heap.</span></span> <span data-ttu-id="c4cd0-628">操作は、演算子の列で指定されたテーブルの行を削除、更新、または挿入し `Argument` ます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-628">The operator deletes, updates, or inserts rows in the table specified in the `Argument` column of the operator.</span></span> <span data-ttu-id="c4cd0-629">実際に実行される操作は、演算子の列に指定された**アクション**列の実行時の値によって異なり `Argument` ます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-629">The actual operation performed depends on the run-time value of the **ACTION** column specified in the `Argument` column of the operator.</span></span> <span data-ttu-id="c4cd0-630">**Table Merge** は物理操作です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-630">**Table Merge** is a physical operator.</span></span>|  
|<span data-ttu-id="c4cd0-631">![Table Scan 操作アイコン](../../2014/database-engine/media/table-scan-32x.gif "Table Scan 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-631">![Table scan operator icon](../../2014/database-engine/media/table-scan-32x.gif "Table scan operator icon")</span></span>|`Table Scan`|<span data-ttu-id="c4cd0-632">操作は、 `Table Scan` クエリ実行プランの列に指定されているテーブルからすべての行を取得 `Argument` します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-632">The `Table Scan` operator retrieves all rows from the table specified in the `Argument` column of the query execution plan.</span></span> <span data-ttu-id="c4cd0-633">列に WHERE:() 述語が含まれている場合 `Argument` 、述語に適合する行だけが返されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-633">If a WHERE:() predicate appears in the `Argument` column, only those rows that satisfy the predicate are returned.</span></span> <span data-ttu-id="c4cd0-634">`Table Scan` は論理操作でもあり、物理操作でもあります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-634">`Table Scan` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="c4cd0-635">![Table Spool 操作アイコン](../../2014/database-engine/media/table-spool-32x.gif "Table Spool 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-635">![Table spool operator icon](../../2014/database-engine/media/table-spool-32x.gif "Table spool operator icon")</span></span>|<span data-ttu-id="c4cd0-636">**Table Spool**</span><span class="sxs-lookup"><span data-stu-id="c4cd0-636">**Table Spool**</span></span>|<span data-ttu-id="c4cd0-637">**Table Spool** 操作は入力をスキャンし、隠しスプール テーブルに各行のコピーを格納します。この隠しスプール テーブルは [tempdb](../relational-databases/databases/tempdb-database.md) データベースに格納され、クエリの有効期間だけ存在します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-637">The **Table Spool** operator scans the input and places a copy of each row in a hidden spool table that is stored in the [tempdb](../relational-databases/databases/tempdb-database.md) database and existing only for the lifetime of the query.</span></span> <span data-ttu-id="c4cd0-638">演算子が巻き戻し (たとえば、演算子によって) されていても、再バインドが不要な場合は、入力を再 `Nested Loops` スキャンする代わりにスプールされたデータが使用されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-638">If the operator is rewound (for example, by a `Nested Loops` operator) but no rebinding is needed, the spooled data is used instead of rescanning the input.</span></span> <span data-ttu-id="c4cd0-639">**Table Spool** は物理操作です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-639">**Table Spool** is a physical operator.</span></span>|  
|<span data-ttu-id="c4cd0-640">![Table Update 操作アイコン](../../2014/database-engine/media/table-update-32x.gif "Table Update 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-640">![Table update operator icon](../../2014/database-engine/media/table-update-32x.gif "Table update operator icon")</span></span>|`Table Update`|<span data-ttu-id="c4cd0-641">`Table Update`物理操作は、 `Argument` クエリ実行プランの列に指定されているテーブルの入力行を更新します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-641">The `Table Update` physical operator updates input rows in the table specified in the `Argument` column of the query execution plan.</span></span> <span data-ttu-id="c4cd0-642">SET:() 述語によって、更新された各列の値が決定されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-642">The SET:() predicate determines the value of each updated column.</span></span> <span data-ttu-id="c4cd0-643">これらの値は、SET 句、またはこの操作内かこのクエリ内で参照されることがあります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-643">These values may be referenced in the SET clause or elsewhere within this operator as well as elsewhere within this query.</span></span>|  
|<span data-ttu-id="c4cd0-644">![Table-valued Function 操作アイコン](../../2014/database-engine/media/table-valued-function-32x.gif "Table-valued Function 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-644">![Table-valued function operator icon](../../2014/database-engine/media/table-valued-function-32x.gif "Table-valued function operator icon")</span></span>|<span data-ttu-id="c4cd0-645">**Table-valued Function**</span><span class="sxs-lookup"><span data-stu-id="c4cd0-645">**Table-valued Function**</span></span>|<span data-ttu-id="c4cd0-646">**Table-valued Function** 操作は、テーブル値関数 ( [!INCLUDE[tsql](../includes/tsql-md.md)] または CLR のいずれか) を評価し、結果行を [tempdb](../relational-databases/databases/tempdb-database.md) データベースに格納します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-646">The **Table-valued Function** operator evaluates a table-valued function (either [!INCLUDE[tsql](../includes/tsql-md.md)] or CLR), and stores the resulting rows in the [tempdb](../relational-databases/databases/tempdb-database.md) database.</span></span> <span data-ttu-id="c4cd0-647">親の反復子が行を要求すると、**テーブル値関数**はから行を返し `tempdb` ます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-647">When the parent iterators request the rows, **Table-valued Function** returns the rows from `tempdb`.</span></span><br /><br /> <span data-ttu-id="c4cd0-648">テーブル値関数への呼び出しを伴うクエリにより、 **Table-valued Function** 反復子を備えたクエリ プランが生成されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-648">Queries with calls to table-valued functions generate query plans with the **Table-valued Function** iterator.</span></span> <span data-ttu-id="c4cd0-649">さまざまなパラメーター値を使用して**Table-valued Function** を評価できます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-649">**Table-valued Function** can be evaluated with different parameter values:</span></span><br /><br /> <span data-ttu-id="c4cd0-650">**Table-valued Function XML Reader** では、パラメーターとして XML BLOB が入力され、XML ノードを表す行セットが XML ドキュメントの順序で生成されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-650">**Table-valued Function XML Reader** inputs an XML BLOB as a parameter and produces a rowset representing XML nodes in XML document order.</span></span> <span data-ttu-id="c4cd0-651">他の入力パラメーターにより、XML ドキュメントのサブセットに返される XML ノードが制限されることがあります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-651">Other input parameters may restrict XML nodes returned to a subset of XML document.</span></span><br /><br /> <span data-ttu-id="c4cd0-652">**Table Valued Function XML Reader with XPath filter** は、出力を XPath 式が満たされる XML ノードに限定する、特殊な種類の **XML Reader Table-valued Function** です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-652">**Table Valued Function XML Reader with XPath filter** is a special type of **XML Reader Table-valued Function** that restricts output to XML nodes satisfying an XPath expression.</span></span><br /><br /> <br /><br /> <span data-ttu-id="c4cd0-653">**Table-valued Function** は論理操作でもあり、物理操作でもあります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-653">**Table-valued Function** is a logical and physical operator.</span></span>|  
|<span data-ttu-id="c4cd0-654">![Top 操作アイコン](../../2014/database-engine/media/top-32x.gif "Top 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-654">![Top operator icon](../../2014/database-engine/media/top-32x.gif "Top operator icon")</span></span>|<span data-ttu-id="c4cd0-655">**上位**</span><span class="sxs-lookup"><span data-stu-id="c4cd0-655">**Top**</span></span>|<span data-ttu-id="c4cd0-656">**Top** 操作は、入力をスキャンし、並べ替え順に基づいて、指定した最初の数または最初の比率の行だけを返します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-656">The **Top** operator scans the input, returning only the first specified number or percent of rows, possibly based on a sort order.</span></span> <span data-ttu-id="c4cd0-657">列には、結合 `Argument` のチェック対象となる列の一覧を含めることができます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-657">The `Argument` column can contain a list of the columns that are being checked for ties.</span></span> <span data-ttu-id="c4cd0-658">**Top** 操作は、更新プランで行数制限を行うときに使用します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-658">In update plans, the **Top** operator is used to enforce row count limits.</span></span> <span data-ttu-id="c4cd0-659">**Top** は論理操作でもあり、物理操作でもあります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-659">**Top** is a logical and physical operator.</span></span> <span data-ttu-id="c4cd0-660">**Top** は論理操作でもあり、物理操作でもあります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-660">**Top** is a logical and physical operator.</span></span>|  
|<span data-ttu-id="c4cd0-661">なし</span><span class="sxs-lookup"><span data-stu-id="c4cd0-661">None</span></span>|<span data-ttu-id="c4cd0-662">**Top N Sort**</span><span class="sxs-lookup"><span data-stu-id="c4cd0-662">**Top N Sort**</span></span>|<span data-ttu-id="c4cd0-663">**Top n Sort**は反復子に似ていますが、 `Sort` 結果セット全体ではなく、最初の*n*行だけが必要です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-663">**Top N Sort** is similar to the `Sort` iterator, except that only the first *N* rows are needed, and not the entire result set.</span></span> <span data-ttu-id="c4cd0-664">*N*の値が小さい場合、 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] のクエリ実行エンジンは、メモリ内全体の並べ替え操作を実行しようとします。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-664">For small values of *N*, the [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] query execution engine attempts to perform the entire sort operation in memory.</span></span> <span data-ttu-id="c4cd0-665">*N*の値が大きい場合、クエリ実行エンジンは、 *N* をパラメーターとしない、より汎用的な並べ替え方法を使用します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-665">For large values of *N*, the query execution engine resorts to the more generic method of sorting to which *N* is not a parameter.</span></span>|  
|<span data-ttu-id="c4cd0-666">![拡張操作 (UDX) のアイコン](../../2014/database-engine/media/udx-32x.gif "拡張操作 (UDX) のアイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-666">![Extended operator (UDX) icon](../../2014/database-engine/media/udx-32x.gif "Extended operator (UDX) icon")</span></span>|`UDX`|<span data-ttu-id="c4cd0-667">拡張操作 (UDX) には、 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]の数ある操作のうちの XQuery 操作と XPath 操作が実装されています。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-667">Extended Operators (UDX) implement one of many XQuery and XPath operations in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="c4cd0-668">すべての UDX 操作には、論理操作と物理操作の両方があります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-668">All UDX operators are both logical and physical operators.</span></span><br /><br /> <span data-ttu-id="c4cd0-669">拡張操作 (UDX) `FOR XML` は、単一出力行の単一 BLOB 列に XML 表記で入力するリレーショナル行セットをシリアル化するのに使用します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-669">Extended operator (UDX) `FOR XML` is used to serialize the relational row set it inputs into XML representation in a single BLOB column in a single output row.</span></span> <span data-ttu-id="c4cd0-670">この操作は、順序を区別する XML 集計操作です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-670">It is an order sensitive XML aggregation operator.</span></span><br /><br /> <span data-ttu-id="c4cd0-671">拡張操作 (UDX) `XML SERIALIZER` は、順序を区別する XML 集計操作です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-671">Extended operator (UDX) `XML SERIALIZER` is an order sensitive XML aggregation operator.</span></span> <span data-ttu-id="c4cd0-672">この操作は、XML ドキュメントの順序で XML ノードまたは XQuery スカラーを表す行を入力し、単一出力行の単一 XML 列にシリアル化した XML BLOB を生成します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-672">It inputs rows representing XML nodes or XQuery scalars in XML document order and produces a serialized XML BLOB in a single XML column in a single output row.</span></span><br /><br /> <span data-ttu-id="c4cd0-673">拡張操作 (UDX) `XML FRAGMENT SERIALIZER` は、XQuery の挿入データの変更拡張に挿入される XML フラグメントを表す入力行の処理に使用する `XML SERIALIZER` の特殊な形式の操作です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-673">Extended operator (UDX) `XML FRAGMENT SERIALIZER` is a special type of `XML SERIALIZER` that is used for processing input rows representing XML fragments being inserted in XQuery insert data modification extension.</span></span><br /><br /> <span data-ttu-id="c4cd0-674">拡張操作 (UDX) `XQUERY STRING` は、XML ノードを表す入力行の XQuery 文字列値を評価します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-674">Extended operator (UDX) `XQUERY STRING` evaluates the XQuery string value of input rows representing XML nodes.</span></span> <span data-ttu-id="c4cd0-675">これは順序を区別する文字列集計操作です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-675">It is an order sensitive string aggregation operator.</span></span> <span data-ttu-id="c4cd0-676">この操作では、入力の文字列値を含む XQuery スカラーを表す列を持つ 1 行が出力されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-676">It outputs one row with columns representing the XQuery scalar that contains string value of the input.</span></span><br /><br /> <span data-ttu-id="c4cd0-677">拡張操作 (UDX) `XQUERY LIST DECOMPOSER` は、XQuery のリスト分解操作です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-677">Extended operator (UDX) `XQUERY LIST DECOMPOSER` is an XQuery list decomposition operator.</span></span> <span data-ttu-id="c4cd0-678">入力が XSD リストで想定されている型の場合、この操作では、XML ノードを表す入力行ごとに、リスト要素の値を含む XQuery スカラーを表す 1 行以上の行が生成されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-678">For each input row representing an XML node it produces one or more rows each representing XQuery scalar containing a list element value if the input is of XSD list type.</span></span><br /><br /> <span data-ttu-id="c4cd0-679">拡張操作 (UDX) `XQUERY DATA` は、XML ノードを表す入力の XQuery の fn:data() 関数を評価します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-679">Extended operator (UDX) `XQUERY DATA` evaluates the XQuery fn:data() function on input representing XML nodes.</span></span> <span data-ttu-id="c4cd0-680">これは順序を区別する文字列集計操作です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-680">It is an order sensitive string aggregation operator.</span></span> <span data-ttu-id="c4cd0-681">この操作では、 **fn:data()** 関数の結果を含む XQuery スカラーを表す列を持つ 1 行が出力されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-681">It outputs one row with columns representing XQuery scalar that contains the result of **fn:data()**.</span></span><br /><br /> <span data-ttu-id="c4cd0-682">拡張操作 `XQUERY CONTAINS` は、XML ノードを表す入力の XQuery の fn:contains() 関数を評価します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-682">Extended operator `XQUERY CONTAINS` evaluates the XQuery fn:contains() function on input representing XML nodes.</span></span> <span data-ttu-id="c4cd0-683">これは順序を区別する文字列集計操作です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-683">It is an order sensitive string aggregation operator.</span></span> <span data-ttu-id="c4cd0-684">この操作では、 **fn:contains()** 関数の結果を含む XQuery スカラーを表す列を持つ 1 行が出力されます。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-684">It outputs one row with columns representing XQuery scalar that contains the result of **fn:contains()**.</span></span><br /><br /> <span data-ttu-id="c4cd0-685">拡張操作は `UPDATE XML NODE` 、xml 型の**modify ()** メソッドで XQuery 置換データ変更拡張の xml ノードを更新します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-685">Extended operator `UPDATE XML NODE` updates XML node in the XQuery replace data modification extension in the **modify()** method on XML type.</span></span>|  
|<span data-ttu-id="c4cd0-686">なし</span><span class="sxs-lookup"><span data-stu-id="c4cd0-686">None</span></span>|<span data-ttu-id="c4cd0-687">**Union (結合)**</span><span class="sxs-lookup"><span data-stu-id="c4cd0-687">**Union**</span></span>|<span data-ttu-id="c4cd0-688">**Union** 操作は、複数の入力をスキャンし、重複行を削除して、スキャンした各行を出力します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-688">The **Union** operator scans multiple inputs, outputting each row scanned and removing duplicates.</span></span> <span data-ttu-id="c4cd0-689">**Union** は論理操作です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-689">**Union** is a logical operator.</span></span>|  
|<span data-ttu-id="c4cd0-690">![Update (データベース エンジン) 操作アイコン](../../2014/database-engine/media/update-32x.gif "Update (データベース エンジン) 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-690">![Update (Database Engine) operator icon](../../2014/database-engine/media/update-32x.gif "Update (Database Engine) operator icon")</span></span>|`Update`|<span data-ttu-id="c4cd0-691">操作は、 `Update` `Argument` クエリ実行プランの列に指定されているオブジェクトの入力から各行を更新します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-691">The `Update` operator updates each row from its input in the object specified in the `Argument` column of the query execution plan.</span></span> <span data-ttu-id="c4cd0-692">`Update` は論理操作です。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-692">`Update` is a logical operator.</span></span> <span data-ttu-id="c4cd0-693">物理操作には、`Table Update`、`Index Update`、および `Clustered Index Update` があります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-693">The physical operator is `Table Update`, `Index Update`, or `Clustered Index Update`.</span></span>|  
|<span data-ttu-id="c4cd0-694">![While 言語要素アイコン](../../2014/database-engine/media/while-32x.gif "While 言語要素アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-694">![While language element icon](../../2014/database-engine/media/while-32x.gif "While language element icon")</span></span>|`While`|<span data-ttu-id="c4cd0-695">`While` 操作は [!INCLUDE[tsql](../includes/tsql-md.md)] while ループを実装します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-695">The `While` operator implements the [!INCLUDE[tsql](../includes/tsql-md.md)] while loop.</span></span> <span data-ttu-id="c4cd0-696">`While`は言語要素です</span><span class="sxs-lookup"><span data-stu-id="c4cd0-696">`While` is a language element</span></span>|  
|<span data-ttu-id="c4cd0-697">![Table Spool 操作アイコン](../../2014/database-engine/media/table-spool-32x.gif "Table Spool 操作アイコン")</span><span class="sxs-lookup"><span data-stu-id="c4cd0-697">![Table spool operator icon](../../2014/database-engine/media/table-spool-32x.gif "Table spool operator icon")</span></span>|`Window Spool`|<span data-ttu-id="c4cd0-698">`Window Spool` 操作は、各行をその行に関連付けられたウィンドウを表す行セットに拡張します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-698">The `Window Spool` operator expands each row into the set of rows that represents the window associated with it.</span></span> <span data-ttu-id="c4cd0-699">クエリでは、OVER 句でクエリの結果セット内のウィンドウを定義してから、ウィンドウ関数がウィンドウ内の各行の値を計算します。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-699">In a query, the OVER clause defines the window within a query result set and a window function then computes a value for each row in the window.</span></span> <span data-ttu-id="c4cd0-700">`Window Spool` は論理操作でもあり、物理操作でもあります。</span><span class="sxs-lookup"><span data-stu-id="c4cd0-700">`Window Spool` is a logical and physical operator.</span></span>|  
  
  
